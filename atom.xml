<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>囿</title>
  
  <subtitle>A 21st century single-player.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nulllstack.github.io/"/>
  <updated>2020-05-03T01:15:14.766Z</updated>
  <id>https://nulllstack.github.io/</id>
  
  <author>
    <name>John</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Haxe编程入门</title>
    <link href="https://nulllstack.github.io/2020/05/03/Haxe%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://nulllstack.github.io/2020/05/03/Haxe编程入门/</id>
    <published>2020-05-02T22:45:08.000Z</published>
    <updated>2020-05-03T01:15:14.766Z</updated>
    
    <content type="html"><![CDATA[<p>Still work-in-progress…</p><hr><p><a href="http://01010111.com/?index/tutorials/programming_in_haxe#programming-in-haxe" target="_blank" rel="noopener">原文链接</a></p><p>嗨！ 这是一篇 Haxe 语言编程的快速入门指南，Haxe 是一门强类型语言，许多人（包括我自己）使用它来开发游戏、app、网站以及许许多多其他的东西。</p><p>我将会介绍一些计算机基础相关的内容，所以你不必担心自己之前没有过编程经验。</p><p>跟随这篇教程，你不需要下载任何东西，只需要前往 <a href="https://try.haxe.org/" target="_blank" rel="noopener">try.haxe.org</a> 即可在网页端在线编译每个小节的例程。</p><hr><h2 id="Part-One-介绍"><a href="#Part-One-介绍" class="headerlink" title="Part One - 介绍"></a>Part One - 介绍</h2><p>如果你还在犹豫是否应该使用 Haxe 来开发你的下一个项目，那么尝试询问自己以下几个问题：</p><ul><li>类似 Java, C++, PHP, 或 AS3 这样的面向对象编程语言你使用起来是否感到舒适？</li><li>你是否希望你的下一个项目在多平台下运行（HTML5, Flash, Windows, Mac/OSX, Linux, Android, iOS 等）？</li><li>你是否对开源项目以及社区感到有兴趣？</li><li>你是否为了学习 Haxe 而来到这篇教程？</li></ul><p>如果以上问题有任何一个的回答是 “yes” 那么或许 Haxe 对你而言会是个不错的选择！</p><p>那么 Haxe 的源码看起来长啥样呢？</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here are some variables!</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> my_name:<span class="type">String </span>= <span class="string">'Will'</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> my_likes:<span class="type">Array</span>&lt;<span class="keyword">String</span>&gt; = [</span><br><span class="line">        <span class="string">'gamedev'</span>,</span><br><span class="line">        <span class="string">'cheeseburgers'</span>,</span><br><span class="line">        <span class="string">'karaoke'</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">trace</span>(<span class="string">'Hi! My name is <span class="subst">$my_name, and I really like...');</span></span></span><br><span class="line"><span class="string"><span class="subst"></span></span></span><br><span class="line"><span class="string"><span class="subst">        for (i in 0...my_likes.length)</span></span></span><br><span class="line"><span class="string"><span class="subst">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">            trace(my_likes[i]);</span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span></span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>你可以通过两个斜杠（//）在你的源码中创建一个“行注释”，你的程序编译时，编译器将会自动忽略位于双斜杠之后与双斜杠同行的任何内容，我将会在我的例程中加入一些这样的注释对代码进行批注，所以你应该注意一下这些内容。</p><p>如果这些代码现在对你而言就是天书的话，不要紧！在接下来的一个小时里你将学会编写比上面有趣得多的代码！</p><hr><h2 id="Part-Two-类（Classes）"><a href="#Part-Two-类（Classes）" class="headerlink" title="Part Two - 类（Classes）"></a>Part Two - 类（Classes）</h2><p>一个类即是数据的组织结构，它由一个名称，一个路径以及零或多个成员构成。前往 <a href="https://try.haxe.org/" target="_blank" rel="noopener">try.haxe.org</a> ，你将会得到如下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">trace</span>(<span class="string">"Haxe is great!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到这个类被命名为 <strong>Test</strong> ，但是它的路径被隐式声明为其所在的根目录了。如果你想显式地声明其路径的话，你可以在代码的顶部位置添加以下这行代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>;</span><br></pre></td></tr></table></figure><p>此处由于并没有在 <code>package</code> 之后声明一个路径，所以这个语句会将路径隐式定义为源码所在的根目录，但是如果你在自己的编辑器中构建自己的程序，且你的源码由如下目录结构构成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source</span><br><span class="line">|__objects</span><br><span class="line">   |__people</span><br><span class="line">      |__Person.hx</span><br><span class="line">      </span><br><span class="line">//Person.hx 源码文件被存放于people文件夹内，people 文件夹被存放于 objects 文件夹内...</span><br></pre></td></tr></table></figure><p>那么你就需要将路径定义为：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> objects.people;</span><br></pre></td></tr></table></figure><p>如果你是在 try.haxe.org 中编写代码，那么你现在不需要担心路径的问题，但是如果你开始在本机编写程序那么这里给出的信息将会很有用。</p><p>最后，try.haxe.org 给出的源码中有一个成员，是一个名为 <code>main()</code> 的函数。类成员由类体的一对封闭的花括号（{}）所包围。</p><p>注意，一个代码块由一对封闭的花括号（{}）组成，且其中的每一条指令都由一个分号（;）表示结束。</p><p>类中还可以包含另外一种形式的类成员 - <strong>变量（variable）</strong> ！</p><hr><h2 id="Part-Three-变量（Variables）"><a href="#Part-Three-变量（Variables）" class="headerlink" title="Part Three - 变量（Variables）"></a>Part Three - 变量（Variables）</h2><p>一个变量是一个被给定名字的对象或值，通过名字你可以引用或改变其值。在 Haxe 中有以下几种基础类型的变量：</p><ul><li>Bool（单词 boolean 的缩写）：这种类型可存储两种值 - 真（true）或 假（false）</li><li>Int （单词 Integer 的缩写）：这种类型可用于存储整数值如： -14 或 256。 也可以以十六进制表示 0xF000D。</li><li>Float（即浮点数 (floating-point number)）：即具备小数位的数字（注意你可以为一个要求使用 Float 类型的位置使用 Int 类型的值代替，但是反之则不行）。</li><li>String：用于存储一串字符如 “Hello World!” 你可以通过使用一对双引号或单引号括住一串字符来创建一个字符串如：<code>&quot;double quotation marks&quot;</code> 或 <code>&#39;single quotation marks&#39;</code> 。</li></ul><p>让我们来添加其中几种到我们的代码中：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> alive:<span class="type">Bool </span>= <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> age:<span class="type">Int </span>= <span class="number">70</span>;</span><br><span class="line"><span class="keyword">var</span> name:<span class="type">String </span>= <span class="string">'Buck'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">trace</span>(<span class="string">"Haxe is great!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们稍微修改一下<code>trace()</code>的调用使其引用我们我们的变量！</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trace</span>(<span class="string">'<span class="subst">$name is $age years old.');</span></span></span><br></pre></td></tr></table></figure><p>这里你可能会注意到我们在一些单词前放置了一个美元符号。</p><p>这是由于在 Haxe 中有一个称为 <em>字符串插入（String Interpolation）</em> 的语言特性，这一语言特性使得我们可以在字符串中插入一个变量或是一个表达式，但是只有当该字符串是由一对单引号括住的形式出现时才能使用这一语言特性。</p><hr><h2 id="Part-Four-对象（Objects）"><a href="#Part-Four-对象（Objects）" class="headerlink" title="Part Four - 对象（Objects）"></a>Part Four - 对象（Objects）</h2><p>一个对象即是一个类的 <em>实例（instance）</em> 。你可以理解为一个类即是用于创建对象时所使用的蓝图。</p><p>让我们来把那些个人信息组织进一个名为 <strong>Person</strong> 的类中吧。在你的代码的最下方添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> alive:<span class="type">Bool</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> age:<span class="type">Int</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> name:<span class="type">String</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(_alive:<span class="type">Bool</span>, _age:<span class="type">Int</span>, _name:<span class="type">String</span>)</span><br><span class="line">&#123;</span><br><span class="line">alive = _alive;</span><br><span class="line">age = _age;</span><br><span class="line">name = _name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意一下 <code>new()</code> 函数，任何可以被实例化为对象的类都应该具备一个 <code>new()</code> 函数 - 这是一个类的构造函数（constructor），被用于初始化对象的代码都位于其中。</p><p>现在让我们回到 <em>Test</em> 类中，并整理一下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> buck:<span class="type">Person </span>= <span class="keyword">new</span> <span class="type">Person</span>(<span class="literal">true</span>, <span class="number">70</span>, <span class="string">'Buck'</span>);</span><br><span class="line"><span class="built_in">trace</span>(<span class="string">'<span class="subst">$name is $age years old.');</span></span></span><br><span class="line"><span class="string"><span class="subst">&#125;</span></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>如果你现在尝试运行代码，那么你将会被甩一脸报错（实际上就一条报错 :P）：</p><p><strong>Unknown identifier : name</strong></p><p>这是由于我们把变量 <code>name</code> 放到 <strong>Person</strong> 类里面了！这个类被用于实例化我们的变量 <code>buck</code> ，所以我们现在需要通过<code>buck.name</code>这样的形式来访问这些变量。这称为 <em>点成员访问符（dot notation)</em> ，通过对变量使用点成员访问符（.）可以访问所有该变量的公开成员（public members）！</p><p>所以让我们来修复一下错误的代码为：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trace</span>(<span class="string">'<span class="subst">$buck.name is $buck.age years old.');</span></span></span><br></pre></td></tr></table></figure><p>现在点击 <em>Build + Run</em> 之后你会看到…emmm…奇怪的运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; alive : true, age : 70, name : Buck &#125;.name is &#123; alive : true, age : 70, name : Buck &#125;.age years old.</span><br></pre></td></tr></table></figure><p>为什么会这样呢？这里有个事情你需要记住，你在 Haxe 中使用 字符串插入 这一语言特性时，如果你要插入的是一个表达式，那么这个表达式必须被一对花括号 <code>{}</code> 所包围：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trace</span>(<span class="string">'<span class="subst">$&#123;buck.name&#125;</span> is <span class="subst">$&#123;buck.age&#125;</span> years old.'</span>);</span><br></pre></td></tr></table></figure><p>让我们再添加一行代码加深理解：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trace</span>(<span class="string">'<span class="subst">$&#123;buck.name&#125;</span> will be <span class="subst">$&#123;buck.age + 1&#125;</span> years old next year.'</span>);</span><br></pre></td></tr></table></figure><p>一个表达式可以是一个函数的调用、一组方程式或是一个赋值操作。</p><p>最后做为一个练习，你可以尝试创建你自己的类，为其添加一些变量或函数，比如，你可以创建一个名为 <strong>Mario</strong> 的类并为其添加以下变量：</p><ul><li>speed:Float</li><li>lives:Int</li><li>has_mushroom:Bool</li></ul><p>以及以下函数：</p><ul><li>jump()</li><li>crouch()</li><li>run()</li></ul><hr><h2 id="Part-Five-可见性（Visibility）"><a href="#Part-Five-可见性（Visibility）" class="headerlink" title="Part Five - 可见性（Visibility）"></a>Part Five - 可见性（Visibility）</h2><p>你是否注意到了我们的某些变量被标记为 <strong>public</strong> ？这样做是为了让其他类可以通过这组变量所在的类的实例访问到这组变量。这就是为什么 <strong>Test</strong> 类得以访问 <strong>buck.name</strong>。</p><p>所有类成员都可以被修饰为 <strong>public</strong> 或 <strong>private</strong>。在 Haxe 中如果有成员没有被修饰为 public，则该成员会被隐式修饰为 private。如果在你的类中有这样一个函数或变量，它只能在其所处的类中被使用，那么最好将其修饰为 private。这样做可以使代码有更好的封装，且使得日后更易于对代码进行维护。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> name:<span class="type">String</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> secret:<span class="type">String</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(_name:<span class="type">String</span>, _secret:<span class="type">String</span>)</span><br><span class="line">&#123;</span><br><span class="line">name = _name;</span><br><span class="line">secret = _secret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> joe:<span class="type">Human </span>= <span class="keyword">new</span> <span class="type">Human</span>(<span class="string">'Joe'</span>, <span class="string">'I like to dance in my underwear!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">trace</span>(joe.name);   <span class="comment">//会输出 “Joe”</span></span><br><span class="line"><span class="built_in">trace</span>(joe.secret); <span class="comment">//错误：不能访问私有字段secret</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码编译后会报错，因为 joe.secret 被修饰为私有的（private)</p><p>在函数体内或者其他代码块之中也可以声明变量，但是它们的可见性只能在他们所在的代码块所覆盖的范围里。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> example_one:<span class="type">Int </span>= <span class="number">1</span>;<span class="comment">//创建 example_one</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(example_one &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> example_two:<span class="type">Int </span>= <span class="number">2</span>;<span class="comment">//创建 example_two</span></span><br><span class="line">example_one = <span class="number">3</span>;<span class="comment">//我们依然可以访问到 example_one</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">trace</span>(example_one);<span class="comment">//输出 “3”</span></span><br><span class="line"><span class="built_in">trace</span>(example_two);<span class="comment">//错误：“未知标识符：example_two”</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码编译后报错，这是由于 <strong>example_two</strong> 于代码块内声明，但是我们于代码块所覆盖的范围之外尝试访问它。</p><p>如果一个函数或变量被修饰为 <strong>static</strong> 则表示你不需要通过实例化它所处的类的对象来访问它。这样做对于常数值或函数而言相当有用，因为我们可以在程序的任意位置访问它！</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Constants</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> max_speed:<span class="type">Int </span>= <span class="number">200</span>; <span class="comment">//这是一个常数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//这个函数不需要实例化对象即可访问！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">cap_speed</span></span>(_speed:<span class="type">Float</span>):<span class="type">Float</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(_speed &gt; Constants.max_speed) <span class="keyword">return</span> Constants.max_speed;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> _speed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RaceCar</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> speed:<span class="type">Float </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> acceleration:<span class="type">Float </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> racecar_number:<span class="type">Int</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(_racecar_number:<span class="type">Int</span>)</span><br><span class="line">&#123;</span><br><span class="line">racecar_number = _racecar_number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">speed = Util.cap_speed(speed * acceleration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察一下我们是如何在其他类中不通过实例化 Constants 与 Util 来访问这些常量与函数的。这样做有一个很显著的好处即当我们想要修改程序中任意位置的 <strong>max_speed</strong> 的值时，我们只需要在一处地方进行修改即可！</p><hr><h2 id="Part-Six-函数（Functions）"><a href="#Part-Six-函数（Functions）" class="headerlink" title="Part Six - 函数（Functions）"></a>Part Six - 函数（Functions）</h2><p>在前面的小节中我们已经编写了不少函数了，但是在这一节中我们将花点时间学习如何编写它。这是一个基本的函数的例子：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">trace</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个完整的函数，但是我们还不能在 <strong>Test</strong> 类中使用它，首先我们需要先将它修饰为 static ，这样做<code>static function main()</code>才能够访问到它。 </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">hello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span>  <span class="title">hello</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">trace</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样我们就可以使用它了，接着让我们对这个函数做一些定制化的修改！</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span></span>(to_who:<span class="type">String </span>= <span class="string">'World'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">trace</span>(<span class="string">'Hello <span class="subst">$to_who!');</span></span></span><br><span class="line"><span class="string"><span class="subst">&#125;</span></span></span><br></pre></td></tr></table></figure><p>我们刚刚为我们的函数添加了一个名为 <strong>to_who</strong> 的参数。参数可以被看作是当你调用函数时提供其值的一个变量，该变量可以在该函数内部被访问到。同时，我们为参数提供了一个默认的值 <strong>‘World’</strong> ，这个时候我们只要不修改 <strong>Test.main()</strong> 中的函数调用则运行结果跟修改前是一模一样的。但是如果我们想要改变运行结果，我们可以通过调用 <strong>hello()</strong> 时提供自己的名字来让程序向自己打招呼！</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello(<span class="string">'Will'</span>) <span class="comment">//"Hello Will!" 将会被输出到输出窗口</span></span><br></pre></td></tr></table></figure><p>如果我们想要从函数取得该字符串而不是通过 <strong>trace()</strong> 函数将其输出到输出窗口时怎么办？这时候 <strong>return</strong> 就帮得上忙了。</p><p>一个函数运行时可以 <em>返回（return）</em> 一个值，这个功能相当有用！让我们修改一下 <strong>hello()</strong> 函数使其返回一串字符串而不是将其输出至控制台窗口：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span></span>(to_who:<span class="type">String </span>= <span class="string">'World'</span>):<span class="type">String</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'Hello <span class="subst">$to_who!';</span></span></span><br><span class="line"><span class="string"><span class="subst">&#125;</span></span></span><br></pre></td></tr></table></figure><p>你可以看到我们通过添加 <strong>:String</strong> 至函数声明末尾的位置，为我们的函数指明我们想要它返回的值或对象的数据类型。这一书写形式和为变量的声明指定数据类型时十分类似！接着在 <strong>hello()</strong> 函数的函数体中我们通过关键字 <strong>return</strong> 将欲返回的值返回出去。如果函数体中出现了 <strong>return</strong> 关键字，那么位于其后（此处不是指书写上的顺序而是指程序的执行顺序）的代码将不会被执行。</p><p>接着让我们通过 <strong>main()</strong> 函数来输出其所返回的字符串！</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">trace</span>(hello(<span class="string">'Will'</span>)); <span class="comment">//输出 "Hello Will!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么让我们来快速的剖析一下下面给出的代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get_random_number</span></span>(min:<span class="type">Float</span>, max:<span class="type">Float</span>):<span class="type">Float</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> min + Math.random() * (max - min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你现在不需要考虑这段代码的功能（尽管我很想尝试向你解释），让我们先来看看它的构成。</p><ul><li>public - 修饰该函数为可在该函数所处的类外部被访问到</li><li>static - 即表示你不需要实例化具有该成员函数的类即可使用它</li><li>function - 即表示它是一个函数（function）</li><li>get_random_number - 这是函数的名字，为函数命名时你应该尽量使用具备阐述性的名字，这样做的好处是当你阅读你所写的代码时，如果你看到了某个函数的调用，即可通过其名字得知该函数所做的工作而不需要查看其实现的源码，命名时应该尽量使其简单易懂且能能尽量保持代码的语境连贯。</li><li>(min:Float, max:Float) - 这个函数为了完成它的工作需要在其被调用时提供两个 Float 参数，分别用于表示最小值与最大值。</li><li>:Float - 这是函数返回值类型，你可以在任何需要提供 Float 类型值位置使用此函数。</li><li>接着是一个函数体，它由一对封闭的花括号{}构成，其中有一个 <strong>return</strong> 关键字以及一段紧随其后的方程式，方程的计算结果总是返回一个 Float 类型的值。</li></ul><p>PS：其实这个函数是用于获取一个随机数，调用该函数需提供两个 Float 类型的浮点数值作为参数，分别表示最小值和最大值，而函数执行结果是返回一个介于这两个值之间的带小数位的随机数（最小值 &lt;= 返回结果 &lt; 最大值），有意思的是函数体中的表达式 <code>min + Math.random() * (max - min)</code> 使得调用该函数时，不论所提供的两个浮点值大小的先后顺序（如 <strong>get_random_number(5, 10)</strong> 或 <strong>get_random_number(10, 5)</strong>），总能正确返回介于这两个浮点数之间的一个随机数（5 &lt;= 计算结果 &lt; 10）。</p><hr><h2 id="Part-Seven-If-amp-Else"><a href="#Part-Seven-If-amp-Else" class="headerlink" title="Part Seven - If &amp; Else"></a>Part Seven - If &amp; Else</h2><p>在大多数程序中，你或许需要使用带分支的逻辑结构来给予程序额外的功能！ <strong>if</strong> 语句被用于检查某个条件是否为 <strong>真（true)</strong> ，如果条件为真，则执行随后的代码块。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apply_senior_discount</span></span>(customer:<span class="type">Person</span>, sub_total:<span class="type">Float</span>):<span class="type">Float</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(customer.age &gt;= <span class="number">65</span>)</span><br><span class="line">&#123;</span><br><span class="line">sub_total = sub_total * <span class="number">0.90</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sub_total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们想要让函数检查顾客是否符合老年人的折扣标准，如果是，则以折扣价对待。为了满足这个功能，我们使用语句 <strong>if(customer.age &gt;= 65)</strong> 来实现。如果顾客的年龄大于等于 65 岁，则程序会执行随后的代码块（代码块会对总价施以 10% 的折扣）。如果年龄小于 65，则程序会掠过后面的代码块执行随后的指令（此例即返回最后的合计价格<code>sub_total</code>）。</p><p>你也可以把上面的代码改写为另一种形式：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apply_senior_discount</span></span>(customer:<span class="type">Person</span>, sub_total:<span class="type">Float</span>):<span class="type">Float</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(customer.age &gt;= <span class="number">65</span>)</span><br><span class="line">&#123;</span><br><span class="line">sub_total = sub_total * <span class="number">0.90</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> sub_total;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <strong>if</strong> 语句有一个与之对应的 <strong>else</strong> 语句出现时，位于 <strong>else</strong> 语句之后的代码块会在 <strong>if</strong> 语句的条件不满足时被执行！</p><p>你还可以使用一个 <strong>else if</strong> 语句来添加另外一个表达式作为条件的分支，比方说，如果你的经理临时起意想要在每周二为每一位顾客提供折扣价，但与此同时他并不希望长者能因此享有叠加的折扣时怎么办？</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apply_senior_discount</span></span>(customer:<span class="type">Person</span>, sub_total:<span class="type">Float</span>, day:<span class="type">String</span>):<span class="type">Float</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(customer.age &gt;= <span class="number">65</span>)</span><br><span class="line">&#123;</span><br><span class="line">sub_total = sub_total * <span class="number">0.90</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(day == <span class="string">'Tuesday'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sub_total = sub_total * <span class="number">0.90</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sub_total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们使用表达式 <strong>day == ‘Tuesday’</strong> 而不是 <strong>day = ‘Tuesday’</strong>。如果你想要检查某个东西是不是与另外一个东西相等时，必须使用两个等于号（==）作为连接两物进行比较的操作符。而如果你是希望将某个值赋值给某一个变量，则使用单个等于号（=）放置于变量名称之后，欲赋值的值之前来完成。</p><p>这段代码可以正常运行，但是你观察一下可以发现其中存在重复的代码 <strong>sub_total = sub_total * 0,90</strong> ！尽管如此，这段代码绝对不会在一次程序的迭代中被运行两次（因为这是一个二选一的逻辑结构）。编程过程中一件有趣的事情之一时尽力使我们编写的代码以更优雅的形式出现，如果你编写的代码中存在冗余的部分，那么一定有方法使其变得更简洁！我们可以使用一个 逻辑或操作符（||）来判断两个表达式之间的某一个是否为真！</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apply_senior_discount</span></span>(customer:<span class="type">Person</span>, sub_total:<span class="type">Float</span>, day:<span class="type">String</span>):<span class="type">Float</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(customer.age &gt;= <span class="number">65</span> || day == <span class="string">'Tuesday'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sub_total = sub_total * <span class="number">0.90</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sub_total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码我们通过判断顾客是否满足老年人折扣标准，或者今天是否是星期二，只要满足两个条件中的其中一条，那么顾客即可享有折扣价。</p><p>如此一来我们的代码就显得更简洁优雅了，现在让我们再设想一下要是我们的经理今天心情极差，所以他想要让长者只有在周二时才可享有老年人优惠。那么我们可以使用 <strong>与操作符（&amp;&amp;）</strong> 来连接两个条件，用以判断两个条件是否同时满足！</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apply_senior_discount</span></span>(customer:<span class="type">Person</span>, sub_total:<span class="type">Float</span>, day:<span class="type">String</span>):<span class="type">Float</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(customer.age &gt;= <span class="number">65</span> &amp;&amp; day == <span class="string">'Tuesday'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sub_total = sub_total * <span class="number">0.90</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sub_total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码我们通过判断顾客是否满足老年人折扣标准且今天是否是周二，只有当两个条件同时满足时，代码块才会被执行。</p><p>而如果想要判断某个条件是否<strong>不为</strong>真，则可以使用一个感叹号（!）以表示你想要判断该命题是否<strong>不为</strong>true</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> foobar:<span class="type">Bool </span>= <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!foobar)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">trace</span>(<span class="string">'foobar is false!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> day:<span class="type">String </span>= <span class="string">'Tuesday'</span>;</span><br><span class="line"><span class="keyword">if</span>(day != <span class="string">'Friday'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">trace</span>(<span class="string">"I can't wait til Friday!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//补充：上面这个语句可以改写为以下形式</span></span><br><span class="line"><span class="keyword">if</span>(!(day == <span class="string">"Friday"</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">trace</span>(<span class="string">"I can't wait til Friday!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//这里特别指出是由于原文没有具体说明 != 比较符与 ! 操作符之间的区别，我也就不多做解释了，文末有扩展资料</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是 if 语句总会期望一个 Bool 类型的值作为条件，因此你不可以写出类似 <strong>if(1)</strong> 这样的语句，因为这里的字面值 <strong>1</strong> 是 Int 类型的。（有别于C++）</p><hr><h2 id="Part-Eight-循环（Loops）"><a href="#Part-Eight-循环（Loops）" class="headerlink" title="Part Eight - 循环（Loops）"></a>Part Eight - 循环（Loops）</h2><p>有时候我们想要某个代码块被重复执行多次</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ninety_nine_bottles</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">trace</span>(<span class="string">'99 bottles of beer on the wall, 99 bottles of beer! Take one down, pass it around, 98 bottles of beer on the wall!'</span>);</span><br><span class="line"><span class="built_in">trace</span>(<span class="string">'98 bottles of beer on the wall, 98 bottles of beer! Take one down, pass it around, 97 bottles of beer on the wall!'</span>);</span><br><span class="line"><span class="built_in">trace</span>(<span class="string">'97 bottles of beer on the wall, 9 bottles of beer! Take one down, pass it around, 96 bottles of beer on the wall!'</span>);</span><br><span class="line">... 我放弃</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要担心，你不需要像这样做。</p><p>让我们通过 <code>while()</code> 循环来帮我们完成这项工作！</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ninety_nine_bottles</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> i:<span class="type">Int </span>= <span class="number">99</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">trace</span>(<span class="string">'<span class="subst">$i bottles of beer on the wall, $i bottles of beer! Take one down, pass it around, $&#123;i - 1&#125; bottles of beer on the wall!');</span></span></span><br><span class="line"><span class="string"><span class="subst">i--;</span></span></span><br><span class="line"><span class="string"><span class="subst">&#125;</span></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>俗话说的好，适当的偷懒是一种美德！现在让我们来看看这里发生了什么！</p><ul><li>var i:Int = 99; - 首先我们声明了一个变量用于计数，通常在这种情况下我喜欢以 <strong>i</strong> 来命名该变量，因为 i 可以被看作是单词 <em>iterator（迭代器）</em> 的缩写</li><li>while(i &gt; 0) - 类似于 <code>if(i &gt; 0)</code> 只不过这里的代码块会被循环往复不停的被执行直至条件表达式的值为假，尽管这样做有点危险，比方如果你的表达式的求值结果有可能永远也不会为假，那么就会陷入死循环。</li><li>trace(‘$i bottles of … on the wall!’); - 我们通过使用 <em>字符串插入（String Interpolation）</em> 配合循环体来唱一首呆萌的歌！</li><li>i–; - 这里是最为重要的部分！我们通过对变量 <strong>i</strong> 进行递减操作来使得下一次循环的迭代会少一瓶酒（bottle）（并且使得我们的循环体不会陷入死循环的情况中）。</li></ul><p><code>++</code> 与 <code>--</code> 是被用于对变量自身进行 加1（++） 或 减1（–） 的两个快捷记法，我们也可以通过 递增/减赋值操作符<code>-=/+=</code> 实现相同的操作，比如 <code>i -= 1</code> 或 <code>i += 1</code>，如果酒保一次递给我们两瓶啤酒的话我们可以这么写：<code>i -= 2</code>，自增/自减操作符与递增/减赋值操作符都是为了实现与 <code>i = i - 1</code> 这样的代码相似的功能（只不过使用上更简便）。</p><p>在 Haxe 中还有另外一种循环体，即 <strong>for</strong> 循环！</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ninety_nine_bottles</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">0</span> ... <span class="number">99</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">trace</span>(<span class="string">'<span class="subst">$&#123;99 - i&#125;</span> bottles of beer on the wall, <span class="subst">$&#123;99 - i&#125;</span> bottles of beer! Take one down, pass it around, <span class="subst">$&#123;98 - i&#125;</span> bottles of beer on the wall!'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Haxe 中的 for循环 十分的简洁优雅！</p><p><code>for(i in 0 ... 99)</code>光是这一行代码就完成了大部分事情！我们设定了一个迭代变量 <strong>i</strong> 并且给它指定了一个 0…99 的迭代范围，与此同时我们不再需要在代码块中对 <strong>i</strong> 进行递增或递减的修改操作！并且 <strong>for()</strong>循环 永远也不会陷入死循环的境地！因此相比起 <strong>while()</strong>循环 我更爱用 <strong>for()</strong>循环。</p><hr><h2 id="Part-Nine-数组（Arrays）"><a href="#Part-Nine-数组（Arrays）" class="headerlink" title="Part Nine - 数组（Arrays）"></a>Part Nine - 数组（Arrays）</h2><p>Still work-in-progress…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Still work-in-progress…&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://01010111.com/?index/tutorials/programming_in_haxe#programming-in-haxe&quot; target=&quot;_blank
      
    
    </summary>
    
    
    
      <category term="Haxe" scheme="https://nulllstack.github.io/tags/Haxe/"/>
    
  </entry>
  
  <entry>
    <title>20200503</title>
    <link href="https://nulllstack.github.io/2020/05/03/20200503/"/>
    <id>https://nulllstack.github.io/2020/05/03/20200503/</id>
    <published>2020-05-02T20:15:05.000Z</published>
    <updated>2020-05-02T20:16:09.902Z</updated>
    
    <content type="html"><![CDATA[<p>Trying to learn how to love myself before love some one else.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Trying to learn how to love myself before love some one else.&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程6-加载Tilemap(更新)</title>
    <link href="https://nulllstack.github.io/2020/04/29/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B6-%E5%8A%A0%E8%BD%BDTilemap-%E6%9B%B4%E6%96%B0/"/>
    <id>https://nulllstack.github.io/2020/04/29/HaxeFlixel官方教程6-加载Tilemap-更新/</id>
    <published>2020-04-29T09:48:36.000Z</published>
    <updated>2020-04-29T12:11:09.216Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://haxeflixel.com/documentation/loading-the-tilemap/" target="_blank" rel="noopener">原文</a></p><p>使用 Ogmo 编辑器配合 HaxeFlixel 的一大好处是框架已经内置了一组类（class）用于方便的加载 Ogmo 创建的地图。不过这组类并不是以 HaxeFlixel 的标准库形式提供的，所以我们需要先安装 flixel-addons 库用于访问这组类。</p><ol><li><p>首先打开命令行窗口并键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haxelib install flixel-addons</span><br></pre></td></tr></table></figure><p>该命令用于安装 HaxeFlixel 的插件库，安装完成后关闭命令行窗口。</p></li><li><p>回到 VSCode 并打开工程中的 <code>Project.xml</code> 文件，我们需要告诉我们的项目我们要导入 flixel-addons 库至我们的项目中。</p></li><li><p>找到以下这行代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;haxelib name="flixel-addons" /&gt;--&gt;</span></span><br></pre></td></tr></table></figure><p>将其修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">haxelib</span> <span class="attr">name</span>=<span class="string">"flixel-addons"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>保存修改，现在你可以开始使用 flixel-addons 库提供的接口了！</p></li><li><p>回到我们的 <code>PlayState</code> 类中，位于 <code>player</code> 变量的定义下方添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map:<span class="type">FlxOgmo3Loader</span>;</span><br><span class="line"><span class="keyword">var</span> walls:<span class="type">FlxTilemap</span>;</span><br></pre></td></tr></table></figure><p>这里我们首先创建了一个对象用于存储我们的 Ogmo 地图，之后又创建了另外一个对象用于保存从 Ogmo 地图中生成的 <code>FlxTilemap</code> 。</p></li><li><p>在 <code>create()</code> 中，位于 player 对象的设置之前的位置添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map = <span class="keyword">new</span> <span class="type">FlxOgmo3Loader</span>(AssetPaths.turnBasedRPG__ogmo, AssetPaths.room_001__json);</span><br><span class="line">walls = map.loadTilemap(AssetPaths.tiles__png, <span class="string">"walls"</span>);</span><br><span class="line">walls.follow();</span><br><span class="line">walls.setTileProperties(<span class="number">1</span>, FlxObject.NONE);</span><br><span class="line">walls.setTileProperties(<span class="number">2</span>, FlxObject.ANY);</span><br><span class="line">add(walls);</span><br></pre></td></tr></table></figure><p>这里我们从关卡文件中加载数据至我们的 <code>FlxOgmo3Loader</code> 对象、从 <code>walls</code> 图层中生成 <code>FlxTilemap</code> 并设置 瓦片1（表示地面的瓦片）的碰撞为无碰撞，瓦片2（表示墙面的瓦片）的碰撞为从任意方向发生碰撞。最后将 tilemap 添加至当前的 状态（state）中。</p></li><li><p>现在我们需要将我们的 player 对象放置于地图中正确的位置上，所以修改我们初始化 player 的代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">player = <span class="keyword">new</span> <span class="type">Player</span>(<span class="number">20</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">player = <span class="keyword">new</span> <span class="type">Player</span>();</span><br><span class="line">map.loadEntities(placeEntities,<span class="string">"entities"</span>);</span><br></pre></td></tr></table></figure><p>这里我们告诉 <code>map</code> 对象遍历所有 <code>entities</code> 图层中的实体，并对其调用 <code>placeEntities()</code> 函数（我们下面就来实现该函数）。</p></li><li><p>当我们调用地图的 <code>loadEntities()</code> 函数时，它会传递所有已放置的实体的数据至一个我们所需要接收数据的函数中。在我们的函数中，我们需要获取这组数据并利用它们做某些事情。这里我们的函数如下所示：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">placeEntities</span></span>(entity:<span class="type">EntityData</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(entity.name == <span class="string">"player"</span>)</span><br><span class="line">&#123;</span><br><span class="line">player.setPosition(entity.x, entity.y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数如果获取到了传递进来的实体名为 “player” ，它将会设 player 对象的<code>x</code>与<code>y</code>坐标至对应实体的<code>x</code>与<code>y</code>坐标的值的位置上。</p></li><li><p>现在我们需要为我们的状态添加碰撞检测，这样 player 碰到到墙面时就会一头撞上而不是穿行而过。所以位于<code>update()</code>中，<code>super.update(elapsed)</code>之后的位置添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlxG.collide(player, walls);</span><br></pre></td></tr></table></figure><p>这里所做的工作是每一次 <code>update()</code> 的迭代都会检测 player 与 walls 之间的重叠情况，如果发生重叠则两个对象之间会自动分离。</p></li><li><p>最后我们需要适当调整一下 player 的属性。由于默认情况下 player sprite 的大小与瓦片的大小是一致的（16x16) ，这导致 player 在穿越与自身大小一致的门口时犹如 “穿针引线” ，往往会由于一点点的偏差卡在门口动弹不得。所以我们需要适当的修改player sprite的大小 与 <code>offset</code> ，这样做不会改变精灵序列实际显示的效果，只会对其碰撞盒的大小产生影响。</p><p>所以在 <code>Player</code> 类的构造函数中，位于 <code>drag</code> 属性的设置下方添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setSize(<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">offset.<span class="keyword">set</span>(<span class="number">4</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改了 player 的碰撞盒之后，为了便于确定其修改后的大小，我们可以将其可视化，以<code>Debug</code>模式编译并运行项目之后，你可以通过 <code>F2</code> 功能键唤起 HaxeFlixel 自带的 <a href="https://haxeflixel.com/documentation/debugger/" target="_blank" rel="noopener">Debugging 工具</a></p><p>点击右上角那个立方体图示的按钮即可渲染出游戏中出现的碰撞盒：</p><p><img src="//nulllstack.github.io/2020/04/29/HaxeFlixel官方教程6-加载Tilemap-更新/browser_map_debugger.png" alt></p></li></ol><p>凑近点看你可以通过碰撞盒发现现在player的大小要比瓦砖更小一点了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://haxeflixel.com/documentation/loading-the-tilemap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用 Ogmo 编辑器配合 HaxeFlixel
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程5-创建Tilemap(更新)</title>
    <link href="https://nulllstack.github.io/2020/04/29/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B5-%E5%88%9B%E5%BB%BATilemap-%E6%9B%B4%E6%96%B0/"/>
    <id>https://nulllstack.github.io/2020/04/29/HaxeFlixel官方教程5-创建Tilemap-更新/</id>
    <published>2020-04-29T08:57:26.000Z</published>
    <updated>2020-04-29T15:45:42.055Z</updated>
    
    <content type="html"><![CDATA[<p>最近官方更新了新一代 Ogmo 编辑器 —— Ogmo3 的支持，于官方教程中更替了旧版的教程，所以顺便也翻译过来吧。</p><hr><p>现在，是时候为我们的玩家创建一个可供活动的地图了，首先我们需要使用一个叫做 <em>Ogmo编辑器</em> 的工具，Ogmo是一个免费的 Tilemap 编辑器，可以很完美的融入 Haxeflixel 的工作流。在这部分教程中我们将使用一个 “两瓦片（2-tile)” 的 tile序列图（tilesheet）用于分别表示墙面与地面。</p><p>你可以自己做一个 16x16(加注*) 大小的 tile序列 或者使用下面提供的这组序列图：</p><p><img src="//nulllstack.github.io/2020/04/29/HaxeFlixel官方教程5-创建Tilemap-更新/tiles.png" alt></p><p>（注意：序列图的第一块“瓦片”其实是透明的）</p><p>（加注*：实际自己做序列图的时候尺寸应该是24x16，因为实际序列图由三块瓦片组成，第一片是透明的，其用于表示“空白”瓦片，询问了一下 Flixel 的核心成员 Will 给出的解释是由于许多编辑器，包括HaxeFlixe引擎本身是通过下标 0 来索引“空白”瓦片的，但是Ogmo是使用 -1 索引来表示空白瓦片的（除 tilesheet 的第一块瓦片是透明的则使用这一块瓦片表示空白），因此如果不在 tilesheet 的第一块位置放置一块透明瓦片，在Ogmo中编辑的时候空白位置没问题，但是在Flixel中加载的时候就可能会引起 bug ， 比如，原本需要空白的位置被瓦片填充或是原本需要显示的瓦片没有显示（Flixel默认不显示第一块瓦片）的情况）</p><ol><li><p>下载并安装 Ogmo Editor 3，并启动。</p></li><li><p>点击 <code>New Project</code> 并定位至 <code>assets/data</code> 文件夹下（你的游戏工程里的文件夹）并保存为 <code>turnBasedRPG.ogmo</code>。</p></li><li><p>在 <code>General</code> 选项卡下，你可以重命名项目、设置关卡（level）的默认大小等。把其中的选项按如下图中所示设置：</p><p><img src="//nulllstack.github.io/2020/04/29/HaxeFlixel官方教程5-创建Tilemap-更新/ogmo_project_general.png" alt></p></li><li><p>在<code>Layer</code>选项卡下，创建一个实体层（Entity Layer）并命名为 <code>entities</code> 以及一个瓦片层（Tile Layer）并命名为 <code>walls</code> ：</p><p><img src="//nulllstack.github.io/2020/04/29/HaxeFlixel官方教程5-创建Tilemap-更新/ogmo_project_layers.png" alt></p></li><li><p>在 <code>Entities</code> 选项卡下，创建一个名为 <code>player</code> 的实体（Entity）：</p><p><img src="//nulllstack.github.io/2020/04/29/HaxeFlixel官方教程5-创建Tilemap-更新/ogmo_project_entities.png" alt></p></li><li><p>最后，在 <code>Tilesets</code> 选项卡下创建一个名为 <code>tiles</code> 的瓦片集（tileset）并加载先前创建好的瓦片序列图：</p><p><img src="//nulllstack.github.io/2020/04/29/HaxeFlixel官方教程5-创建Tilemap-更新/ogmo_project_tilesets.png" alt></p></li><li><p>完成以上工作之后点击 <code>Save</code> ，接着你会被带至如下窗口：</p><p><img src="//nulllstack.github.io/2020/04/29/HaxeFlixel官方教程5-创建Tilemap-更新/ogmo_editor_blank.png" alt></p></li><li><p>确保你目前位于 <code>walls</code> 图层，并且已正确选择屏幕上方的对应工具，然后开始绘制你的地图吧。</p><p>确保你的地图由墙面形成一个闭环（这样玩家就不能跑出地图以外的区域），并且其内由地面完全填充，最后绘制完的地图应该类似下面这样：</p><p><img src="//nulllstack.github.io/2020/04/29/HaxeFlixel官方教程5-创建Tilemap-更新/ogmo_editor_tiles.png" alt></p></li><li><p>现在，切换至 <code>entities</code> 图层并将 <code>player</code> 实体放置于地图中的某一个位置：</p><p><img src="//nulllstack.github.io/2020/04/29/HaxeFlixel官方教程5-创建Tilemap-更新/ogmo_editor_entities.png" alt></p></li><li><p>最后的最后， Ctrl+S 将关卡保存为 <code>room-001.json</code> 至 <code>assets/data</code> 文件夹下。</p></li></ol><p>到这里 Ogmo 的基本使用就介绍完了，下一节我们将介绍如何将我们创建好的关卡加载至我们的游戏中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近官方更新了新一代 Ogmo 编辑器 —— Ogmo3 的支持，于官方教程中更替了旧版的教程，所以顺便也翻译过来吧。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;现在，是时候为我们的玩家创建一个可供活动的地图了，首先我们需要使用一个叫做 &lt;em&gt;Ogmo编辑器&lt;/em&gt; 的工具，Ogmo是一
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>No organism Except myself</title>
    <link href="https://nulllstack.github.io/2020/04/11/No-organism-Except-myself/"/>
    <id>https://nulllstack.github.io/2020/04/11/No-organism-Except-myself/</id>
    <published>2020-04-10T17:01:46.000Z</published>
    <updated>2020-04-10T17:14:53.639Z</updated>
    
    <content type="html"><![CDATA[<p>对一件不再有趣的事情或一段令人失望的关系付之一笑之后就可以结束了吧。</p><p>你们和我总得先死一个，为什么不能是你们。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对一件不再有趣的事情或一段令人失望的关系付之一笑之后就可以结束了吧。&lt;/p&gt;
&lt;p&gt;你们和我总得先死一个，为什么不能是你们。&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>20200320</title>
    <link href="https://nulllstack.github.io/2020/03/20/20200320/"/>
    <id>https://nulllstack.github.io/2020/03/20/20200320/</id>
    <published>2020-03-20T05:21:54.000Z</published>
    <updated>2020-03-20T05:22:37.695Z</updated>
    
    <content type="html"><![CDATA[<p>做着越来越多违心的事，说着越来越多违心的话。</p><p>在明知其无聊的圈子里越来越麻木。</p><p>到底还是因为自己太菜。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做着越来越多违心的事，说着越来越多违心的话。&lt;/p&gt;
&lt;p&gt;在明知其无聊的圈子里越来越麻木。&lt;/p&gt;
&lt;p&gt;到底还是因为自己太菜。&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>一个常量引用未定义操作引发的Bug</title>
    <link href="https://nulllstack.github.io/2020/03/19/%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E6%9C%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C%E5%BC%95%E5%8F%91%E7%9A%84Bug/"/>
    <id>https://nulllstack.github.io/2020/03/19/一个常量引用未定义操作引发的Bug/</id>
    <published>2020-03-19T12:35:46.000Z</published>
    <updated>2020-03-20T06:40:15.218Z</updated>
    
    <content type="html"><![CDATA[<p>最近逛贴吧碰上一个灵魂提问，随后请教了几位大佬给出了很详细的解答，但是囿于知识面不全暂时还不是很通透，遂在此记上一笔，日后回来补充详细信息。</p><p>事情是这样的，声明一个常量引用并绑定至一常量，创建一个指针指向该引用，随后对该指针进行解引用，强制类型转换并赋值；这样一番操作之后会引发一个bug，指针与引用所访问的值已经被修改，但同时被间接访问的常量本身值却保持不变；以下是代码片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;re = c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;re;</span><br><span class="line">*((<span class="keyword">int</span>*)p) = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*p = "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"re = "</span> &lt;&lt; re &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//但常量引用re变成30了</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//常量c没变还是10</span></span><br></pre></td></tr></table></figure><p>以下是反汇编后汇编代码：</p><p><img src="//nulllstack.github.io/2020/03/19/一个常量引用未定义操作引发的Bug/result.png" alt></p><p>一个简单的解释是由于 c 为常量，编译器会为 c 的调用提供一个固定的值（该常量定义时的初始值）进行替换，所以当对常量 c 所在内存地址的内容进行修改的时候，除对 c 的间接访问会被修改外，对 c 的直接访问都保持原值不变。</p><p>例子中对 c 的内存区域进行修改的操作是一种 “未定义操作”。</p><hr><p>补充：<a href="https://blog.csdn.net/wue1206/article/details/81007787" target="_blank" rel="noopener">CSDN</a></p><p>文章中对编译过程中，编译器处理常量的工作有较为详细的解释。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近逛贴吧碰上一个灵魂提问，随后请教了几位大佬给出了很详细的解答，但是囿于知识面不全暂时还不是很通透，遂在此记上一笔，日后回来补充详细信息。&lt;/p&gt;
&lt;p&gt;事情是这样的，声明一个常量引用并绑定至一常量，创建一个指针指向该引用，随后对该指针进行解引用，强制类型转换并赋值；这样
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C/C++文件读写的一点事儿</title>
    <link href="https://nulllstack.github.io/2020/01/10/C-C-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%9A%84%E4%B8%80%E7%82%B9%E4%BA%8B%E5%84%BF/"/>
    <id>https://nulllstack.github.io/2020/01/10/C-C-文件读写的一点事儿/</id>
    <published>2020-01-10T14:45:34.000Z</published>
    <updated>2020-01-10T19:50:40.117Z</updated>
    
    <content type="html"><![CDATA[<p>折腾C/C++基础，踩了两个坑。</p><p>首先是关于<code>fstream.tellg()</code>调用的问题。</p><p>第二是关于<code>fstream</code> 对象对文本文件读写 <em>换行符</em>  的问题。</p><hr><p>先说第二点吧，我们都知道 <code>endl</code> 操作符是在缓冲区末尾添加一个换行并清空缓冲区，这个操作对文件流的写入作用也是一样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out_file</span><span class="params">(filename + <span class="string">".txt"</span>)</span></span>;</span><br><span class="line">        out_file &lt;&lt; user_name &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; num_corr &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; num_tries &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>以这种方式写入数据到 <em>filename</em>.txt 的时候每次都会写入三个数据，分别用空格分隔开，并且在行末添加一个<code>/n</code>换行。</p><p>但是当我用 <code>ifstream</code> 打开该文件进行读取并尝试通过 <code>seekg(n, ios::cur)</code> <strong>向前移动</strong> n 字节指针位置的时候，每一次指针都没对上我想要的位置。</p><p>下面给出一个例子来说明问题。</p><p>假设 <code>user_data.txt</code> 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">John 0 0</span><br><span class="line">NullStack 25 50</span><br><span class="line">NullStack 25 50</span><br><span class="line">NullStack 25 50</span><br></pre></td></tr></table></figure><p>cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">iofile</span><span class="params">(<span class="string">"user_data.txt"</span>,ios_base::in|ios_base::app)</span></span>;</span><br><span class="line">iofile.seekg(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iofile.tellg() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//通过seekg(0)使得指针当前位置为0，也就是第一行数据的开始位置</span></span><br><span class="line">iofile &gt;&gt; user_name &gt;&gt; num1 &gt;&gt; num2;<span class="comment">//user_name:John, num1:0, num2:0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iofile.tellg() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//经过上一行代码的操作之后指针会位于第一行末尾，也就是数字0之后那个位置</span></span><br><span class="line">iofile &gt;&gt; user_name;<span class="comment">//再读一次数据，此时user_name:NullStack, “&gt;&gt;” 操作符会自动丢弃空白字符（即换行）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由于第一行数据 “John 0 0” 加上行末的换行符长度刚好与</span></span><br><span class="line"><span class="comment">第二行数据的第一个数据“NullStack”一样为9个“字节(byte)”</span></span><br><span class="line"><span class="comment">我们可以推断当前指针位置应该是: 2*9=18，第18个字节的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iofile.tellg() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//然而实际上当前位置会是 19 也就是多了一个字节</span></span><br></pre></td></tr></table></figure><p>在跟发小尬聊的时候提到这个问题，他觉得是由于内存中对齐存放导致的问题，但是我感觉这种底层存放的操作应该不会对文件内容本身的读写造成影响，但还是找了<a href="https://www.cnblogs.com/clover-toeic/p/3853132.html" target="_blank" rel="noopener">相关资料</a>，目前而言感觉还蛮复杂的，日后再深入。</p><p>因此我又找了其他资料有了如下发现：</p><p><a href="https://blog.csdn.net/wu_nan_nan/article/details/53469958" target="_blank" rel="noopener">原文链接</a></p><blockquote><p>历史：<br>  在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。<br>  　于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。<br>  这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。<br>  　后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。<br>  　Unix 系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；Windows系统里面，每行结尾是“ &lt;回车&gt;&lt;换 行&gt;”，即“\r\n”；Mac系统里，每行结尾是“&lt;回车&gt;”。一个直接后果是，Unix/Mac系统下的文件在Windows里打 开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。</p></blockquote><p>由于 Windows 下对<strong>文本文件</strong>进行写入的时候，<code>\n</code>换行符会被替换为<code>\r\n</code>两个字符，因此以<code>endl</code>对 user_data.txt 写入数据的时候行末会有两个字节的占用。</p><p>纯手写的 txt 也可以发现这一点：</p><img src="//nulllstack.github.io/2020/01/10/C-C-文件读写的一点事儿/example.png" style="zoom:80%;"><p>sth.txt 的内容仅仅是敲了个回车写了个换行，但是依然占用了2个字节。</p><p>这个问题对二进制文件进行读写操作的时候不会存在。</p><hr><p>下面说说第一个碰上的坑。</p><p>ok，这个问题我现在还是很懵，就在我写这篇博客，尝试复现问题并给予描述的时候。</p><p>尽管这个问题可以通过换一个编译器解决（从MinGW换到MSVC），下面我尝试一下能不能描述明白问题。</p><p>首先，我们先来看一下 <a href="https://zh.cppreference.com/w/cpp/io/basic_istream/tellg" target="_blank" rel="noopener">cppreference.com 对 tellg() 函数的描述</a>：</p><img src="//nulllstack.github.io/2020/01/10/C-C-文件读写的一点事儿/tellg.png" style="zoom:80%;"><p>简单来说就是用于获取一个值，获取失败时返回 -1 ，成功则返回当前指针的位置。</p><p>行吧，看起来很好理解，由于<code>ifstream</code>对象进行读入的时候是按字节读入的，指针位置也会随之后移，读到哪移动到哪，每读一个字节后移一位。在前面的问题中我们也通过 tellg() 来获取指针位置的状态。</p><p>然而那是在我换了MSVC编译器之后 tellg() 的行为才符合我的预期，那么在MinGW环境下编译的结果如何呢，下面还是例子来说明：</p><p>首先是cpp的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> user_name;</span><br><span class="line">    <span class="keyword">int</span> num1,num2;</span><br><span class="line"></span><br><span class="line">    <span class="function">fstream <span class="title">iofile</span><span class="params">(<span class="string">"user_data.txt"</span>,ios_base::in|ios_base::app)</span></span>;</span><br><span class="line">    iofile.seekg(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pointer position: "</span> &lt;&lt; iofile.tellg() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    iofile &gt;&gt; user_name &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"data: "</span> &lt;&lt; user_name &lt;&lt; <span class="string">" "</span> &lt;&lt; num1 &lt;&lt; <span class="string">" "</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pointer position: "</span> &lt;&lt; iofile.tellg() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出上一行代码执行读取操作之后指针的位置</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设当前<code>user_data.txt</code>只有两行内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">John 0 0</span><br><span class="line">NullStack 25 50</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pointer position: 0</span><br><span class="line">data: John 0 0</span><br><span class="line">pointer position: 9</span><br></pre></td></tr></table></figure><p>如果增加 user_data.txt 内容的行数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">John 0 0</span><br><span class="line">NullStack 25 50</span><br><span class="line">NullStack 25 50</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pointer position: 0</span><br><span class="line">data: John 0 0</span><br><span class="line">pointer position: 10</span><br></pre></td></tr></table></figure><p>可以发现指针位置偏移多了1个字节的量，而且以此类推<code>user_data.txt</code>的内容增加多少行 <code>tellg()</code> 返回的指针位置就会偏移多少个字节。</p><p>但是tellg()的这个行为在MSVC环境下编译是不会存在的，不论<code>user_data.txt</code>的内容有多少行程序都会输出一样的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pointer position: 0</span><br><span class="line">data: John 0 0</span><br><span class="line">pointer position: 8</span><br></pre></td></tr></table></figure><p>尽管MinGW环境下 tellg() 的行为很奇怪，但是更怪的是这并不影响我们使用它配合 <code>ios::cur</code> 来进行寻位操作：</p><p>cpp源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> user_name;</span><br><span class="line">    <span class="keyword">int</span> num1,num2;</span><br><span class="line"></span><br><span class="line">    <span class="function">fstream <span class="title">iofile</span><span class="params">(<span class="string">"user_data.txt"</span>,ios_base::in|ios_base::app)</span></span>;</span><br><span class="line">    iofile.seekg(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pointer position: "</span> &lt;&lt; iofile.tellg() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    下面四行代码会把 user_data.txt 的头</span></span><br><span class="line"><span class="comment">    四行数据都读走也不会影响后面的寻位操作</span></span><br><span class="line"><span class="comment">    iofile &gt;&gt; user_name &gt;&gt; num1 &gt;&gt; num2;</span></span><br><span class="line"><span class="comment">    iofile &gt;&gt; user_name &gt;&gt; num1 &gt;&gt; num2;</span></span><br><span class="line"><span class="comment">    iofile &gt;&gt; user_name &gt;&gt; num1 &gt;&gt; num2;</span></span><br><span class="line"><span class="comment">    iofile &gt;&gt; user_name &gt;&gt; num1 &gt;&gt; num2;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    iofile &gt;&gt; user_name &gt;&gt; num1 &gt;&gt; num2;<span class="comment">//为了方便理解我们只读一行</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"data: "</span> &lt;&lt; user_name &lt;&lt; <span class="string">" "</span> &lt;&lt; num1 &lt;&lt; <span class="string">" "</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pointer position after read: "</span> &lt;&lt; iofile.tellg() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    iofile.seekg(-(iofile.tellg()), ios::cur);<span class="comment">//把指针以当前位置取反后位移，这样就可以让指针回到文件开始位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pointer positon after "</span></span><br><span class="line">         &lt;&lt; <span class="string">"iofile.seekg(-(iofile.tellg()), ios::cur): "</span></span><br><span class="line">         &lt;&lt; iofile.tellg()</span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    iofile &gt;&gt; user_name &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"data: "</span> &lt;&lt; user_name &lt;&lt; <span class="string">" "</span> &lt;&lt; num1 &lt;&lt; <span class="string">" "</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//此时读入的还是第一行</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pointer position after read: "</span> &lt;&lt; iofile.tellg() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>user_data.txt</code>（一共11行数据）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">John 0 0</span><br><span class="line">NullStack 25 50</span><br><span class="line">NullStack 25 50</span><br><span class="line">NullStack 25 50</span><br><span class="line">NullStack 25 50</span><br><span class="line">NullStack 25 50</span><br><span class="line">NullStack 25 50</span><br><span class="line">NullStack 25 50</span><br><span class="line">NullStack 25 50</span><br><span class="line">NullStack 25 50</span><br><span class="line">NullStack 25 50</span><br></pre></td></tr></table></figure><p>MSVC环境输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pointer position: 0</span><br><span class="line">data: John 0 0</span><br><span class="line">pointer position after read: 8</span><br><span class="line">pointer positon after iofile.seekg(-(iofile.tellg()), ios::cur): 0</span><br><span class="line">data: John 0 0</span><br><span class="line">pointer position after read: 8</span><br></pre></td></tr></table></figure><p>MinGW环境输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pointer position: 0</span><br><span class="line">data: John 0 0</span><br><span class="line">pointer position after read: 18</span><br><span class="line">pointer positon after iofile.seekg(-(iofile.tellg()), ios::cur): 0</span><br><span class="line">data: John 0 0</span><br><span class="line">pointer position after read: 18</span><br></pre></td></tr></table></figure><p>如输出所示两个环境下都能通过<code>seekg(-(iofile.tellg()), ios::cur)</code>把指针移回到文件的开始位置。</p><p>至于为什么会出现这样奇怪的问题我也没搞懂，网上找了一下相关资料有的人说是 MinGW 的编译器 bug，有的人则说这是 MinGW 在 Windows 下编译的正常行为（后者我认为靠谱一点）。</p><p>我找到的相关资料：<a href="https://stackoverflow.com/questions/12252075/ifstream-tellg-not-returning-the-correct-position" target="_blank" rel="noopener">StackOverflow</a>、<a href="https://www.imooc.com/wenda/detail/599051" target="_blank" rel="noopener">猿问</a></p><p>暂时就先到这吧，文件读写就先放一边了，抓紧折腾点别的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;折腾C/C++基础，踩了两个坑。&lt;/p&gt;
&lt;p&gt;首先是关于&lt;code&gt;fstream.tellg()&lt;/code&gt;调用的问题。&lt;/p&gt;
&lt;p&gt;第二是关于&lt;code&gt;fstream&lt;/code&gt; 对象对文本文件读写 &lt;em&gt;换行符&lt;/em&gt;  的问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>openFrameworks文件结构</title>
    <link href="https://nulllstack.github.io/2020/01/01/openFrameworks%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://nulllstack.github.io/2020/01/01/openFrameworks文件结构/</id>
    <published>2019-12-31T17:09:44.000Z</published>
    <updated>2019-12-31T18:01:24.069Z</updated>
    
    <content type="html"><![CDATA[<p>把下好的oF解压，从现在开始我们将以该文件夹作为 oF 根目录，你可以把 oF 的根目录放置于任何位置。但是有一件事需要强调，oF 已经被设计为一个 “独立的（self-contained）” 结构，所有依赖项都被整合好放在同一个文件夹里了，也就是说你可以把这整个文件夹移动到任何磁盘下使用，甚至可以打包带走带去机房上课的时候写着玩 :P。<strong>如果你有其他版本的 oF 那么请保持他们之间的相互独立，不要尝试把两个版本的文件混在一起。</strong></p><p>打开解压出来的文件夹，它包含了一些其他文件夹，我们将在下面给出详细解释。现在我们先找到 examples 文件夹并尝试编译其中的项目。examples/graphics/graphicsExample。如果你使用的是OS X操作系统，那么打开graphicsExample.xcodeproj。如果你使用的是 Visual Studio，那么选择打开 “.sln” 文件。</p><p><em>注：由于我一直是使用 Windows ，从现在开始其它系统相关的内容我都不再区分，只讲 Windows 相关的部分。</em></p><p>现在你的 IDE 将自动打开并加载该例子，找到“运行” 按钮或选项并点击它，例子源码将会开始被编译（首次编译因为因为需要编译 oF 库，可能需要多花一点时间）。你会看到许多文件开始被编译，放心，大部份文件只会在 oF 库被重构或首次编译时需要编译。</p><p>如果以上工作进行顺利的话，将会弹出一个窗口并显示你刚刚所编译的例子中的内容。</p><p>如果图形例程能够正常工作的话，花点时间看一遍其他 oF 实例并尝试运行他们；通常来讲在你打开一个新的项目之前先把当前的 项目/工作目录 完全关闭会是一个好习惯。一旦 oF 库完成了首次编译，之后项目的编译速度会快很多！</p><h2 id="openFrameworks-文件结构"><a href="#openFrameworks-文件结构" class="headerlink" title="openFrameworks 文件结构"></a>openFrameworks 文件结构</h2><p>在 oF 根目录中你可以找到以下这些文件夹：</p><h3 id="Addons"><a href="#Addons" class="headerlink" title="Addons"></a>Addons</h3><p>“addons”文件夹中包含了已内置的“核心”插件。插件是一些额外的扩展了 oF 功能的代码片段，插件通常由第三方用户编写并分享出来。而“核心”插件是那些被用户频繁使用的插件于是被选择作为官方 oF 库的内置插件。他们被 oF 的核心开发者维护与编写。<br>访问该链接：<a href="http://ofxaddons.com/" target="_blank" rel="noopener">ofxAddons</a> 可以找到由社区贡献的大量额外的插件。</p><h3 id="Apps"><a href="#Apps" class="headerlink" title="Apps"></a>Apps</h3><p>该文件夹用于存放你新建的项目；你当前的 oF 中默认存放了一个名为 “myApps” 的文件夹于 “apps” 文件夹内，当你新建项目的时候项目生成器会默认使用该文件夹（注1）。还有重要的一点需要注意，项目对 libs 文件夹的引用是使用相对路径来定位的；需要注意的点是你的项目应该一直位于相对路径所指从当前文件夹开始到 libs 文件夹之间的深度中（如<code>../../../libs</code>即 表示项目文件夹所在的路径应该类似<code>oF根目录/apps/myApps/mySketch</code>这样），如果你随便更改了项目文件夹的存放路径它们将找不到编译所需的其他部分内容（注2）。</p><p><em>注1：推荐使用 projectGenerator 来管理项目，理由后面会给出解释。</em></p><p><em>注2：如果你尝试用文本编辑器打开项目文件（.sln以及.vcxproj）你会看到其中有些地方有一段相对地址如<code>../../../libs</code>把这一段的路径改为绝对地址你就可以把这个项目文件夹放在硬盘上的任何一个位置也能确保正确编译，但不推荐这么做。</em></p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>该文件夹用于存放例程，其中的例程按主题分类排序，几乎涵盖了 oF 的各个方面，每个实例都以保持简单并专注于解决特定主题的问题为主，因此当你需要在你的项目中完成某些类似的工作，这里的例程会相对简单且易于理解，可以作为你着手解决问题的一个起点。</p><h3 id="libs"><a href="#libs" class="headerlink" title="libs"></a>libs</h3><p>这里面存放了 oF 用于编译你的项目时使用的各种库文件，其中包含的库有如 FreeType 库用于平面设计（Typography）的支持、FreeImage 库用于图像加载、glfw 库用于窗体实现（Windowing 不知道翻译对不对，没用过）；以及其他用于编译 oF 项目的依赖项还有 oF 的源码也都在这个文件夹内，如果你想看源码的话就在这里面翻找吧。</p><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p>这里面存放了 Arduino 相关的例程，在 <code>examples/communication</code> 文件夹下你可以找到串口（serial）例程，当你的项目使用了 Arduino 的时候可以用这里的例程检查 Arduino 是否正确连接并正常工作。</p><h3 id="projectGenerator"><a href="#projectGenerator" class="headerlink" title="projectGenerator"></a>projectGenerator</h3><p>现在 oF 附加了一个简单的项目生成器用于简化项目的创建流程。这个工具使用了一个项目模板（位于 scripts 文件夹下）用于项目的创建与修改（项目名称、使用的插件等）。同时用项目生成器创建的项目可以被存放于磁盘的任意目录下（实际上已存在的项目若存放路径发生变动，需使用生成器导入该项目并点击 Update ”刷新“ 项目依赖项的引用信息）。</p><p>最后，原文罗列了 oF 的 API 以及可用的插件与相关用途，我就不在这里罗列了，直接丢两个链接更具 “时效性” 毕竟这些东西随时可能更新随时可能发生变动，<strong>最重要的是：码字真的很麻烦。</strong> :P</p><p>API 文档：<a href="https://openframeworks.cc/documentation/" target="_blank" rel="noopener">openFrameworks Doc</a></p><p>插件目录：<a href="http://ofxaddons.com/" target="_blank" rel="noopener">ofxAddons</a>（其实前文以及给过了）</p><p>emmm…再就是在豆瓣上发现官方文档的 ofBook 已经有大佬翻译了我后面想要翻译的部分了，虽然后半段机翻成分较多，但是也足够我看了….没必要重复劳动，加上我写这些东西目的也是出于方便自己查阅，所以….后面我再更新就是整理与总结向的内容了，翻译的文章视情况更新把。</p><p>Farewell</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把下好的oF解压，从现在开始我们将以该文件夹作为 oF 根目录，你可以把 oF 的根目录放置于任何位置。但是有一件事需要强调，oF 已经被设计为一个 “独立的（self-contained）” 结构，所有依赖项都被整合好放在同一个文件夹里了，也就是说你可以把这整个文件夹移动
      
    
    </summary>
    
    
    
      <category term="openFrameworks" scheme="https://nulllstack.github.io/tags/openFrameworks/"/>
    
  </entry>
  
  <entry>
    <title>openFrameworks Philosophy</title>
    <link href="https://nulllstack.github.io/2019/12/30/openFrameworks-Philosophy/"/>
    <id>https://nulllstack.github.io/2019/12/30/openFrameworks-Philosophy/</id>
    <published>2019-12-29T18:59:30.000Z</published>
    <updated>2019-12-29T19:04:09.092Z</updated>
    
    <content type="html"><![CDATA[<p>po 完上一篇博客之后发现那个垃圾排版与Typora编辑时呈现的排版完全不一致，恶心到我了，甚至开始考虑是否继续使用博客，反正主要是给自己看的，何必如此折腾煞费苦心 :(</p><hr><p>openFrameworks 的发展尝试遵循以下几个目标：它应该是合作性（Collaborative）的，简单易用的，连贯且直观的，跨平台的，强大且可扩展的。以上目标也由 “与人协作” （”do it with others – DIWO”）的哲学观所驱动。</p><hr><h3 id="合作性（Collaborative）"><a href="#合作性（Collaborative）" class="headerlink" title="合作性（Collaborative）"></a>合作性（Collaborative）</h3><p>openFrameworks 的开发是协作完成的，它的蓬勃发展得益于许多经常参与讨论、在插件与项目中完成协作的人的贡献。我们鼓励大家使用oF并为社区的生态环境做出贡献。</p><p>我们使用了分布式版本控制系统 “git”，这意味着大家可以提出建议，为项目添加新的 branch、做一些实验性的扩展；如果你看过 <a href="https://github.com/openframeworks/openFrameworks" target="_blank" rel="noopener">GitHub</a> 上的网络图（network diagram）便不难发现它呈现出一种奇怪的图示，四处编织着新的分支，某个部分的代码被拆分后又在另一头重组。整个社区遍布全球各地，共同维护着oF的核心代码：他们修补BUG，提交新请求以及构建他们所需的新的工具，这是一个 全球性的项目，如果你在美国一觉醒来并开始查看电子邮件，发现邮箱里充满着来自亚洲与欧洲的程序员提交的新的需求或者 issue 是很常见的事情。有超过70人为核心代码做出直接的贡献，还有数百人以fork或其他形式为社区做出贡献。</p><h3 id="简单性（Simplicity）"><a href="#简单性（Simplicity）" class="headerlink" title="简单性（Simplicity）"></a>简单性（Simplicity）</h3><p>openFrameworks尝试在<strong>有用（usability）</strong>与 <strong>简单（Simplicity）</strong>之间寻找平衡，最早期的oF核心库被用于教授C++与<a href="https://en.wikipedia.org/wiki/OpenGL" target="_blank" rel="noopener">OpenGL</a>，后由时间的推移其核心库的例程随着更多高级功能的加入变为了最适合学习的途径，因此我们随着oF的发布创建了更多的例程，为实验提供更多简单、易于拆解的学习起点。</p><p>我们希望oF可以尽可能的简单，特别是为那些从其他语言或开发环境入坑的朋友，C++是一门“庞杂”的语言，它的庞杂还意味着每个人使用C++编写的规范可以很不一样。如果你去书店你会发现C++相关的书可以有数百本之多。我们希望创建一个你只需要一两本书来入门而不需要成为一名专家就能够使用的代码库，其代码规范、编程模式及编程范式（the patterns, approaches and style of the code）是简单且直观的。我们刻意在某种程度上与<a href="http://www.processing.org/" target="_blank" rel="noopener">Processing</a>对齐，两者的某些函数都是相似的，为的是能够让大家在两个框架间的使用能够更自然的过渡。</p><h3 id="连贯且直观（Consistent-and-Intuitive）"><a href="#连贯且直观（Consistent-and-Intuitive）" class="headerlink" title="连贯且直观（Consistent and Intuitive）"></a>连贯且直观（Consistent and Intuitive）</h3><p>openFrameworks是连贯且直观的：它运转于一些常规（least surprise）的原则之上，所以你从oF中的所学也可以在其他领域有所用。初学者可以从oF中学习到常见的编程模式（programming patterns）而高级用户在其他语言或工具集中所学的知识也在oF中也有用武之地。</p><p>oF的箴言是“学生排在第一位”，许多关于oF的发展的指导方针是基于 “在5或10年以前我会喜欢什么样的工具” 这样的思考的。我们希望代码的模式（pattern）尽可能简单地易于输入。这意味着有如在视频播放器中使用“play”与“stop”命名的具“自我阐释性（self-exlanatory)” 的函数命名法以及类似的变量的命名法会更直观。我们就直观方面有过许多讨论，都是为了让代码尽可能的简洁明了，使得你可以在输入代码的过程中，在自动补全的帮助下也能够学习oF。</p><h3 id="跨平台（Cross-platfiorm）"><a href="#跨平台（Cross-platfiorm）" class="headerlink" title="跨平台（Cross-platfiorm）"></a>跨平台（Cross-platfiorm）</h3><p>openFrameworks是一个跨平台的工具包，它尽可能多的支持各种开发环境与操作系统，当你下载好oF之后你可以选择你需要的开发环境与目标平台进行开发，oF已经包含了相关的项目与例程供学习与使用。难以移植（Difficult-to-port）的部分代码被提供于插件（addons）中而不是核心代码中。</p><p>oF被设计为可工作于多个平台：OSX，Windows，Linux， iOS，Android，嵌入式ARM Linux系统，以及如BlackBerry和PlayBook这样的处于实验性阶段的平台。openFrameworks的开发人员已经想出了一些聪明的方法使得oF可以访问其他语言的接口如Android平台下的Java以及iOS平台下的Ojective-C。</p><p>跨平台库的一个喜闻乐见的点在于你可以将你的想法从一个平台导出至另一个平台，你可以在笔记本上迭代原型并快速地在你的手机上检验运行结果。它使得你的想法能够先落地而不需要担心冗余的跨平台工作。</p><h3 id="功能强大的（Powerful）"><a href="#功能强大的（Powerful）" class="headerlink" title="功能强大的（Powerful）"></a>功能强大的（Powerful）</h3><p>openFrameworks功能强大，它使你能够借助如<a href="http://opencv.org/" target="_blank" rel="noopener">OpenCV</a>之类的高级库，访问你的硬件如显卡进行加速，或者连接摄像头之类的外设。</p><p>我们选择使用C++编写oF是因为它是一门足够“低级”的语言同时又可以以现代高级语言的方式进行编程。由于它可以认为是C语言的扩展，所以它可以编写一些很底层的东西，可以以老式C语言的方式编写，也可以以现代C++的形式编写。我们试图在oF中以简单、清晰、但功能强大的形式接纳这两种编程方法。同时，使用C++也使得我们能够直接访问许多已由C或C++编写的库的接口而不需要依赖其他语言的包装器（wrapper）。</p><p>openFrameworks本质上包装（wrap）了其他库如：OpenGL、<a href="http://cairographics.org/" target="_blank" rel="noopener">Cairo</a>、<a href="http://freetype.org/" target="_blank" rel="noopener">FreeType</a>、<a href="http://freeimage.sourceforge.net/" target="_blank" rel="noopener">FreeImage</a>、以及OpenCV，你可以把oF设想为一层介于用户代码（由你编写的代码）与这些库之间的代码层。由于不同库的使用上，编程方法与风格各不相同所以我们把各个库进行了统一的包装并提供一个更为连贯且直观的形式。</p><h3 id="可扩展的（Extensible）"><a href="#可扩展的（Extensible）" class="headerlink" title="可扩展的（Extensible）"></a>可扩展的（Extensible）</h3><p>openFrameworks是可扩展的。如果你发现它缺少某些你需要的东西你可以简单地通过创建一个插件来扩展它。oF的核心插件通常包装了其他的库而不是直接以加入新功能的形式来解决问题。当oF包装了新的库的同时这些库也为进一步的扩展提供了新的途径。</p><p>oF的愿景是成为你开发过程中的一个可靠的臂膀或脚手架。能够使得oF的核心库更轻量化的一点是避免尽可能多的往里纳入所有新的东西，取而代之的是oF有一个插件体系允许用户之间共享额外的代码，库以及方法使得在必要时可以将其 “编织” 进项目里。</p><p>oF的插件可以是一段代码片段，或是更为复杂的库如OpenNI、Tesseract或Box2d的一个封装。插件名字的前缀通常是“ofx”，为的是可以使你方便的区分oF的核心与非核心代码，另外，我们为oF纳入了“核心插件（core addons）”，这些插件是我们认为大家通常会需要但并不是每一个项目都会需要用到的插件比如 ofxOpenCv 插件。</p><p>我们试图通过 <a href="http://ofxaddons.com" target="_blank" rel="noopener">http://ofxaddons.com</a> 网站组织与支持社区开发插件，该网站通过自动检索Github中标题包含 “ofx” 一词的仓库（repos）收集插件目录，目前已有超过1500个插件收录在册。</p><h3 id="与他人协作（Do-it-with-others-–-DIWO）"><a href="#与他人协作（Do-it-with-others-–-DIWO）" class="headerlink" title="与他人协作（Do it with others – DIWO）"></a>与他人协作（Do it with others – DIWO）</h3><p>这个部分有点懒得翻了，大概就是鼓励大家多合作多分享，共同探索 creative coding 的乐趣。（完 :D）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;po 完上一篇博客之后发现那个垃圾排版与Typora编辑时呈现的排版完全不一致，恶心到我了，甚至开始考虑是否继续使用博客，反正主要是给自己看的，何必如此折腾煞费苦心 :(&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;openFrameworks 的发展尝试遵循以下几个目标：它应该是合作性（Co
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程12:音效与音乐</title>
    <link href="https://nulllstack.github.io/2019/04/05/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B12-%E9%9F%B3%E6%95%88%E4%B8%8E%E9%9F%B3%E4%B9%90/"/>
    <id>https://nulllstack.github.io/2019/04/05/HaxeFlixel官方教程12-音效与音乐/</id>
    <published>2019-04-04T18:22:05.000Z</published>
    <updated>2019-04-04T18:29:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>打算一次翻译完剩下的部分之后去弄点别的事情，HaxeFlixel相关的东西很闲的时候再回来整理。</p><p><a href="http://haxeflixel.com/documentation/sound-and-music/" target="_blank" rel="noopener">原文</a></p><p>目前我们为游戏所做的各个部分已经整合起来了，不过它还缺少一点东西…它还没有声音。</p><p>我们依然保持这个游戏简单化。我们将使用一个可循环的单音轨音频文件用于游戏运行时循环播放。我们也会为各种不同的动作添加一些简单的音效。在 HaxeFlixel 中播放音频文件是十分简单的事情。</p><p>首先，你需要创建一段音乐还有其他音效。来自 <a href="http://fatbard.tumblr.com/" target="_blank" rel="noopener">FatBard</a> 的 Patrick Crecelius 为本教程提供了<a href="https://raw.githubusercontent.com/HaxeFlixel/flixel-demos/master/Tutorials/TurnBasedRPG/assets/music/HaxeFlixel_Tutorial_Game.mp3" target="_blank" rel="noopener">一段音乐</a>（建议在直接上<a href="https://github.com/HaxeFlixel/flixel-demos/tree/dev/Tutorials/TurnBasedRPG" target="_blank" rel="noopener">GitHub</a>从<code>asstes/music</code>文件夹内下载），你可以随意使用，或者可以自己做。</p><p>我们还使用了 <a href="https://www.bfxr.net/" target="_blank" rel="noopener">Bfxr</a> 制作了一些音效，如果你喜欢的话可以使用这些音效文件或者自己做一套。</p><p>如果你一步步跟着教程走下来的话那么在 “UI与战斗系统” 一节中你已经下载过这些音效文件了。以下列出这些文件确保你确实完整下载了这些文件：</p><ul><li>coin.wav - 用于玩家拾起硬币时使用的音效</li><li>combat.wav - 战斗开始时使用的音效</li><li>fled.wav - 当玩家成功逃离战斗时使用的音效</li><li>hurt.wav - 玩家或敌人击中对方时使用的音效</li><li>lose.wav - 玩家于战斗中死亡时使用的音效</li><li>miss.wav - 玩家或敌人攻击miss时使用的音效</li><li>select.wav - 用于按钮以及玩家于选项栏进行选择时使用的音效</li><li>step.wav - 用于玩家以及敌人的脚步声的音效</li><li>win.wav - 当玩家于战斗中获胜时使用的音效</li></ul><p>音效文件链接：<a href="https://github.com/HaxeFlixel/flixel-demos/tree/dev/Tutorials/TurnBasedRPG/assets/sounds" target="_blank" rel="noopener">GitHub</a></p><p>当你准备完这些声音文件之后把<strong>音乐</strong>文件放置于<code>assets/music</code>文件夹下，把<strong>音效</strong>文件放置于<code>asstes/sounds</code>文件夹下。</p><p>现在让我们修改代码来使用这些声音文件：</p><ol><li><p>首先打开<code>MenuState.hx</code>文件，由于我们需要让音乐从游戏启动那一刻开始并不管如何都不停循环，所以我们要从<code>create()</code>内添加它。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(FlxG.sound.music == <span class="literal">null</span>) <span class="comment">//如果音乐已经在播放了则不重放音乐</span></span><br><span class="line">&#123;</span><br><span class="line">    FlxG.sound.playMusic(AssetPaths.HaxeFlixel_Tutorial_Game__mp3, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们同时还检查了音乐是否已经处于播放（比如玩家从<code>GameOver</code>状态切换至<code>MenuState</code>的时候音乐其实已经是在播放了），我们不希望在这个时候做不必要的重放。</p><p>现在编译启动游戏之后它应该可以播放音乐了。</p></li><li><p>接下来我们需要让按钮被点击的时候播放一段音效。很简单，我们只需要告诉按钮的<code>onUP</code>属性（注）加载一段声音。在<code>MenuState</code>的<code>create()</code>函数中，开始按钮的初始化之后的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_btnPlay.onUp.sound = FlxG.sound.load(AssetPaths.select__wav);</span><br></pre></td></tr></table></figure></li><li><p>现在你可以对选项按钮做同样的事情（将以上代码的<code>_btnPlay</code>替换为<code>_btnOptions</code>）。</p><p>对于游戏中剩下的每一个按钮 - 位于<code>OptionsState</code>状态中的四个，以及位于<code>GameOver</code>状态中的那一个；它们的代码已经写好了，但作为课后练习你可以去这两个文件中看看是如何实现的。</p><p><em>注：不知道什么原因，<code>FlxButton</code>的<code>onUp</code>等属性在官方API文档中是没有被列出来的，但是源码中能找到，还带注释，它们的类型为<code>FlxButtonEvent</code>，是<code>FlxButton</code><a href="https://www.kancloud.cn/simon_chang/haxe3manual/183601" target="_blank" rel="noopener">模块</a>中的私有类，该类为<code>FlxButton</code>的辅助类用于<code>FlxButton</code>的事件处理。两个类型的关系可参考：<a href="https://www.kancloud.cn/simon_chang/haxe3manual/186343" target="_blank" rel="noopener">模块子类型</a>。这里记上一笔日后回来整理需要注意一下。</em></p></li><li><p>下一步让我们为玩家添加脚步声，我们不想要每次需要播放同一个声音的时候都创建与销毁一个新的声音对象（sound object），所以我们要创建一个<code>FlxSound</code>对象以便复用。在<code>Player</code>类体的顶部添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _sndStep:<span class="type">FlxSound</span>;</span><br></pre></td></tr></table></figure></li><li><p>然后我们需要在构造函数的某处加载脚步声文件。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndStep = FlxG.sound.load(AssetPaths.step__wav);</span><br></pre></td></tr></table></figure></li><li><p>接着跳到<code>movement()</code>函数中，在检查玩家是否处于移动的条件语句（<code>if((velocity.x != 0 || velocity.y != 0) &amp;&amp; touching == FlxObject.NONE)</code>）中第一行位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndStep.play();</span><br></pre></td></tr></table></figure><p><code>FlxSound</code>有一个灵活的小特性，如果你告诉它播放一个声音而它已经在播放了（并且你没有设置<code>forceRestart</code>flag为真）那么它不会再次播放。这意味着我们可以轻易地在玩家移动时按每一帧进行调用以播放声音，而且声音听起来就像是在不断循环。但当玩家不再移动时停止声音的播放，并处于静止状态时声音不会重放。</p></li><li><p>现在我们也为敌人创建脚步声，与上面不同的是我们现在不是一直以满格的音量重复播放脚步声，而是基于敌人与玩家间的距离来改变音量的高低，实际上实现起来比听起来简单得多，首先我们在<code>Enemy</code>类体的顶部添加一个变量：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _sndStep:<span class="type">FlxSound</span>;</span><br></pre></td></tr></table></figure></li><li><p>接着与对<code>Player</code>类的设置一样，添加以下代码到构造函数中：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_sndStep = FlxG.sound.load(AssetPaths.step__wav, <span class="number">.4</span>);</span><br><span class="line">_sndStep.proximity(x, y, FlxG.camera.target, FlxG.width * <span class="number">.6</span>);</span><br></pre></td></tr></table></figure><p>你可能注意到了我们把声音设为<code>.4</code>（40%），这是由于地图中将会有多个敌人存在，而他们的脚步声可能会很吵闹（另外，怪物有可能是光着脚不穿鞋的，不是吗？）</p></li><li><p>加载所有文件之后我们为声音设置了邻近跟踪，传入了该敌人的<code>x</code>与<code>y</code>坐标并告诉它追踪的目标为<code>FlxG.camera.target</code>对象（也就是我们的玩家）。最后我们告诉它声音的传播半径稍微比屏幕一半宽度多一点点，这样我们就能够听到稍微越出屏幕的敌人的声音。如此一来我们就能够听到 基于敌人与摄像机目标之间的距离 计算出的或大或小的脚步声了。</p></li><li><p>接下来我们要在敌人的<code>update()</code>函数中，位于<code>super.update()</code>调用之后的位置检查敌人是否处于移动状态，并且没有撞到墙上去。如果他们处于移动状态，我们将把脚步声放到这个敌人所处的位置上（放置于其精灵（sprite）的底部，也就是它的脚上），之后开始播放脚步声。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((velocity.x != <span class="number">0</span> || velocity.y != <span class="number">0</span>) &amp;&amp; toucing == FlxObject.NONE)</span><br><span class="line">&#123;</span><br><span class="line">    _sndStep.setPosition(x + frameWidth / <span class="number">2</span>, y + height);</span><br><span class="line">    _sndStep.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来我们跳到<code>PlayState</code>中，在<code>PlayState</code>中我们只需要一个声音文件，用于拾起硬币的时候播放，尽管你可以把它放到<code>Coin</code>类中，但是由于有可能一次会载入多枚硬币，并且我们实际上一次只能捡一枚硬币（所以音效不需要重叠（overlap）），把一个单独的硬币音效加载进<code>PlayState</code>可以为我们的性能节省一些开销。</p><p>就像添加其他音效一样，初始化变量：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _sndCoin:<span class="type">FlxSound</span>;</span><br></pre></td></tr></table></figure><p>在<code>create()</code>中加载音效：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndCoin = FlxG.sound.load(AssetPaths.coin__wav);</span><br></pre></td></tr></table></figure><p>之后在<code>playerTouchCoin()</code>函数中，在<code>if</code>语句里添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndCoin.play(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>这一次我们将使用<code>forceRestart</code>，这样当玩家拾起紧挨在一起的多枚硬币的时候新触发的声音会紧接而上。</p></li><li><p>剩下的音效由于都用于战斗阶段，所以会被放到<code>CombatHUD</code>类里面。</p><p>假设你已经下载了<code>CombatHUD</code>类文件，那么这些音效的相关代码就已经在里面写好了，不过作为一种课后练习，去完整浏览一遍也是个好主意，这样做有助于你在下一个项目中更好的理解声音的工作方式。</p><p>初始化变量：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _sndFled:<span class="type">FlxSound</span>;</span><br><span class="line"><span class="keyword">var</span> _sndHurt:<span class="type">FlxSound</span>;</span><br><span class="line"><span class="keyword">var</span> _sndLose:<span class="type">FlxSound</span>;</span><br><span class="line"><span class="keyword">var</span> _sndMiss:<span class="type">FlxSound</span>;</span><br><span class="line"><span class="keyword">var</span> _sndSelect:<span class="type">FlxSound</span>;</span><br><span class="line"><span class="keyword">var</span> _sndWin:<span class="type">FlxSound</span>;</span><br><span class="line"><span class="keyword">var</span> _sndCombat:<span class="type">FlxSound</span>;</span><br></pre></td></tr></table></figure><p>加载音效：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_sndFled = FlxG.sound.load(AssetPaths.fled__wav);</span><br><span class="line">_sndHurt = FlxG.sound.load(AssetPaths.hurt__wav);</span><br><span class="line">_sndLose = FlxG.sound.load(AssetPaths.lose__wav);</span><br><span class="line">_sndMiss = FlxG.sound.load(AssetPaths.miss__wav);</span><br><span class="line">_sndSelect = FlxG.sound.load(AssetPaths.select__wav);</span><br><span class="line">_sndWin = FlxG.sound.load(AssetPaths.win__wav);</span><br><span class="line">_sndCombat = FlxG.sound.load(AssetPaths.combat__wav);</span><br></pre></td></tr></table></figure><p>也许你知道它们会被放在哪些地方使用了，但我还是要过一遍。</p><p>于 initCombat 中：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndCombat.play();</span><br></pre></td></tr></table></figure><p>于 finishFadeIn 中：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndSelect.play();</span><br></pre></td></tr></table></figure><p>于<code>update()</code>函数中，位于三个按钮的按压判定相关的<code>if</code>语句（<code>if(_fire), else if(_up), else if(_down)</code>）中添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndSelect.play();</span><br></pre></td></tr></table></figure><p>于 makeChoice 中，位于 “命中” 的逻辑代码（在<code>_damages[1].text = &quot;1&quot;;</code>之后）的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndHurt.play();</span><br></pre></td></tr></table></figure><p>于闪躲的逻辑代码中添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndHurt.play();</span><br></pre></td></tr></table></figure><p>再往下，如果玩家逃脱（位于<code>cutcome = ESCAPE</code>之后的位置）添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndFled.play();</span><br></pre></td></tr></table></figure><p>于<code>enemyAttack()</code>中敌人的攻击命中玩家时：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndHurt.play();</span><br></pre></td></tr></table></figure><p>如果他们的攻击被miss了：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndMiss.play();</span><br></pre></td></tr></table></figure><p>最后，在 <code>DoneDamageOut()</code> 中，位于 <code>outcome = DEFEAT</code> 之后的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndLose.play();</span><br></pre></td></tr></table></figure><p>位于 <code>outcome = VICTORY</code> 之后的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndWin.play();</span><br></pre></td></tr></table></figure><p>添加声音的工作到此就结束了，编译并运行你的游戏，现在你可以听到我们添加的所有音效了（确保你把系统的声音打开了）下一节我们将使游戏可以跨平台运行。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打算一次翻译完剩下的部分之后去弄点别的事情，HaxeFlixel相关的东西很闲的时候再回来整理。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/sound-and-music/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程11:游戏结束菜单</title>
    <link href="https://nulllstack.github.io/2019/03/29/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B11-%E6%B8%B8%E6%88%8F%E7%BB%93%E6%9D%9F%E8%8F%9C%E5%8D%95/"/>
    <id>https://nulllstack.github.io/2019/03/29/HaxeFlixel官方教程11-游戏结束菜单/</id>
    <published>2019-03-29T08:39:03.000Z</published>
    <updated>2019-09-12T18:02:43.783Z</updated>
    
    <content type="html"><![CDATA[<p>这周情绪一天也没消停过，现在是 2019/3/29 15:06 我已经一周没去上课了，起床冲了咖啡，饭一顿也没吃，开始考虑是不是要去看医生。</p><p><a href="http://haxeflixel.com/documentation/game-over-menu/" target="_blank" rel="noopener">原文</a></p><p>我们的游戏现在开始最后的整合阶段，现在我们需要为其添加一个胜负功能使其更像一个完整的游戏，对于我们这个简单的游戏而言，我们想要让玩家如果在战斗阶段死亡，则游戏结束，或者是玩家击败了Boss即获胜，这两个情况下都会跳转至同一个<code>FlxState</code>状态下，它将显示最终得分并允许玩家从这里重新开始游戏。</p><ol><li><p>让我们从<code>PlayState</code>开始，我们需要设一个flag用于检查游戏是否结束，以及玩家是否获胜：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ending:<span class="type">Bool</span>;</span><br><span class="line"><span class="keyword">var</span> _won:<span class="type">Bool</span>;</span><br></pre></td></tr></table></figure><p>两个变量添加于类体的顶部。</p></li><li><p>下一步，位于<code>update()</code>函数，<code>super.update(elapsed)</code>的调用后方的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_ending)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在游戏结束时开始准备开始切换state，不需要做其他任何事情所以return。</p></li><li><p>下一步，依然在<code>update()</code>函数中，把原来的逻辑代码修改为如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!_combatHud.visible)</span><br><span class="line">&#123;</span><br><span class="line">    _health = _combatHud.playerHealth;</span><br><span class="line">    _hud.updateHUD(_health, _money);</span><br><span class="line">    <span class="keyword">if</span>(_combatHud.outcome == DEFEAT)</span><br><span class="line">    &#123;</span><br><span class="line">        _ending = <span class="literal">true</span>;</span><br><span class="line">        FlxG.camera.fade(FlxColor.BLACK, <span class="number">.33</span>, <span class="literal">false</span>, doneFadeOut);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(_combatHud.outcome == VICTORY)</span><br><span class="line">        &#123;</span><br><span class="line">            _combatHud.e.kill();</span><br><span class="line">            <span class="keyword">if</span>(_combatHud.e.etype == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _won = <span class="literal">true</span>;</span><br><span class="line">                _ending = <span class="literal">true</span>;</span><br><span class="line">                FlxG.camera.fade(FlxColor.BLACK, <span class="number">.33</span>, <span class="literal">false</span>, doneFadeOut);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _combatHud.e.flicker();</span><br><span class="line">        &#125;</span><br><span class="line">        _inCombat = <span class="literal">false</span>;</span><br><span class="line">        _player.active = <span class="literal">true</span>;</span><br><span class="line">        _grpEnemies.active = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里所做的事情为检查结果是否为<code>DEFEAT</code>，如果是则设结束flag为真，并告诉摄像机开始渐隐（fading out），渐隐结束后调用<code>doneFadeOut()</code>。</p><p>相似的，如果结果为<code>VICTORY</code>，并且被击败的敌人类型为1（也就是Boss），则设<code>won</code>flag为真，并开始渐隐。</p></li><li><p>当摄像机渐隐为黑色之后，我们将调用该函数，它用于切换状态至<code>GameOverState</code>（我们在之后添加该类），并传递玩家是否获胜的信息以及玩家收集了多少金币：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doneFadeOut</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    FlxG.switchState(<span class="keyword">new</span> <span class="type">GameOverState</span>(_won, _money));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要添加<code>GameOverState</code>类。它是一个十分简单的<code>FlxState</code>对象，用于显示一些信息： “Game Over” 或 “You Win!” （显示哪一个取决于获胜flag的当前值）、以及玩家收集了多少金币。这里我们还将使用flixel的保存/读取功能用以比较历史最高分，如果当前玩家收集的金币比历史记录更多，我们将对当前分数替换历史最高分进行保存，并显示当前最高分。</p><p>最后我们会添加一个返回按钮使玩家可以退回至菜单界面。</p><p>这里是该类的源码：</p><p><a href="https://github.com/HaxeFlixel/flixel-demos/blob/dev/Tutorials/TurnBasedRPG/source/GameOverState.hx" target="_blank" rel="noopener">GameOverState.hx</a></p></li></ol><p>如果你开始测试你的游戏，你将可以通过于战斗阶段死亡或击败Boss而触发<code>GameOverState</code>，接着点击<code>GameOverState</code>状态中的按钮返回至<code>MenuState</code>状态，这样你就可以再一次开始游戏。如果游戏能够如以上描述的正常工作表明你目前没有偏离正轨。不过…目前我们的<code>MenuState</code>看起来有些乏味，所以我们开始为它添加些东西。</p><ol><li><p>让我们为它添加一个标题以及一个选项按钮（于<code>MenuState.hx</code>中）：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _txtTitle:<span class="type">FlxText</span>;</span><br><span class="line"><span class="keyword">var</span> _btnOptions:<span class="type">FlxButton</span>;</span><br></pre></td></tr></table></figure></li><li><p>接着，在<code>create()</code>函数中，我们把它添加至状态中（并移动原来的开始游戏按钮）：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_txtTitle = <span class="keyword">new</span> <span class="type">FlxText</span>(<span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">"HaxeFlixel\nTutorial\nGame"</span>, <span class="number">22</span>);</span><br><span class="line">_txtTitle.alignment = CENTER;</span><br><span class="line">_txtTitle.screenCenter(X);</span><br><span class="line">add(_txtTitle);</span><br><span class="line"></span><br><span class="line">_btnPlay = <span class="keyword">new</span> <span class="type">FlxButton</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Play"</span>, clickPlay);</span><br><span class="line">_btnPlay.x = (FlxG.width / <span class="number">2</span>) - _btnPlay.width - <span class="number">10</span>;</span><br><span class="line">_btnPlay.y = FlxG.height - _btnPlay.height - <span class="number">10</span>;</span><br><span class="line">add(_btnPlay);</span><br><span class="line"></span><br><span class="line">_btnOptions = <span class="keyword">new</span> <span class="type">FlxButton</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Options"</span>, clickOptins);</span><br><span class="line">_btnOptions.x = (FlxG.width / <span class="number">2</span>) + <span class="number">10</span>;</span><br><span class="line"> _btnOptions.y = FlxG.height - _btnOptions.height - <span class="number">10</span>;</span><br><span class="line"> add(_btnOptions);</span><br></pre></td></tr></table></figure></li><li><p>添加一个函数用于当选项按钮被点击时调用：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clickOptions</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    FlxG.switchState(<span class="keyword">new</span> <span class="type">OptionsState</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当选项按钮被点击后切换的<code>OptionState</code>状态类也相当简单，它将包含一个按钮用于使玩家可以清空以保存的数据（如 历史最高分），以及一个简单的<code>FlxBar</code>拉动条用于表示当前游戏的音量级数以及一组按钮用于调整音量级数的高低。它将会保存当前音量的值，所以当游戏开始时它将会记住最后音量级数的设置（我知道我们的游戏现在还没有声音 ;) ）。</p><p>该类的源码：</p><p><a href="https://github.com/HaxeFlixel/flixel-demos/blob/dev/Tutorials/TurnBasedRPG/source/OptionsState.hx" target="_blank" rel="noopener">OptionsState.hx</a></p><p><code>OptionsState</code>类使用了一组精灵序列供音量调节按钮使用（因为他们需要比默认的按钮更小一些），该资源文件需要包含3个帧，分别表现出按钮的三个状态：<code>正常</code>、<code>高亮</code>、以及<code>被按下</code>。我们只需要按此顺序排列这个精灵序列的各个帧，<code>FlxButton</code>会为我们处理剩余的工作。</p><p>再一次，你可以自己做一个，或者使用下面提供的图像资源。将其放置于<code>assets/images</code>文件夹内即可。</p></li></ol><div align="center"><p><img src="//nulllstack.github.io/2019/03/29/HaxeFlixel官方教程11-游戏结束菜单/button.png" alt></p></div><p>   最后，我们需要游戏每次开始时读取已保存的音量设置（如果当前有设置的话），跳转至<code>Main.hx</code>类，并在<code>addChild()</code>函数调用之后的位置添加以下代码：</p>   <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _save:<span class="type">FlxSave </span>= <span class="keyword">new</span> <span class="type">FlxSave</span>();</span><br><span class="line">_save.bind(<span class="string">"flixel-tutorial"</span>);</span><br><span class="line"><span class="keyword">if</span>(_save.data.volume != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    FlxG.sound.volume = _save.data.volume;</span><br><span class="line">&#125;</span><br><span class="line">_save.close();</span><br></pre></td></tr></table></figure><p>   十分简单，它创建一个新的<code>FlxSave</code>对象，将其绑定至我们的<code>&quot;flixel-tutorial&quot;</code>并在之后检查是否有音量值被存储进来，如果有，则将游戏的音量设为该值，之后关闭保存。</p><p>测试游戏，确保正常工作，如果你在设置中修改了音量设置并退出游戏，它将会在下一次进入游戏时保留当前设置的音量值。</p><div align="center"><p><img src="//nulllstack.github.io/2019/03/29/HaxeFlixel官方教程11-游戏结束菜单/0022.png" alt></p></div><p>看起来不错，下一节我们将添加一些音效与音乐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这周情绪一天也没消停过，现在是 2019/3/29 15:06 我已经一周没去上课了，起床冲了咖啡，饭一顿也没吃，开始考虑是不是要去看医生。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/game-over-menu
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程10:UI与战斗系统</title>
    <link href="https://nulllstack.github.io/2019/03/16/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B10-UI%E4%B8%8E%E6%88%98%E6%96%97%E7%B3%BB%E7%BB%9F/"/>
    <id>https://nulllstack.github.io/2019/03/16/HaxeFlixel官方教程10-UI与战斗系统/</id>
    <published>2019-03-15T17:23:28.000Z</published>
    <updated>2019-03-29T08:41:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/ui-and-combat/" target="_blank" rel="noopener">原文</a></p><p>由于这次内容涉及比较多东西，估计摸索的时间会比较长，文本我先翻译完先放上来，之后摸索完整理些细节再另外po一篇作为补充。</p><p>现在我们需要让玩家知道他们在游戏中的行为产生了哪些影响。所以我们需要在屏幕中显示一个HUD用于告诉玩家 当前/最大 血量为多少，以及目前收集了多少金币。表示生命值的图标你可以使用这个图形资源：<img src="//nulllstack.github.io/2019/03/16/HaxeFlixel官方教程10-UI与战斗系统/health.png" alt>,确保你将图像资源保存至<code>assets/images</code>文件夹下。</p><ol><li><p>我们首先新建一个<code>HUD</code>类，它用于保存所有的HUD元素。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> flixel.FlxSprite;</span><br><span class="line"><span class="keyword">import</span> flixel.text.FlxText;</span><br><span class="line"><span class="keyword">import</span> flixel.FlxSprite;</span><br><span class="line"><span class="keyword">import</span> flixel.group.FlxGroup.FlxTypedGroup;</span><br><span class="line"><span class="keyword">import</span> flixel.util.FlxColor;</span><br><span class="line"><span class="keyword">import</span> flixel.FlxG;</span><br><span class="line"><span class="keyword">using</span> flixel.util.FlxSpriteUtil;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HUD</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">FlxTypedGroup</span></span>&lt;<span class="title">FlxSprite</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _sprBack:<span class="type">FlxSprite</span>;</span><br><span class="line">    <span class="keyword">var</span> _txtHealth:<span class="type">FlxText</span>;</span><br><span class="line">    <span class="keyword">var</span> _txtMoney:<span class="type">FlxText</span>;</span><br><span class="line">    <span class="keyword">var</span> _sprHealth:<span class="type">FlxSprite</span>;</span><br><span class="line">    <span class="keyword">var</span> _sprMoney:<span class="type">FlxSprite</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        _sprBack = <span class="keyword">new</span> <span class="type">FlxSprite</span>().makeGraphic(FlxG.width, <span class="number">20</span>, FlxColor.BLACK);</span><br><span class="line">        </span><br><span class="line">        _sprBack.drawRect(<span class="number">0</span>, <span class="number">19</span>, FlxG.width, <span class="number">1</span>, FlxColor.WHITE); </span><br><span class="line">        <span class="comment">/*此处技术细节参考：https://www.kancloud.cn/simon_chang/haxe3manual/183635*/</span></span><br><span class="line">        </span><br><span class="line">        _txtHealth = <span class="keyword">new</span> <span class="type">FlxText</span>(<span class="number">16</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="string">"3 / 3"</span>, <span class="number">8</span>);</span><br><span class="line">        _txtHealth.setBorderStyle(SHADOW, FlxColor.GRAY, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        _txtMoney = <span class="keyword">new</span> <span class="type">FlxText</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="string">"0"</span>, <span class="number">8</span>);</span><br><span class="line">        _txtMoney.setBorderStyle(SHADOW, FlxColor.GRAY, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        _sprHealth = <span class="keyword">new</span> <span class="type">FlxSprite</span>(<span class="number">4</span>, _txtHealth.y + (_txtHealth.height/<span class="number">2</span>) - <span class="number">4</span>, AssetPaths.health__png);</span><br><span class="line">        _sprMoney = <span class="keyword">new</span> <span class="type">FlxSprite</span>(FlxG.width - <span class="number">12</span>, _txtMoney.y + (_txtMoney.height/<span class="number">2</span>) - <span class="number">4</span>, AssetPaths.coin__png);</span><br><span class="line">        _txtMoney.alignment = RIGHT;</span><br><span class="line">        _txtMoney.x = _sprMoney.x - _txtMoney.width - <span class="number">4</span>;</span><br><span class="line">        add(_sprBack);</span><br><span class="line">        add(_sprHealth);</span><br><span class="line">        add(_sprMoney);</span><br><span class="line">        add(_txtHealth);</span><br><span class="line">        add(_txtMoney);</span><br><span class="line">        </span><br><span class="line">        forEach(<span class="function"><span class="keyword">function</span></span>(spr:<span class="type">FlxSprite</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    spr.scrollFactor.<span class="keyword">set</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">/*注意此处的forEach()函数并非一个迭代语句（iterate statement)，它是声明于FlxGroup类中的一个函数具体细节参考官方API文档*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">updateHUD</span></span>(Health:<span class="type">Int </span>= <span class="number">0</span>, Money:<span class="type">Int </span>= <span class="number">0</span>):<span class="type">Void</span></span><br><span class="line"><span class="type">    </span>&#123;</span><br><span class="line">        _txtHealth.text = Std.string(Health) + <span class="string">" / 3"</span>;</span><br><span class="line">        _txtMoney.text = Std.string(Money);</span><br><span class="line">        _txtMoney.x = _sprMoney.x - _txtMoney.width - <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类继承自<code>FlxTypedGroup&lt;FlxSprite&gt;</code>类所以它可以用于保存我们所有的<code>FlxSprite</code>对象。它由5个部分组成：背景（黑色，底部有一条1像粗细的白色细线），两个<code>FlxText</code>对象（一个用于生命值，一个用于当前金币），两个<code>FlxSprite</code>对象（用于在<code>FlxText</code>对象旁边显示图标）。在构造函数的函数体最后几行里我们调用了<code>forEach()</code>遍历当前Group的所有成员并将它们的<code>scrollFactor.x</code>与<code>scrollFactor.y</code>都设为 0，这么做可以使得摄像机在滚动的时候这些对象的位置也会停留在原地（相对于显示屏幕）。</p><p>最后我们声明了一个函数使得从任意位置调用时告诉<code>HUD</code>应该如何显示。</p></li><li><p>现在我们要让它开始实际工作并在玩家不论何时捡起硬币时更新数据。在<code>PlayState</code>类的顶部添加以下变量：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _hud:<span class="type">HUD</span>;</span><br><span class="line"><span class="keyword">var</span> _money:<span class="type">Int </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> _health:<span class="type">Int </span>= <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>在<code>create()</code>函数，于<code>super.create()</code>语句之前的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_hud = <span class="keyword">new</span> <span class="type">HUD</span>();</span><br><span class="line">add(_hud);</span><br></pre></td></tr></table></figure></li><li><p>最后，在<code>playerTouchCoin()</code>函数体中的<code>if</code>语句中任意位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_money++;</span><br><span class="line">_hud.updateHUD(_health, _money);</span><br></pre></td></tr></table></figure></li></ol><p>接着测试你的游戏，HUD应该会在你每次拾起硬币的时候更新显示的内容。</p><p><img src="//nulllstack.github.io/2019/03/16/HaxeFlixel官方教程10-UI与战斗系统/untitled.png" alt></p><p>如果我们有一个使玩家的角色受到伤害的方式，那么我们也需要更新HUD显示的生命值，不过首先我们要确定玩家与敌人战斗的形式。</p><p>现在让我们开始搭建我们的战斗系统。首先，在这里我们并不是要做一个如最终幻想那样庞大的战斗系统，这里只不过是对几个不同的元素如何工作做出一个基本演示。所以我想这里我们要做的是当玩家与敌人发生碰撞时，跳出一个界面，显示玩家与敌人当前的生命值（为了视觉上更为友好，数值显示于一管血条中），并为玩家提供两个选项：<code>战斗</code>或<code>逃跑</code>。</p><p>如果玩家选择了战斗，我们将roll一个随机数用于判断玩家与敌人间的攻击是否击中了对方，如果击中了，将对对方造成一点伤害。如果敌人死亡玩家将脱离战斗状态。而如果玩家选择了逃跑，我们将以同样的方式判断玩家是否成功脱离，如果成功脱离战斗则关闭战斗界面，并使敌人在原地停顿几秒给玩家时间远离它。如果脱离失败了，敌人会乘机攻击玩家。我们还要在战斗界面显示当前攻击是否被闪躲或造成了多少伤害值。</p><p>这些看起来很简单，但实际上这需要几个不同的部分相互协作来实现，他其实是我们到目前为止所作的最复杂的部分。</p><ol><li><p>第一个部分是<code>CombatHUD</code>类。这是一个庞大的类，战斗系统主要的逻辑代码都交由这个类完成。你可以在这里查看完整的源码：</p><p><a href="https://github.com/HaxeFlixel/flixel-demos/blob/dev/Tutorials/TurnBasedRPG/source/CombatHUD.hx" target="_blank" rel="noopener">CombatHUD.hx</a></p><p>花点时间完整的查看这个类的源码搞清楚它是如何工作的，之后再将它添加进你的项目里。</p><p>我们现在已经有了供<code>CombatHUD</code>类使用的大部分资源文件，但是我们还需要一个图形文件，用于当玩家做选择时显示的箭头图形。你可以在<a href="https://github.com/HaxeFlixel/flixel-demos/blob/dev/Tutorials/TurnBasedRPG/assets/images/pointer.png" target="_blank" rel="noopener">这里下载</a>（点击download）（或者自己做一个），确保文件名为<code>pointer.png</code>并把它保存至项目文件夹内的<code>assets/images</code>文件夹内。</p><p><code>CombatHUD</code>类中还使用了一些我们尚未讨论的东西：<em>声音</em>。我们将会在 “声音与音乐” 章节对此进行更深入的探讨，现在请先将以下这些文件下载<code>assets/sounds</code>文件夹下，这样才能让源码正确编译。</p><p>这我就不单独罗列了，github上有，把链接里全部<code>wav</code>文件都下下来：<a href="https://github.com/HaxeFlixel/flixel-demos/tree/dev/Tutorials/TurnBasedRPG/assets/sounds" target="_blank" rel="noopener">链接</a></p></li><li><p>现在你需要为<code>Enemy</code>类添加一个简单的函数：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">changeEnemy</span></span>(EType:<span class="type">Int</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(etype != EType)</span><br><span class="line">    &#123;</span><br><span class="line">        etype = EType;</span><br><span class="line">        loadGraphic(<span class="string">"assets/images/enemy-"</span> + etype + <span class="string">".png"</span>, <span class="literal">true</span>, <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着我们需要把<code>CombatHUD</code>对象添加进<code>PlayState</code>类中，把以下代码添加至<code>PlayState</code>类的顶部：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _inCombat:<span class="type">Bool </span>= <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> _combatHud:<span class="type">CombatHUD</span>;</span><br></pre></td></tr></table></figure></li><li><p>移动到<code>create()</code>函数的位置，在函数体中，在我们添加（add）HUD之后，调用<code>super.create()</code>之前的位置添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_combatHud = <span class="keyword">new</span> <span class="type">CombatHUD</span>();</span><br><span class="line">add(_combatHud);</span><br></pre></td></tr></table></figure></li><li><p>移动到<code>update()</code>函数的位置，将其修改为<strong>仅当</strong>处于非战斗状态时才进行碰撞与重叠检测。位于<code>super.update()</code>调用之后的所有东西应该如以下代码所示：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!_inCombat)</span><br><span class="line">&#123;</span><br><span class="line">    FlxG.collide(_player, _mWalls);</span><br><span class="line">    FlxG.overlap(_player, _grpCoins, playerTouchCoin);</span><br><span class="line">    FlxG.collide(_grpEnemies, _mWalls);</span><br><span class="line">    _grpEnemies.forEachAlive(checkEnemyVision);</span><br><span class="line">    FlxG,overlap(_player, _grpEnmies, playerTouchEnemy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_combatHud.visible)</span><br><span class="line">    &#123;</span><br><span class="line">        _health = _combatHud.playerHealth;</span><br><span class="line">        _hud.updateHUD(_health, _money);</span><br><span class="line">        <span class="keyword">if</span>(_combatHud.outcome == VICTORY)</span><br><span class="line">        &#123;</span><br><span class="line">            _combatHud.e.kill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _combatHud.e.flicker();</span><br><span class="line">        &#125;</span><br><span class="line">        _inCombat = <span class="literal">false</span>;</span><br><span class="line">        _player.active = <span class="literal">true</span>;</span><br><span class="line">        _grpEnemies.active = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们要添加一个条件检测，用于检查玩家是否碰到一个敌人，如果是则调用回调函数以查看我们是否应该开始战斗。</p><p>如果我们处于战斗阶段，我们就持续检测HUD当前是否为可见的，当它为不可见时我们就知道战斗结束了，之后我们就可以对结果进行结算，当结果为<code>VICTORY</code>（我们的四个枚举值的其中一个）时，我们就杀掉敌人（<code>_combatHud.e.kill()</code>），而当玩家选择了逃跑，我们将使该敌人闪烁，用于表示玩家从这一刻起的一小段时间内将是安全的不会与该敌人再次触发战斗。</p></li><li><p>你可能已经发现了我们的<code>Enemy</code>类并没有<code>flicker()</code>函数（注），这是因为我们将使用<code>FlxSpriteUtil</code>类的一个函数来实现这个功能，Haxe提供了一个很nice的语法特性来帮我们完成这个工作。那么在<code>PlayState</code>类文件的顶部，位于其他导入语句（import）之后，添加一行代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> flixel.util.FlxSpriteUtil;</span><br></pre></td></tr></table></figure><p>这将使得我们可以使用<code>FlxSpriteUtil</code>的APIs，如<code>flicker()</code>函数，它可以被用于任何<code>FlxObject</code>对象。具体技术细节参考<a href="https://haxe.org/manual/lf-static-extension.html" target="_blank" rel="noopener">官方文档-静态扩展</a>。</p><p><strong>注：<code>_combatHud.e.flicker()</code>的调用使用了Haxe的语法特性-*<a href="https://www.kancloud.cn/simon_chang/haxe3manual/183635" target="_blank" rel="noopener">静态扩展</a>*，使得我们的<code>Enemy</code>类本身即使没有flicker()函数也可以通过外部类进行扩展。</strong></p></li><li><p>接下来让我们添加一个函数用于处理当玩家触碰到一个敌人的情况：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playerTouchEnemy</span></span>(P:<span class="type">Player</span>, E:<span class="type">Enemy</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(P.alive &amp;&amp; P.exists &amp;&amp; E.alive &amp;&amp; E.exists &amp;&amp; !E.isFlickering())</span><br><span class="line">    &#123;</span><br><span class="line">        startCombat(E);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startCombat</span></span>(E:<span class="type">Enemy</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    _inCombat = <span class="literal">true</span>;</span><br><span class="line">    _player.active = <span class="literal">false</span>;</span><br><span class="line">    _grpEnemies.active = <span class="literal">false</span>;</span><br><span class="line">    _combatHud.initCombat(_health, E);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这里检查玩家与敌人的<code>alive</code>与<code>exists</code>属性是否都为<code>true</code>并且敌人不处于闪烁状态（闪烁状态下的敌人是那些我们刚刚脱离战斗状态的敌人）。如果条件都满足，我们就使之进入战斗状态。</p><p><code>startCombat()</code>函数所做的事情是设置我们的<code>inCombat</code>flag进行赋值（这样做使得我们可以知道是否进行碰撞检测），并使玩家与敌人都进入非活动状态，这样它们将停止逻辑代码的更新（暂停<code>update()</code>的调用）。</p><p>最后我们调用<code>initCombat()</code>函数，使得<code>CombatHUD</code>初始化并开始工作。</p></li><li><p>最后的最后，我们要使闪烁的敌人原地不动，它们应该在玩家逃跑后停顿几秒。</p><p>在<code>Enemy</code>类中，于<code>update()</code>函数体内添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.isFlickering())</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>把这段代码放在函数体的第一行的位置，优先于函数体内其他语句执行。</p><p>注意<code>isFlickering()</code>函数同样来自<code>FlxSpriteUtil</code>类，所以如前面的做法，需要在<code>Enemy</code>类中添加一行<code>using</code>语句：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> flixel.util.FlxSpriteUtil;</span><br></pre></td></tr></table></figure><p>这样就ok了，测试游戏确保能如期正常运行！</p><p><img src="//nulllstack.github.io/2019/03/16/HaxeFlixel官方教程10-UI与战斗系统/0020.png" alt></p><p>下一节我们将涉及获胜于失败状态（<code>PlayState</code>是游玩状态），并整合我们的所有状态（state）。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/ui-and-combat/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于这次内容涉及比较多东西，估计摸索的时间会比较长，文本我先翻
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程9:敌人与基础AI</title>
    <link href="https://nulllstack.github.io/2019/03/08/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B9-%E6%95%8C%E4%BA%BA%E4%B8%8E%E5%9F%BA%E7%A1%80AI/"/>
    <id>https://nulllstack.github.io/2019/03/08/HaxeFlixel官方教程9-敌人与基础AI/</id>
    <published>2019-03-07T17:39:49.000Z</published>
    <updated>2019-03-07T17:42:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/enemies-and-basic-ai/" target="_blank" rel="noopener">原文</a></p><p>如果地牢游戏里没有敌人的话就太名不副实了，所以现在我们来添加一些敌人进去！</p><ol><li><p>现在为你的 Ogmo 项目添加一个新的实体（entity）- 你很快就会习惯于这个工作流：</p><p><img src="//nulllstack.github.io/2019/03/08/HaxeFlixel官方教程9-敌人与基础AI/1.png" alt></p><p>确保你添加了<code>etype</code>值。</p></li><li><p>接着在地图里散布一些敌人，确保其中有且只有一个敌人的<code>etype</code>值为1，其余为0</p><p><img src="//nulllstack.github.io/2019/03/08/HaxeFlixel官方教程9-敌人与基础AI/2.png" alt></p></li><li><p>那么我们想要游戏中存在两种类型的敌人，我们需要为它们提供两组精灵序列图，同样是16x16像素大小、与我们的player精灵序列图一样数量的动作帧。把它们命名为<code>enemy-0.png</code>与<code>enemy-1.png</code>，并保存至<code>assets/images</code>文件夹下，一下提供这两组精灵序列图给你使用（再次感谢 Vicky 为我们创作的图形资源！）：</p><p><img src="//nulllstack.github.io/2019/03/08/HaxeFlixel官方教程9-敌人与基础AI/enemy-0.png" alt></p><p><img src="//nulllstack.github.io/2019/03/08/HaxeFlixel官方教程9-敌人与基础AI/enemy-1.png" alt></p><p>注意：确保你的两个精灵序列图以相同方式工作，它们在每个朝向上（facing）的动画都应该有相同数量的帧。</p></li><li><p>现在让我们来添加一个<code>Enemy</code>类，这个类整体上与我们的<code>Player</code>类十分相似，其中有几处改动：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enemy</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">FlxSprite</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> speed:<span class="type">Float </span>= <span class="number">140</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> etype(<span class="keyword">default</span>, <span class="literal">null</span>):<span class="type">Int</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(X:<span class="type">Float</span>=<span class="number">0</span>, Y:<span class="type">Float</span>=<span class="number">0</span>, EType:<span class="type">Int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(X, Y);</span><br><span class="line">        etype = EType;</span><br><span class="line">        loadGraphic(<span class="string">"assets/images/enemy-"</span> + etype + <span class="string">".png"</span>, <span class="literal">true</span>, <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">        setFacingFlip(FlxObject.LEFT, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        setFacingFlip(FlxObject.RIGHT, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        animation.add(<span class="string">"d"</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>], <span class="number">6</span>, <span class="literal">false</span>);</span><br><span class="line">        animation.add(<span class="string">"lr"</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>], <span class="number">6</span>, <span class="literal">false</span>);</span><br><span class="line">        animation.add(<span class="string">"u"</span>, [<span class="number">6</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>], <span class="number">6</span>, <span class="literal">false</span>);</span><br><span class="line">        drag.x = drag.y = <span class="number">10</span>;</span><br><span class="line">        width = <span class="number">8</span>;</span><br><span class="line">        height = <span class="number">14</span>;</span><br><span class="line">        offset.x = <span class="number">4</span>;</span><br><span class="line">        offset.y = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">draw</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((velocity.x != <span class="number">0</span> || velocity.y != <span class="number">0</span> ) &amp;&amp; touching == FlxObject.NONE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(velocity.x) &gt; Math.abs(velocity.y))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (velocity.x &lt; <span class="number">0</span>)</span><br><span class="line">                    facing = FlxObject.LEFT;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    facing = FlxObject.RIGHT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (velocity.y &lt; <span class="number">0</span>)</span><br><span class="line">                    facing = FlxObject.UP;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    facing = FlxObject.DOWN;</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">switch</span> (facing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> FlxObject.LEFT, FlxObject.RIGHT:<span class="type"></span></span><br><span class="line"><span class="type">                    animation</span>.play(<span class="string">"lr"</span>);</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">case</span> FlxObject.UP:<span class="type"></span></span><br><span class="line"><span class="type">                    animation</span>.play(<span class="string">"u"</span>);</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">case</span> FlxObject.DOWN:<span class="type"></span></span><br><span class="line"><span class="type">                    animation</span>.play(<span class="string">"d"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的不同点在于现在我们有一个新的<code>etype</code>变量，它被我们用于确定哪个enemy的精灵序列图将要被加载，以及我们将处理哪一个精灵等等。</p></li><li><p>接下来我们需要在<code>PlayState</code>中创建一个<code>FlxGroup</code>实例，用于保存我们的enemies对象并把他们加载进地图内，与前面章节对coin对象的操作极为相似。</p><p>位于类的顶部添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _grpEnemies:<span class="type">FlxTypedGroup</span>&lt;Enemy&gt;;</span><br></pre></td></tr></table></figure><p>在构造函数中，位于coin组的实例化之后的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_grpEnemies = <span class="keyword">new</span> <span class="type">FlxTypedGroup</span>&lt;Enemy&gt;();</span><br><span class="line">add(_grpEnemies);</span><br></pre></td></tr></table></figure><p>然后在<code>placeEntities()</code>函数中位于 if/else 语句之后的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(entityName == <span class="string">"enemy"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _grpEnemies.add(<span class="keyword">new</span> <span class="type">Enemy</span>(x + <span class="number">4</span>, y, Std.parseInt(EntityData.<span class="keyword">get</span>(<span class="string">"etype"</span>))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着编译一下游戏测试一下敌人是不是被正确的添加至游戏中。</p></li></ol><p>现在让我们给敌人创造一个大脑。</p><p>为了让我们的敌人能够“思考”，我们将要应用一个简单的 有限状态机（<a href="http://en.wikipedia.org/wiki/Finite_state_machine" target="_blank" rel="noopener">Finite-state Machine(FSM)</a>）。</p><p>简单来说，可以把一个FSM看成是一个一次只能表现一个状态的机器或实体，对应地我们将给予我们的 enemies 对象两种可能存在的状态：渡步（<code>Idle</code>）与追逐（<code>Chase</code>）。当它们看不到玩家时，它们将处于渡步状态下，即无目的的在四周徘徊。直到玩家出现在它们的视野范围内，它们将切换为追逐状态，朝玩家所处位置跑动。</p><ol><li><p>这应该不会很难，首先让我们来创建一个<code>FSM</code>类：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FSM</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> activeState:<span class="type">Void-&gt;Void</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(?InitState:<span class="type">Void-&gt;Void</span>):<span class="type">Void</span></span><br><span class="line"><span class="type">    </span>&#123;</span><br><span class="line">        activeState = InitState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(activeState != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            activeState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着我们稍微对<code>Enemy</code>类做一点修改。</p><p>我们需要在类的顶部定义以下这些变量：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _brain:<span class="type">FSM</span>;</span><br><span class="line"><span class="keyword">var</span> _idleTmr:<span class="type">Float</span>;</span><br><span class="line"><span class="keyword">var</span> _moveDir:<span class="type">Float</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> seesPlayer:<span class="type">Bool </span>= <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> playerPos(<span class="keyword">default</span>, <span class="literal">null</span>):<span class="type">FlxPoint</span>;</span><br></pre></td></tr></table></figure></li><li><p>并在位于构造函数的末尾处添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_brain = <span class="keyword">new</span> <span class="type">FSM</span>(idle);</span><br><span class="line">_idleTmr = <span class="number">0</span>;</span><br><span class="line">playerPos = FlxPoint.<span class="keyword">get</span>();</span><br></pre></td></tr></table></figure></li><li><p>接着添加以下几个函数：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">idle</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seesPlayer)</span><br><span class="line">    &#123;</span><br><span class="line">        _brain.activeState = chase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(_idleTmr &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(FlxG.random.bool(<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            _moveDir = <span class="number">-1</span>;</span><br><span class="line">            velocity.x = velocity.y = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _moveDir = FlxG.random.int(<span class="number">0</span>, <span class="number">8</span>) * <span class="number">45</span>;</span><br><span class="line">            velocity.<span class="keyword">set</span>(speed * <span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">            velocity.rotate(FlxPoint.weak(), _moveDir);</span><br><span class="line">        &#125;</span><br><span class="line">        _idleTmr = FlxG.random.int(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    _idleTmr -= FlxG.elapsed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">chase</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!seesPlayer)</span><br><span class="line">        _brain.activeState = idle;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        FlxVelocity.moveTowardsPoint(<span class="built_in">this</span>, playerPos, Std.int(speed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span></span>(elapsed:<span class="type">Float</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    _brain.update();</span><br><span class="line">    <span class="keyword">super</span>.update(elapsed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其工作方式是这样的：每个敌人将以<code>Idle</code>也就是渡步状态生成，在<code>PlayState</code>中每一个敌人将时刻检查是否看到玩家，如果看到了，它将切换至<code>Chase</code>也就是追逐状态，直到不再能够看到玩家为止。当处于<code>Idle</code>状态下，通常（随机间隔内）选择一个随机的朝向移动（以及一个小概率的止步不前）。当处于<code>Chase</code>状态下时它们会朝玩家所处位置移动。</p></li><li><p>让我们跳回到<code>PlayState</code>类中，添加检测玩家的视野范围的逻辑代码。在<code>update()</code>函数中位于重叠与碰撞检测的代码之后的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FlxG.collide(_grpEnemies, _mWalls);</span><br><span class="line">_grpEnemies.forEeachAlive(checkEnemyVision);</span><br></pre></td></tr></table></figure></li><li><p>接着添加<code>checkEnemyVision()</code>函数：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkEnemyVision</span></span>(e:<span class="type">Enemy</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_mWalls.ray(e.getMidpoint(), _player.getMidpoint()))</span><br><span class="line">    &#123;</span><br><span class="line">        e.seesPlayer = <span class="literal">true</span>;</span><br><span class="line">        e.playerPos.copyFrom(_player.getMidpoint());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    e.seesPlayer = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>至此就完成这一节的所有工作了，编译运行你的游戏确保它能正常工作！</p><p><img src="//nulllstack.github.io/2019/03/08/HaxeFlixel官方教程9-敌人与基础AI/untitled.png" alt></p><p>下一节，我们将为游戏添加一些UI，以及一个 RPG 类型的战斗系统，这样玩家就能够与敌人进行战斗了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/enemies-and-basic-ai/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果地牢游戏里没有敌人的话就太名不副实了，所以现
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>蛋疼的迁移过程</title>
    <link href="https://nulllstack.github.io/2019/03/06/%E8%9B%8B%E7%96%BC%E7%9A%84%E8%BF%81%E7%A7%BB%E8%BF%87%E7%A8%8B/"/>
    <id>https://nulllstack.github.io/2019/03/06/蛋疼的迁移过程/</id>
    <published>2019-03-05T17:28:15.000Z</published>
    <updated>2019-03-05T18:04:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为某些原因想要丢掉原来的GitHub账号还有博客，换身皮囊再继续。</p><p>隔了一天的关系迁移过程有点模糊没什么头绪，我先罗列一下：</p><ol><li>更改本地的GitHub账号</li><li>绑定SSH</li><li>新建一个Repository</li><li>重新部署博客（迁移博客配置文件、迁移博客主题配置文件、安装插件等）</li></ol><p>在我做完 1、2 、3 之后我新建了一个文件夹用于重新生成博客（<code>hexo init</code>），之后尝试进行第 4 步操作。结果大概如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remote: Permission to myNewAccount.git denied to MY_OLD_GITHUB_ACCOUNT</span><br><span class="line">fatal: unable to access &apos;https://github.com/myNewAccount/myNewRepo&apos;: </span><br><span class="line">The requested URL returned error: 403`</span><br></pre></td></tr></table></figure><p>似乎是由于部署博客的过程里往仓库 push 的时候被自动使用了旧账号进行操作，在这之后的2个小时里我不断更新 SSH key 、删掉博客的本地文件再 <code>hexo init</code> 反复折腾，最后发现只需要打开 GitHub Desktop 更新账号，把放博客的新 repo 给 clone 下来就行（重启电脑前不行，重启之后再尝试博客就成功部署上去了）</p><p>部署完不算完，因为我以为每次迁移博客都需要重新 <code>hexo init</code> 所以新博客现在是空的，我原来旧的那些文章都还没放进去，虽然都是食之无味弃之可惜，但是。。。弃之可惜嘛。。。所以我把备份好的 <code>.md</code> 文件直接丢到新博客的 post 文件夹里生成。。。结果又出事了，只有靠前的两三篇文章标题正确显示，剩余的全是“no-title”；这个情况在之前也碰上过，但是由于每次码字都累爆，上传又遇上这种情况就会心烦气躁地 “备份-删除-重新上传、复制-粘贴-重新上传” 地折腾个三四十分钟，问题往往莫名其妙地就能解决。但是这次我怀疑的对象不再是文件本身，我怀疑是 hexo 生成的页面会根据 <code>hexo new &quot;article title&quot;</code> 时生成某个文件、保存文章标题来进行显示。然而事实是我想多了。</p><p>事实上每一次的 <code>hexo new &quot;new article&quot;</code> 生成的 <code>.md</code> 文件里都会自动生成出如下内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: 蛋疼的迁移过程</span><br><span class="line">date: 2019-03-06 01:28:15</span><br><span class="line">tags:</span><br></pre></td></tr></table></figure><p>估计 hexo 生成的页面就是通过这里的 title 获取文章标题进行显示的（我真的很不乐意学HTML之流，我甚至觉得它们比C++还麻烦 :P ），而我在云端备份的文章里都没把这一段内容放进去，所以生成的页面找不到标题就默认给了 no-title 。</p><p>哦对了，想起来一个事儿，在我直接放 <code>.md</code> 文件生成博客之前我看了 hexo 官网的文档，里头提到迁移文章的一个插件“hexo-migrator-rss” ，需要通过<code>npm install hexo-migrator-rss --save</code> 安装之后使用，他可以从RSS迁移所有文章，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo migrate rss &lt;source&gt;</span><br></pre></td></tr></table></figure><p><code>source</code> 可以是文件路径或网址，也就是指向某个“atom.xml”文件就行了，所以我试了一下，结果文章确实都被取回来了，但是都是根据<code>.xml</code>文件的内容生成的，文章内嵌入的图片资源都没能获取到，<strong>原因不明</strong>。似乎很麻烦所以很快就考虑其他解决办法。</p><p>接着我意识到这一切都与是否生成一个新博客不相关的，你要做的只是在博客的配置文件里更改 url、root（可选）、deploy的参数，部署的时候 hexo 只看你的 deploy 参数而已，于是我滚回原来存放博客的文件夹里修改了配置文件，重新部署了一下。。。</p><p>至此迁移工作就完事儿了，挺蛋疼的，30分钟的事情我弄了3个小时，尽管多多少少还是有所收获吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为某些原因想要丢掉原来的GitHub账号还有博客，换身皮囊再继续。&lt;/p&gt;
&lt;p&gt;隔了一天的关系迁移过程有点模糊没什么头绪，我先罗列一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;更改本地的GitHub账号&lt;/li&gt;
&lt;li&gt;绑定SSH&lt;/li&gt;
&lt;li&gt;新建一个Repository&lt;
      
    
    </summary>
    
    
    
      <category term="学习记录" scheme="https://nulllstack.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>作废，迁移</title>
    <link href="https://nulllstack.github.io/2019/03/03/%E4%BD%9C%E5%BA%9F%EF%BC%8C%E8%BF%81%E7%A7%BB/"/>
    <id>https://nulllstack.github.io/2019/03/03/作废，迁移/</id>
    <published>2019-03-02T17:20:21.000Z</published>
    <updated>2019-03-03T18:39:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>从原来的地方搬到这里来了，回头记录一下迁移过程（有点蛋疼），明天还有课已经凌晨两点半了，该睡觉了，晚安:)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从原来的地方搬到这里来了，回头记录一下迁移过程（有点蛋疼），明天还有课已经凌晨两点半了，该睡觉了，晚安:)&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>时隔多日再水一篇</title>
    <link href="https://nulllstack.github.io/2018/09/05/%E6%97%B6%E9%9A%94%E5%A4%9A%E6%97%A5%E5%86%8D%E6%B0%B4%E4%B8%80%E7%AF%87/"/>
    <id>https://nulllstack.github.io/2018/09/05/时隔多日再水一篇/</id>
    <published>2018-09-05T15:18:15.000Z</published>
    <updated>2019-09-12T17:43:05.133Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客本该在几日前写完的，开学前应一老友所需码一篇关于HaxeFlixel开发环境搭建的文章，无奈开学这两天没太适应过来拖延到今晚才开始有心情码字，实际发布时间会晚于tag所标示的时间。</p><p>以下是本次要安装的各种工具：</p><ul><li><a href="#first">Haxe工具集</a><ul><li>Lime</li><li>OpenFL</li><li>Flixel</li><li>Flixel Tools</li></ul></li><li><a href="#second">VisualStudio</a></li><li><a href="#third">VisualStudioCode</a></li></ul><p><a name="first"><h2>安装Haxe工具集与其他依赖项</h2></a></p><p>首先，登陆Haxe的官网<a href="https://haxe.org/download/" target="_blank" rel="noopener">haxe.org</a>下载安装包，安装内容包括一个Haxe的跨平台编译器，一个标准库以及一个命令行工具“haxelib”，它是一个包管理工具，可以用于提交和检索可用的库，目前我只用它来安装一些依赖项而已，下面开始安装其他依赖项。</p><p>打开PowerShell或者CMD，依次执行以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">haxelib install lime</span><br><span class="line">haxelib install openfl</span><br><span class="line">haxelib install flixel</span><br></pre></td></tr></table></figure><p>注意：如果下载过程报错中断显示超时，那么搭个梯子试试或者在命令中加入参数<code>haxelib -notimeout &lt;command&gt;</code>以取消超时。</p><p>Lime是OpenFL用于跨平台编译的一个底层支持，主要用于给不同平台（如Flash，HTML5，C++）提供输入，音频，渲染上下文，网络访问提供统一的底层支持，具体的技术细节我也还没搞懂，所以就不多说了。</p><p>Flixel原本是由<a href="http://www.adamatomic.com/" target="_blank" rel="noopener">Adam “Atomic” Saltsman</a>以ActionScript3.0写就的一套Flash平台的游戏开发框架，由于后来Flash平台日渐衰落，所以喜爱Flixel的人就开始考虑把它移植到其他平台去，正巧Haxe社区已经有人做了Flash整个API的移植版本——也就是OpenFL，于是Flixel就顺其自然的被移植到了Haxe平台上，这样既能做到原来Flash平台做不到的跨平台开发（Adobe在Flash衰落的日子里主动放弃了很多跨平台的支持），同时又能让原来Flash平台上的开发者通过熟悉的API快速上手，投入Haxe平台的怀抱。</p><p>好了，一点点介绍说完了，当以上东西都下完之后再执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haxelib run lime setup flixel</span><br></pre></td></tr></table></figure><p>它会检查你的lime和opemfl是否为最新，以及其他Flixel相关的库（主要是插件，DEMO，UI，模板）。</p><p>如果你跑了以上命令，那么Flixel Tools已经被安装了，但是我们需要启动它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haxelib run flixel-tools setup</span><br></pre></td></tr></table></figure><p>它将会询问你两个问题：</p><p>是否使用命令别名（用于快捷输入，我都是启用的）：y/n</p><p>使用的默认IDE（我们使用VSCode，设置之后通过命令创建模板后将自动通过所选择的编辑器打开）：这里我们选择VisualStudioCode。</p><p>它同样也是一个命令行工具，之后我们新建项目或下载flixel相关的其他库都将通过它来完成。</p><p>到这里先通过几条指令来检查所有东西是不是都安装正确了：</p><p>依次执行以下指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lime</span><br><span class="line">flixel</span><br></pre></td></tr></table></figure><p>如果如下图所示则表明所需要的东西都安装完毕。</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/command.jpg" alt></p></div><p><a name="second"><h2>安装VisualStudio</h2></a></p><p>若想将游戏编译至C++平台上HaxeFlixel似乎只能用MSVC编译器，所以需要安装这个庞大的东西，那么上官网 <a href="https://visualstudio.microsoft.com/" target="_blank" rel="noopener">VisualStudo</a> ，目前推荐安装最新的 Community 2017 版。</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/VS2017.jpg" alt></p></div><p>下载完打开，然后选中如下图所示的勾选项</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/VSInstaller.jpg" alt></p></div><p>但其实我们需要的是VC++的编译器，所以也可以只勾选VC++ 2017 工具</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/VSInstaller2.jpg" alt></p></div><p>安装完直接把VS关掉就行。</p><p><a name="third"><h2>安装VisualStudioCode</h2></a></p><p>我们使用VisualStudioCode（VSCode）作为我们的代码编辑环境，同样登陆<a href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener">VS官网</a>，点击如下图所示下载VSCode：</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/VSCode.jpg" alt></p></div><p>安装完成后打开VSCode打开左侧边栏中的扩展：</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/VSCodeExtension.jpg" alt></p></div><p>如图所示搜索Haxe，选中Haxe Extension Pack并安装，之后再搜索Lime并安装Lime插件：</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/Lime.jpg" alt></p></div><p>完成后重启VSCode。</p><h2>测试项目</h2>至此万事俱备，我们再次打开PowerShell，输入以下指令新建一个HaxeFlixel项目：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flixel tpl &quot;default&quot; -n &quot;HelloWorld&quot;</span><br></pre></td></tr></table></figure><p>这里使用默认模板，并以”HelloWorld”命名在当前目录创建一个新的项目。命令<code>tpl</code>是<code>template</code>的别名，如果在<code>haxelib run flixel-tools setup</code>时启用了别名则可以使用<code>tpl</code>作为缩写快捷输入，default模板在我们执行<code>haxelib run lime setup</code>的时候下载好了，通过它我们可以在使用Flixel命令行工具创建项目时自动生成所需的配置文件，VSCode的配置文件存放于<code>.vscode</code>文件夹下，具体了解看官网文档，同样模板的自定义我自己也没研究过在这里就不讲了，官网资料或者论坛或者StackOverflow或其他什么方式，<strong>自己动手丰衣足食</strong>。</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/Complete.jpg" alt></p></div><p>动手检查一下Haxe插件是不是工作正常，主要是看看代码提示和补全，随便在那一行哪一个位置<code>Ctrl+Space</code>可以激活VSCode的IntelliSense，如果出现没有提示的情况，看看界面左下角是不是显示Building Cache，如果是这样的话参考我的上一篇博文。</p><p>到这里应该没什么问题了，如果我什么时候想起来要补充点什么再回来更新，晚安 :)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客本该在几日前写完的，开学前应一老友所需码一篇关于HaxeFlixel开发环境搭建的文章，无奈开学这两天没太适应过来拖延到今晚才开始有心情码字，实际发布时间会晚于tag所标示的时间。&lt;/p&gt;
&lt;p&gt;以下是本次要安装的各种工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>摸鱼一把</title>
    <link href="https://nulllstack.github.io/2018/08/16/%E6%91%B8%E9%B1%BC%E4%B8%80%E6%8A%8A/"/>
    <id>https://nulllstack.github.io/2018/08/16/摸鱼一把/</id>
    <published>2018-08-16T14:33:13.000Z</published>
    <updated>2018-08-16T14:55:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>解决了VSCode的Haxe插件时不时卡死building cache，导致代码提示功能无法正常工作的问题。</p><p>打开VSCode<code>文件 -&gt; 首选项 -&gt; 设置</code>在右边窗口用户设置内添加:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "haxe.buildCompletionCache" = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以覆盖默认设置，一个不知所云的热修复，问题暂时得到解决。</p><p>再就是搭建了一个Haxe的学习环境，<code>.vscode</code>文件夹下配置文件为：</p><p>task.json:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // See https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">    // for the documentation about the tasks.json format</span><br><span class="line">    "version": "2.0.0",</span><br><span class="line">    "tasks": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"compile"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"haxe"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"-main"</span>, <span class="string">"Main"</span>, <span class="string">"-cpp"</span>, <span class="string">"output"</span>, <span class="string">"-debug"</span>, <span class="string">"-lib"</span>, <span class="string">"hxcpp-debug-server"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"promptOnClose"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>launch.json:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    "version": "0.2.0",</span><br><span class="line">    "configurations": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"preLaunchTask"</span>: <span class="string">"compile"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Hxcpp"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"hxcpp"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceRoot&#125;/output/Main-debug.exe"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，博客的关于页上分享了我的邮箱地址，有兴趣交流的朋友可以通过邮箱地址联系我，其实只是想知道到底有多少人在看 = =</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解决了VSCode的Haxe插件时不时卡死building cache，导致代码提示功能无法正常工作的问题。&lt;/p&gt;
&lt;p&gt;打开VSCode&lt;code&gt;文件 -&amp;gt; 首选项 -&amp;gt; 设置&lt;/code&gt;在右边窗口用户设置内添加:&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
    
      <category term="学习记录" scheme="https://nulllstack.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程8:拾取物品</title>
    <link href="https://nulllstack.github.io/2018/08/05/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B8-%E6%8B%BE%E5%8F%96%E7%89%A9%E5%93%81/"/>
    <id>https://nulllstack.github.io/2018/08/05/HaxeFlixel官方教程8-拾取物品/</id>
    <published>2018-08-04T17:22:54.000Z</published>
    <updated>2019-09-12T17:52:57.679Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/pickups/" target="_blank" rel="noopener">原文</a></p><p>目前我们有一个小家伙可以在地图内自由行走，让我们为它添加一些可以拾取的东西。我们将要添加一些硬币，当玩家拾起的时候会计入分数。</p><ol><li><p>再一次打开你的Ogmo项目，然后打开<code>Project &gt; Edit Project</code>选项卡。</p></li><li><p>在‘Entities’选项卡内添加一个新的实体。</p></li></ol><div align="center"><p><img src="//nulllstack.github.io/2018/08/05/HaxeFlixel官方教程8-拾取物品/0014.png" alt></p></div><ol start="3"><li>选中 ‘entities’ 图层，在地图中散布一些硬币：</li></ol><div align="center"><p><img src="//nulllstack.github.io/2018/08/05/HaxeFlixel官方教程8-拾取物品/0015.png" alt></p></div><ol start="4"><li><p>我们将使用8x8像素作为硬币的大小，硬币的图像资源你可以使用这个<img src="//nulllstack.github.io/2018/08/05/HaxeFlixel官方教程8-拾取物品/coin.png" alt>,或者是你自己画一个，然后保存至<code>assets/images</code>文件夹下。</p></li><li><p>回到VSCode，新建一个新的类：</p></li></ol><div align="center"><p><img src="//nulllstack.github.io/2018/08/05/HaxeFlixel官方教程8-拾取物品/VSCode1.png" alt></p></div><div align="center"><p><img src="//nulllstack.github.io/2018/08/05/HaxeFlixel官方教程8-拾取物品/VSCode2.png" alt></p></div>6. Coin类十分简单，我们只需要修改一下构造函数：   <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>;</span><br><span class="line"><span class="keyword">import</span> flixel.FlxSprite;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coin</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">FlxSprite</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(X:<span class="type">Float</span>,Y:<span class="type">Float</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(X,Y);</span><br><span class="line">        loadGraphic(AssetPaths.coin__png,<span class="literal">false</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><p>现在回到<code>PlayState</code>类中，我们需要修改一下地图加载的逻辑代码，让它从Ogmo文件中加载实体时如果发现coin将会把<code>Coin</code>对象加入当前状态（state）。</p></li><li><p>首先让我们创建一个<code>FlxGroup</code>对象用于存储所有的硬币，在类中定义所有全局变量的地方添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _grpCoins:<span class="type">FlxTypedGroup</span>&lt;Coin&gt;</span><br></pre></td></tr></table></figure><p><code>FlxGroup</code>类似一个存储Flixel对象（Flixel Object）的数组，以供在许多需要的情况下使用，在这里我们用它来存储所有的硬币所以以<code>FlxTypedGroup&lt;Coin&gt;</code>形式声明。</p><p>在<code>create()</code>函数中位于初始化player之前，添加墙体之后的位置，我们从这里初始化硬币组（coin group）并将其添加至当前状态：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_grpCoins = <span class="keyword">new</span> <span class="type">FlxTypedGroup</span>&lt;Coin&gt;();</span><br><span class="line">add(_grpCoins);</span><br></pre></td></tr></table></figure></li><li><p>接下来我们需要修改<code>placeEntities()</code>函数，让其从Ogmo文件中读取到”coin“实体时将其添加进组中，位于我们的if语句的末尾添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(entityName == <span class="string">"coin"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _grpCoins.add(<span class="keyword">new</span> <span class="type">Coin</span>(x+<span class="number">4</span>,y+<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做将告诉程序创建一个coin对象，将其放置于Ogmo文件中所定义的位置（对其<code>x</code>值+4，<code>y</code>值+4，使得硬币位于瓦砖的居中位置），之后将这个coin对象添加进组。</p></li><li><p>现在我们需要player能够拾取这些硬币，我们将通过检查重叠情况（overlap）的方式来实现，在<code>update()</code>函数中位于<code>FlxG.collide()</code>调用之后的位置添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlxG.overlap(_player,_grpCoins,playerTouchCoin);</span><br></pre></td></tr></table></figure><p>这么做是告诉程序：在每一帧检查player与硬币组之间的重叠情况，如果发生重叠，则调用<code>playerTouchCoin()</code>函数。</p></li><li><p>现在我们来实现<code>playerTouchCoin()</code>回调函数：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playerTouchCoin</span></span>(P:<span class="type">Player</span>,C:<span class="type">Coin</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(P.alive &amp;&amp; P.exists &amp;&amp; C.alive &amp;&amp; C.exists)</span><br><span class="line">    &#123;</span><br><span class="line">        C.kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数检查player与硬币之间是否发生重叠且两者之间的alive与exists属性皆为true，如果是，则对硬币调用<code>kill()</code>函数（我们稍后会添加计分功能）。</p><p>如果你现在运行游戏，当你在地图内行走时触碰到的硬币将会消失。很好，但是有点无趣，让我们为其添加一点小样式。</p></li><li><p>回到<code>Coin</code>类中添加以下几个函数：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">kill</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    alive = <span class="literal">false</span>;</span><br><span class="line">    FlxTween.tween(<span class="built_in">this</span>,&#123;alpha: <span class="type">0</span>, y: <span class="type">y - 16</span>&#125;,<span class="number">.33</span>,&#123;ease: <span class="type">FlxEase</span>.circOut, onComplete: <span class="type">finishKill</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishKill</span></span>(<span class="literal">_</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    exists = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><p>目前为止遇到一些Haxe语法上的问题待解决暂时先翻译到这里，我先去看看Haxe官方的文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/pickups/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前我们有一个小家伙可以在地图内自由行走，让我们为它添加一些可以拾取的东西
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程7:摄像机与缩放</title>
    <link href="https://nulllstack.github.io/2018/08/02/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B7-%E6%91%84%E5%83%8F%E6%9C%BA%E4%B8%8E%E7%BC%A9%E6%94%BE/"/>
    <id>https://nulllstack.github.io/2018/08/02/HaxeFlixel官方教程7-摄像机与缩放/</id>
    <published>2018-08-02T09:33:46.000Z</published>
    <updated>2019-09-12T17:43:48.224Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/zoom-and-cameras/" target="_blank" rel="noopener">原文</a></p><p>当你开始运行你的游戏，你将会看到，目前场景内的所有东西看起开都非常非常小，我们将要通过设置缩放来改变游戏内物体的能见度，以此让玩家得以看清角色每个细微的动作。要做到缩放很简单：</p><ol><li><p>打开<code>Main.hx</code>文件，这个类用于游戏的初始化工作，如果你想要的话看看有哪些东西你需要修改的，但这里我们只需要改变其中的几个参数。</p></li><li><p>修改<code>new FlxGame()</code>的宽度与高度参数为<code>320</code>与<code>240</code>（原来的值的一半）。</p></li><li><p>如果你现在开始运行游戏，你将看到所有东西都被放大了，但是player会越出屏幕的可视范围，因此我们需要告诉摄像机紧跟player的当前位置，再一次打开<code>PlayState</code>文件。</p></li><li><p>在构造函数内，位于添加player之后，<code>super.create()</code>之前的位置添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlxG.camera.follow(_player,TOPDOWN,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这样做将会告诉摄像机以<code>TOPDOWN</code>视角跟踪player的位置，以1为取值赋给<code>lerp</code>参数（这样做将会让摄像机的移动更为平滑一些）</p></li></ol><p>完事了！测试游戏的运行结果看看效果如何。</p><div align="center"><p><img src="//nulllstack.github.io/2018/08/02/HaxeFlixel官方教程7-摄像机与缩放/results.png" alt></p><p>下一节，让我们为player添加一些可以在地图内拾起的东西。</p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/zoom-and-cameras/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当你开始运行你的游戏，你将会看到，目前场景内的所有东西看
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
</feed>
