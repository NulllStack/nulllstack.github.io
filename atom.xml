<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>囿</title>
  
  <subtitle>A 21st century single-player.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nulllstack.github.io/"/>
  <updated>2019-12-29T19:04:09.092Z</updated>
  <id>https://nulllstack.github.io/</id>
  
  <author>
    <name>John</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>openFrameworks Philosophy</title>
    <link href="https://nulllstack.github.io/2019/12/30/openFrameworks-Philosophy/"/>
    <id>https://nulllstack.github.io/2019/12/30/openFrameworks-Philosophy/</id>
    <published>2019-12-29T18:59:30.000Z</published>
    <updated>2019-12-29T19:04:09.092Z</updated>
    
    <content type="html"><![CDATA[<p>po 完上一篇博客之后发现那个垃圾排版与Typora编辑时呈现的排版完全不一致，恶心到我了，甚至开始考虑是否继续使用博客，反正主要是给自己看的，何必如此折腾煞费苦心 :(</p><hr><p>openFrameworks 的发展尝试遵循以下几个目标：它应该是合作性（Collaborative）的，简单易用的，连贯且直观的，跨平台的，强大且可扩展的。以上目标也由 “与人协作” （”do it with others – DIWO”）的哲学观所驱动。</p><hr><h3 id="合作性（Collaborative）"><a href="#合作性（Collaborative）" class="headerlink" title="合作性（Collaborative）"></a>合作性（Collaborative）</h3><p>openFrameworks 的开发是协作完成的，它的蓬勃发展得益于许多经常参与讨论、在插件与项目中完成协作的人的贡献。我们鼓励大家使用oF并为社区的生态环境做出贡献。</p><p>我们使用了分布式版本控制系统 “git”，这意味着大家可以提出建议，为项目添加新的 branch、做一些实验性的扩展；如果你看过 <a href="https://github.com/openframeworks/openFrameworks" target="_blank" rel="noopener">GitHub</a> 上的网络图（network diagram）便不难发现它呈现出一种奇怪的图示，四处编织着新的分支，某个部分的代码被拆分后又在另一头重组。整个社区遍布全球各地，共同维护着oF的核心代码：他们修补BUG，提交新请求以及构建他们所需的新的工具，这是一个 全球性的项目，如果你在美国一觉醒来并开始查看电子邮件，发现邮箱里充满着来自亚洲与欧洲的程序员提交的新的需求或者 issue 是很常见的事情。有超过70人为核心代码做出直接的贡献，还有数百人以fork或其他形式为社区做出贡献。</p><h3 id="简单性（Simplicity）"><a href="#简单性（Simplicity）" class="headerlink" title="简单性（Simplicity）"></a>简单性（Simplicity）</h3><p>openFrameworks尝试在<strong>有用（usability）</strong>与 <strong>简单（Simplicity）</strong>之间寻找平衡，最早期的oF核心库被用于教授C++与<a href="https://en.wikipedia.org/wiki/OpenGL" target="_blank" rel="noopener">OpenGL</a>，后由时间的推移其核心库的例程随着更多高级功能的加入变为了最适合学习的途径，因此我们随着oF的发布创建了更多的例程，为实验提供更多简单、易于拆解的学习起点。</p><p>我们希望oF可以尽可能的简单，特别是为那些从其他语言或开发环境入坑的朋友，C++是一门“庞杂”的语言，它的庞杂还意味着每个人使用C++编写的规范可以很不一样。如果你去书店你会发现C++相关的书可以有数百本之多。我们希望创建一个你只需要一两本书来入门而不需要成为一名专家就能够使用的代码库，其代码规范、编程模式及编程范式（the patterns, approaches and style of the code）是简单且直观的。我们刻意在某种程度上与<a href="http://www.processing.org/" target="_blank" rel="noopener">Processing</a>对齐，两者的某些函数都是相似的，为的是能够让大家在两个框架间的使用能够更自然的过渡。</p><h3 id="连贯且直观（Consistent-and-Intuitive）"><a href="#连贯且直观（Consistent-and-Intuitive）" class="headerlink" title="连贯且直观（Consistent and Intuitive）"></a>连贯且直观（Consistent and Intuitive）</h3><p>openFrameworks是连贯且直观的：它运转于一些常规（least surprise）的原则之上，所以你从oF中的所学也可以在其他领域有所用。初学者可以从oF中学习到常见的编程模式（programming patterns）而高级用户在其他语言或工具集中所学的知识也在oF中也有用武之地。</p><p>oF的箴言是“学生排在第一位”，许多关于oF的发展的指导方针是基于 “在5或10年以前我会喜欢什么样的工具” 这样的思考的。我们希望代码的模式（pattern）尽可能简单地易于输入。这意味着有如在视频播放器中使用“play”与“stop”命名的具“自我阐释性（self-exlanatory)” 的函数命名法以及类似的变量的命名法会更直观。我们就直观方面有过许多讨论，都是为了让代码尽可能的简洁明了，使得你可以在输入代码的过程中，在自动补全的帮助下也能够学习oF。</p><h3 id="跨平台（Cross-platfiorm）"><a href="#跨平台（Cross-platfiorm）" class="headerlink" title="跨平台（Cross-platfiorm）"></a>跨平台（Cross-platfiorm）</h3><p>openFrameworks是一个跨平台的工具包，它尽可能多的支持各种开发环境与操作系统，当你下载好oF之后你可以选择你需要的开发环境与目标平台进行开发，oF已经包含了相关的项目与例程供学习与使用。难以移植（Difficult-to-port）的部分代码被提供于插件（addons）中而不是核心代码中。</p><p>oF被设计为可工作于多个平台：OSX，Windows，Linux， iOS，Android，嵌入式ARM Linux系统，以及如BlackBerry和PlayBook这样的处于实验性阶段的平台。openFrameworks的开发人员已经想出了一些聪明的方法使得oF可以访问其他语言的接口如Android平台下的Java以及iOS平台下的Ojective-C。</p><p>跨平台库的一个喜闻乐见的点在于你可以将你的想法从一个平台导出至另一个平台，你可以在笔记本上迭代原型并快速地在你的手机上检验运行结果。它使得你的想法能够先落地而不需要担心冗余的跨平台工作。</p><h3 id="功能强大的（Powerful）"><a href="#功能强大的（Powerful）" class="headerlink" title="功能强大的（Powerful）"></a>功能强大的（Powerful）</h3><p>openFrameworks功能强大，它使你能够借助如<a href="http://opencv.org/" target="_blank" rel="noopener">OpenCV</a>之类的高级库，访问你的硬件如显卡进行加速，或者连接摄像头之类的外设。</p><p>我们选择使用C++编写oF是因为它是一门足够“低级”的语言同时又可以以现代高级语言的方式进行编程。由于它可以认为是C语言的扩展，所以它可以编写一些很底层的东西，可以以老式C语言的方式编写，也可以以现代C++的形式编写。我们试图在oF中以简单、清晰、但功能强大的形式接纳这两种编程方法。同时，使用C++也使得我们能够直接访问许多已由C或C++编写的库的接口而不需要依赖其他语言的包装器（wrapper）。</p><p>openFrameworks本质上包装（wrap）了其他库如：OpenGL、<a href="http://cairographics.org/" target="_blank" rel="noopener">Cairo</a>、<a href="http://freetype.org/" target="_blank" rel="noopener">FreeType</a>、<a href="http://freeimage.sourceforge.net/" target="_blank" rel="noopener">FreeImage</a>、以及OpenCV，你可以把oF设想为一层介于用户代码（由你编写的代码）与这些库之间的代码层。由于不同库的使用上，编程方法与风格各不相同所以我们把各个库进行了统一的包装并提供一个更为连贯且直观的形式。</p><h3 id="可扩展的（Extensible）"><a href="#可扩展的（Extensible）" class="headerlink" title="可扩展的（Extensible）"></a>可扩展的（Extensible）</h3><p>openFrameworks是可扩展的。如果你发现它缺少某些你需要的东西你可以简单地通过创建一个插件来扩展它。oF的核心插件通常包装了其他的库而不是直接以加入新功能的形式来解决问题。当oF包装了新的库的同时这些库也为进一步的扩展提供了新的途径。</p><p>oF的愿景是成为你开发过程中的一个可靠的臂膀或脚手架。能够使得oF的核心库更轻量化的一点是避免尽可能多的往里纳入所有新的东西，取而代之的是oF有一个插件体系允许用户之间共享额外的代码，库以及方法使得在必要时可以将其 “编织” 进项目里。</p><p>oF的插件可以是一段代码片段，或是更为复杂的库如OpenNI、Tesseract或Box2d的一个封装。插件名字的前缀通常是“ofx”，为的是可以使你方便的区分oF的核心与非核心代码，另外，我们为oF纳入了“核心插件（core addons）”，这些插件是我们认为大家通常会需要但并不是每一个项目都会需要用到的插件比如 ofxOpenCv 插件。</p><p>我们试图通过 <a href="http://ofxaddons.com" target="_blank" rel="noopener">http://ofxaddons.com</a> 网站组织与支持社区开发插件，该网站通过自动检索Github中标题包含 “ofx” 一词的仓库（repos）收集插件目录，目前已有超过1500个插件收录在册。</p><h3 id="与他人协作（Do-it-with-others-–-DIWO）"><a href="#与他人协作（Do-it-with-others-–-DIWO）" class="headerlink" title="与他人协作（Do it with others – DIWO）"></a>与他人协作（Do it with others – DIWO）</h3><p>这个部分有点懒得翻了，大概就是鼓励大家多合作多分享，共同探索 creative coding 的乐趣。（完 :D）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;po 完上一篇博客之后发现那个垃圾排版与Typora编辑时呈现的排版完全不一致，恶心到我了，甚至开始考虑是否继续使用博客，反正主要是给自己看的，何必如此折腾煞费苦心 :(&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;openFrameworks 的发展尝试遵循以下几个目标：它应该是合作性（Co
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>我又准备开坑了</title>
    <link href="https://nulllstack.github.io/2019/12/30/%E6%88%91%E5%8F%88%E5%87%86%E5%A4%87%E5%BC%80%E5%9D%91%E4%BA%86/"/>
    <id>https://nulllstack.github.io/2019/12/30/我又准备开坑了/</id>
    <published>2019-12-29T16:46:45.000Z</published>
    <updated>2019-12-29T18:56:36.388Z</updated>
    
    <content type="html"><![CDATA[<p>​    又准备开新坑了，由于目前处于死磕C/C++的状态，天性使然想让学习过程变得不那么枯燥一点，选择了创意编程框架openFrameworks作为学习与练习过程中适当的调剂手段，由于过去断断续续玩过一阵子Processing，开坑后往坑底坠落的过程应该不至于过分崎岖（至少离洞口不远处的岩壁空间会大一些吧 = =）最坏的情况也不至于撞死在悬臂上，至于算法，可以想象我目前拿着一把石镐准备去开采钻石，暂且不提钻石能不能挖到，效率固然是很低的。实话讲我还是很反感身边有条件接受良好教育的人对我讲，“算法学习的自学与有良师指导之间的<strong>效率</strong>没差” 以及 “如果你真的想，没有什么<strong>客观障碍</strong>存在” 的这种说法，不管我如何想象这都属于 “站着说话不腰疼” 或是 “自欺欺人” 的范畴；说得更难听一点，一名身披全副武装的现代战士与一名战国武士对决全胜的情况下，还要求武士不可以认为这是冷热兵器差距悬殊的结果；<strong>这种事情难免使人联想到人性那恶臭的一面</strong>。咳咳，请你们不要有多余的想象，这仅仅是一个夸张且不够贴切的比喻，仅此而已，实在不行的话，得罪就得罪吧 ;)  总之以后再碰上类似的言论我就权当影响心情的狗屁，敬而远之（ni ge sha bi wan yi）好了。</p><p>​    哦对了还有，还有些人不学无术却<strong>特爱</strong>扣学术名词或概念出来添油加醋地附加自己无端的想象，麻烦你们，do not bullshit anymore, and show me your code :) 。做个人，别做根搅屎棍。</p><p>​    总而言之，我准备开新坑了。如开篇所言，目前我还处于C/C++环境的摸爬滚打阶段，不得不说的是，C/C++是一门 “庞杂” 的语言，为何我会选择使用 “C/C++” 而不是 “C” 或 “C++” 来指代这门语言也是出于其“庞杂”的谨慎考虑，让我试着引用《C++ Primer Plus》中 1.1节 的一段介绍来尝试解释其中的原因：</p><blockquote><p>​    C++ 融合了 3 种不同的编程方式： C 语言代表的过程性语言、 C++ 在 C 语言基础上添加的类代表的面向对象语言、C++ 模板支持的泛型编程。</p><p>（略…）所以， 如果已经对 C 有所了解， 便可以学习 C++ 了， 但这并不仅仅是学习更多的关键字和结构， 从 C 过渡到 C++ 的学习量就像从头学习 C 语言一样大。 另外， 如果先掌握 了 C 语言， 则在过渡到 C++ 时， 必须摈弃一些编程习惯。 如果不了解 C 语言， 则学习 C++ 时需要掌握 C 语言的知识、OOP 知识以及泛型编程知识，但无需摈弃任何编程习惯。</p><p>Stephen Prata. C++ Primer Plus（第6版）中文版（异步图书） (C和C++实务精选) (Kindle 位置 680-683). 人民邮电出版社. Kindle 版本. </p></blockquote><p>我不想在这篇博客中具体到某一个技术细节上讨论C与C++之间的关系，但从上面的引述中我们已经可以了解到C与C++之间有着密不可分的联系，书中对C++的描述为C的 “超集” ，然而实际上现代C++规范中已经明确了现代C++不仅不是C的超集，而且C++从一开始就不是C的超集，他们之间应该属于交集关系，从原则上来看如引用中所描述的 “如果先掌握 了 C 语言， 则在过渡到 C++ 时， 必须摈弃一些编程习惯” 中已经可以看出些许端倪，实际上C++出于一些兼容性考虑，大部分从C继承下来的特性都被得以永久保留，但如果你是希望以现代C++的形式进行编写的话这些特性是不被推荐使用的。</p><img src="//nulllstack.github.io/2019/12/30/我又准备开坑了/1.png" style="zoom: 50%;"><p>如上图所示，C++规范中已经明确指出 “字符串字面值不允许被赋值到一个 <code>char *</code> 类型变量上，取而代之的应该是 <code>const char *</code> 类型或 <code>auto</code>”，但是编译器只会抛出一个警告，这个代码片段依然可以被编译并运行。</p><p>​    我并不是想表明某种 “原教旨主义” 的态度，毕竟目前而言C/C++风格混用的代码遍地都是，提倡严格遵守标准进行编写的人也不在少数，更何况我还是在 “摸爬滚打” 。而是说我看到过太多武断地或人云亦云的讨论，甚至还有许多像是急于 “宣示主权” 表明自己身为码农的身份一般的人存在，对于这种，我就很想对兄弟说一句，“如果你是来自我物化的，那还请做个人吧，别再做根搅屎棍了 :) ”；对于我们不了解的东西我们就闭嘴学习，好吗。</p><p>​    我也不是说我们不可以对数字世界发挥想象，当我们伸手指向月亮的时候，我们是出于某种动机指代月亮，但如果有人把指向月亮的手指当作月亮本身，那无疑是一种愚蠢的行为。</p><p>​    我原本还想 “bitching” 一下论坛文化的丧失，但是写到这里我发现已经离我写这篇博客的初衷太远了，原本 “bitching” 的部分并不在我写这篇博客的考虑范围内，那么我就贴上几张 Discord 上保留的截图（来自Haxe社区的一段讨论），来尝试 “解释” 我所认为的讨论应该是什么样子吧：</p><img src="//nulllstack.github.io/2019/12/30/我又准备开坑了/2.png" style="zoom: 60%;"><img src="//nulllstack.github.io/2019/12/30/我又准备开坑了/3.png" style="zoom: 60%;"><img src="//nulllstack.github.io/2019/12/30/我又准备开坑了/4.png" style="zoom: 60%;"><p>最后还是让我们回归正题，我究竟开了个什么坑。</p><p>​    由于我不够安分，学点什么就习惯于另辟蹊径给自己找快乐，但面对C/C++的 “庞杂” 寸步难移，一时间能给我折腾的好玩简单易上手的库近乎没有选择，最后把目光锁定在了 openFrameworks 框架上。姑且就先引用一段来自官网的介绍吧——“openFrameworks 是一个为创意编程而设的 C++ 开源工具集”，更为具体的介绍日后再另外讲述吧，写累了。依然采用学习+整理+post 的形式来分享与自我回顾。另外这样篇幅的 bitching 以后还是不写了，忽然感觉毫无意义。</p><p>就这样吧，晚安。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    又准备开新坑了，由于目前处于死磕C/C++的状态，天性使然想让学习过程变得不那么枯燥一点，选择了创意编程框架openFrameworks作为学习与练习过程中适当的调剂手段，由于过去断断续续玩过一阵子Processing，开坑后往坑底坠落的过程应该不至于过分崎岖（至
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程12:音效与音乐</title>
    <link href="https://nulllstack.github.io/2019/04/05/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B12-%E9%9F%B3%E6%95%88%E4%B8%8E%E9%9F%B3%E4%B9%90/"/>
    <id>https://nulllstack.github.io/2019/04/05/HaxeFlixel官方教程12-音效与音乐/</id>
    <published>2019-04-04T18:22:05.000Z</published>
    <updated>2019-04-04T18:29:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>打算一次翻译完剩下的部分之后去弄点别的事情，HaxeFlixel相关的东西很闲的时候再回来整理。</p><p><a href="http://haxeflixel.com/documentation/sound-and-music/" target="_blank" rel="noopener">原文</a></p><p>目前我们为游戏所做的各个部分已经整合起来了，不过它还缺少一点东西…它还没有声音。</p><p>我们依然保持这个游戏简单化。我们将使用一个可循环的单音轨音频文件用于游戏运行时循环播放。我们也会为各种不同的动作添加一些简单的音效。在 HaxeFlixel 中播放音频文件是十分简单的事情。</p><p>首先，你需要创建一段音乐还有其他音效。来自 <a href="http://fatbard.tumblr.com/" target="_blank" rel="noopener">FatBard</a> 的 Patrick Crecelius 为本教程提供了<a href="https://raw.githubusercontent.com/HaxeFlixel/flixel-demos/master/Tutorials/TurnBasedRPG/assets/music/HaxeFlixel_Tutorial_Game.mp3" target="_blank" rel="noopener">一段音乐</a>（建议在直接上<a href="https://github.com/HaxeFlixel/flixel-demos/tree/dev/Tutorials/TurnBasedRPG" target="_blank" rel="noopener">GitHub</a>从<code>asstes/music</code>文件夹内下载），你可以随意使用，或者可以自己做。</p><p>我们还使用了 <a href="https://www.bfxr.net/" target="_blank" rel="noopener">Bfxr</a> 制作了一些音效，如果你喜欢的话可以使用这些音效文件或者自己做一套。</p><p>如果你一步步跟着教程走下来的话那么在 “UI与战斗系统” 一节中你已经下载过这些音效文件了。以下列出这些文件确保你确实完整下载了这些文件：</p><ul><li>coin.wav - 用于玩家拾起硬币时使用的音效</li><li>combat.wav - 战斗开始时使用的音效</li><li>fled.wav - 当玩家成功逃离战斗时使用的音效</li><li>hurt.wav - 玩家或敌人击中对方时使用的音效</li><li>lose.wav - 玩家于战斗中死亡时使用的音效</li><li>miss.wav - 玩家或敌人攻击miss时使用的音效</li><li>select.wav - 用于按钮以及玩家于选项栏进行选择时使用的音效</li><li>step.wav - 用于玩家以及敌人的脚步声的音效</li><li>win.wav - 当玩家于战斗中获胜时使用的音效</li></ul><p>音效文件链接：<a href="https://github.com/HaxeFlixel/flixel-demos/tree/dev/Tutorials/TurnBasedRPG/assets/sounds" target="_blank" rel="noopener">GitHub</a></p><p>当你准备完这些声音文件之后把<strong>音乐</strong>文件放置于<code>assets/music</code>文件夹下，把<strong>音效</strong>文件放置于<code>asstes/sounds</code>文件夹下。</p><p>现在让我们修改代码来使用这些声音文件：</p><ol><li><p>首先打开<code>MenuState.hx</code>文件，由于我们需要让音乐从游戏启动那一刻开始并不管如何都不停循环，所以我们要从<code>create()</code>内添加它。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(FlxG.sound.music == <span class="literal">null</span>) <span class="comment">//如果音乐已经在播放了则不重放音乐</span></span><br><span class="line">&#123;</span><br><span class="line">    FlxG.sound.playMusic(AssetPaths.HaxeFlixel_Tutorial_Game__mp3, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们同时还检查了音乐是否已经处于播放（比如玩家从<code>GameOver</code>状态切换至<code>MenuState</code>的时候音乐其实已经是在播放了），我们不希望在这个时候做不必要的重放。</p><p>现在编译启动游戏之后它应该可以播放音乐了。</p></li><li><p>接下来我们需要让按钮被点击的时候播放一段音效。很简单，我们只需要告诉按钮的<code>onUP</code>属性（注）加载一段声音。在<code>MenuState</code>的<code>create()</code>函数中，开始按钮的初始化之后的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_btnPlay.onUp.sound = FlxG.sound.load(AssetPaths.select__wav);</span><br></pre></td></tr></table></figure></li><li><p>现在你可以对选项按钮做同样的事情（将以上代码的<code>_btnPlay</code>替换为<code>_btnOptions</code>）。</p><p>对于游戏中剩下的每一个按钮 - 位于<code>OptionsState</code>状态中的四个，以及位于<code>GameOver</code>状态中的那一个；它们的代码已经写好了，但作为课后练习你可以去这两个文件中看看是如何实现的。</p><p><em>注：不知道什么原因，<code>FlxButton</code>的<code>onUp</code>等属性在官方API文档中是没有被列出来的，但是源码中能找到，还带注释，它们的类型为<code>FlxButtonEvent</code>，是<code>FlxButton</code><a href="https://www.kancloud.cn/simon_chang/haxe3manual/183601" target="_blank" rel="noopener">模块</a>中的私有类，该类为<code>FlxButton</code>的辅助类用于<code>FlxButton</code>的事件处理。两个类型的关系可参考：<a href="https://www.kancloud.cn/simon_chang/haxe3manual/186343" target="_blank" rel="noopener">模块子类型</a>。这里记上一笔日后回来整理需要注意一下。</em></p></li><li><p>下一步让我们为玩家添加脚步声，我们不想要每次需要播放同一个声音的时候都创建与销毁一个新的声音对象（sound object），所以我们要创建一个<code>FlxSound</code>对象以便复用。在<code>Player</code>类体的顶部添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _sndStep:<span class="type">FlxSound</span>;</span><br></pre></td></tr></table></figure></li><li><p>然后我们需要在构造函数的某处加载脚步声文件。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndStep = FlxG.sound.load(AssetPaths.step__wav);</span><br></pre></td></tr></table></figure></li><li><p>接着跳到<code>movement()</code>函数中，在检查玩家是否处于移动的条件语句（<code>if((velocity.x != 0 || velocity.y != 0) &amp;&amp; touching == FlxObject.NONE)</code>）中第一行位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndStep.play();</span><br></pre></td></tr></table></figure><p><code>FlxSound</code>有一个灵活的小特性，如果你告诉它播放一个声音而它已经在播放了（并且你没有设置<code>forceRestart</code>flag为真）那么它不会再次播放。这意味着我们可以轻易地在玩家移动时按每一帧进行调用以播放声音，而且声音听起来就像是在不断循环。但当玩家不再移动时停止声音的播放，并处于静止状态时声音不会重放。</p></li><li><p>现在我们也为敌人创建脚步声，与上面不同的是我们现在不是一直以满格的音量重复播放脚步声，而是基于敌人与玩家间的距离来改变音量的高低，实际上实现起来比听起来简单得多，首先我们在<code>Enemy</code>类体的顶部添加一个变量：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _sndStep:<span class="type">FlxSound</span>;</span><br></pre></td></tr></table></figure></li><li><p>接着与对<code>Player</code>类的设置一样，添加以下代码到构造函数中：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_sndStep = FlxG.sound.load(AssetPaths.step__wav, <span class="number">.4</span>);</span><br><span class="line">_sndStep.proximity(x, y, FlxG.camera.target, FlxG.width * <span class="number">.6</span>);</span><br></pre></td></tr></table></figure><p>你可能注意到了我们把声音设为<code>.4</code>（40%），这是由于地图中将会有多个敌人存在，而他们的脚步声可能会很吵闹（另外，怪物有可能是光着脚不穿鞋的，不是吗？）</p></li><li><p>加载所有文件之后我们为声音设置了邻近跟踪，传入了该敌人的<code>x</code>与<code>y</code>坐标并告诉它追踪的目标为<code>FlxG.camera.target</code>对象（也就是我们的玩家）。最后我们告诉它声音的传播半径稍微比屏幕一半宽度多一点点，这样我们就能够听到稍微越出屏幕的敌人的声音。如此一来我们就能够听到 基于敌人与摄像机目标之间的距离 计算出的或大或小的脚步声了。</p></li><li><p>接下来我们要在敌人的<code>update()</code>函数中，位于<code>super.update()</code>调用之后的位置检查敌人是否处于移动状态，并且没有撞到墙上去。如果他们处于移动状态，我们将把脚步声放到这个敌人所处的位置上（放置于其精灵（sprite）的底部，也就是它的脚上），之后开始播放脚步声。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((velocity.x != <span class="number">0</span> || velocity.y != <span class="number">0</span>) &amp;&amp; toucing == FlxObject.NONE)</span><br><span class="line">&#123;</span><br><span class="line">    _sndStep.setPosition(x + frameWidth / <span class="number">2</span>, y + height);</span><br><span class="line">    _sndStep.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来我们跳到<code>PlayState</code>中，在<code>PlayState</code>中我们只需要一个声音文件，用于拾起硬币的时候播放，尽管你可以把它放到<code>Coin</code>类中，但是由于有可能一次会载入多枚硬币，并且我们实际上一次只能捡一枚硬币（所以音效不需要重叠（overlap）），把一个单独的硬币音效加载进<code>PlayState</code>可以为我们的性能节省一些开销。</p><p>就像添加其他音效一样，初始化变量：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _sndCoin:<span class="type">FlxSound</span>;</span><br></pre></td></tr></table></figure><p>在<code>create()</code>中加载音效：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndCoin = FlxG.sound.load(AssetPaths.coin__wav);</span><br></pre></td></tr></table></figure><p>之后在<code>playerTouchCoin()</code>函数中，在<code>if</code>语句里添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndCoin.play(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>这一次我们将使用<code>forceRestart</code>，这样当玩家拾起紧挨在一起的多枚硬币的时候新触发的声音会紧接而上。</p></li><li><p>剩下的音效由于都用于战斗阶段，所以会被放到<code>CombatHUD</code>类里面。</p><p>假设你已经下载了<code>CombatHUD</code>类文件，那么这些音效的相关代码就已经在里面写好了，不过作为一种课后练习，去完整浏览一遍也是个好主意，这样做有助于你在下一个项目中更好的理解声音的工作方式。</p><p>初始化变量：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _sndFled:<span class="type">FlxSound</span>;</span><br><span class="line"><span class="keyword">var</span> _sndHurt:<span class="type">FlxSound</span>;</span><br><span class="line"><span class="keyword">var</span> _sndLose:<span class="type">FlxSound</span>;</span><br><span class="line"><span class="keyword">var</span> _sndMiss:<span class="type">FlxSound</span>;</span><br><span class="line"><span class="keyword">var</span> _sndSelect:<span class="type">FlxSound</span>;</span><br><span class="line"><span class="keyword">var</span> _sndWin:<span class="type">FlxSound</span>;</span><br><span class="line"><span class="keyword">var</span> _sndCombat:<span class="type">FlxSound</span>;</span><br></pre></td></tr></table></figure><p>加载音效：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_sndFled = FlxG.sound.load(AssetPaths.fled__wav);</span><br><span class="line">_sndHurt = FlxG.sound.load(AssetPaths.hurt__wav);</span><br><span class="line">_sndLose = FlxG.sound.load(AssetPaths.lose__wav);</span><br><span class="line">_sndMiss = FlxG.sound.load(AssetPaths.miss__wav);</span><br><span class="line">_sndSelect = FlxG.sound.load(AssetPaths.select__wav);</span><br><span class="line">_sndWin = FlxG.sound.load(AssetPaths.win__wav);</span><br><span class="line">_sndCombat = FlxG.sound.load(AssetPaths.combat__wav);</span><br></pre></td></tr></table></figure><p>也许你知道它们会被放在哪些地方使用了，但我还是要过一遍。</p><p>于 initCombat 中：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndCombat.play();</span><br></pre></td></tr></table></figure><p>于 finishFadeIn 中：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndSelect.play();</span><br></pre></td></tr></table></figure><p>于<code>update()</code>函数中，位于三个按钮的按压判定相关的<code>if</code>语句（<code>if(_fire), else if(_up), else if(_down)</code>）中添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndSelect.play();</span><br></pre></td></tr></table></figure><p>于 makeChoice 中，位于 “命中” 的逻辑代码（在<code>_damages[1].text = &quot;1&quot;;</code>之后）的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndHurt.play();</span><br></pre></td></tr></table></figure><p>于闪躲的逻辑代码中添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndHurt.play();</span><br></pre></td></tr></table></figure><p>再往下，如果玩家逃脱（位于<code>cutcome = ESCAPE</code>之后的位置）添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndFled.play();</span><br></pre></td></tr></table></figure><p>于<code>enemyAttack()</code>中敌人的攻击命中玩家时：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndHurt.play();</span><br></pre></td></tr></table></figure><p>如果他们的攻击被miss了：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndMiss.play();</span><br></pre></td></tr></table></figure><p>最后，在 <code>DoneDamageOut()</code> 中，位于 <code>outcome = DEFEAT</code> 之后的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndLose.play();</span><br></pre></td></tr></table></figure><p>位于 <code>outcome = VICTORY</code> 之后的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sndWin.play();</span><br></pre></td></tr></table></figure><p>添加声音的工作到此就结束了，编译并运行你的游戏，现在你可以听到我们添加的所有音效了（确保你把系统的声音打开了）下一节我们将使游戏可以跨平台运行。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打算一次翻译完剩下的部分之后去弄点别的事情，HaxeFlixel相关的东西很闲的时候再回来整理。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/sound-and-music/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程11:游戏结束菜单</title>
    <link href="https://nulllstack.github.io/2019/03/29/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B11-%E6%B8%B8%E6%88%8F%E7%BB%93%E6%9D%9F%E8%8F%9C%E5%8D%95/"/>
    <id>https://nulllstack.github.io/2019/03/29/HaxeFlixel官方教程11-游戏结束菜单/</id>
    <published>2019-03-29T08:39:03.000Z</published>
    <updated>2019-09-12T18:02:43.783Z</updated>
    
    <content type="html"><![CDATA[<p>这周情绪一天也没消停过，现在是 2019/3/29 15:06 我已经一周没去上课了，起床冲了咖啡，饭一顿也没吃，开始考虑是不是要去看医生。</p><p><a href="http://haxeflixel.com/documentation/game-over-menu/" target="_blank" rel="noopener">原文</a></p><p>我们的游戏现在开始最后的整合阶段，现在我们需要为其添加一个胜负功能使其更像一个完整的游戏，对于我们这个简单的游戏而言，我们想要让玩家如果在战斗阶段死亡，则游戏结束，或者是玩家击败了Boss即获胜，这两个情况下都会跳转至同一个<code>FlxState</code>状态下，它将显示最终得分并允许玩家从这里重新开始游戏。</p><ol><li><p>让我们从<code>PlayState</code>开始，我们需要设一个flag用于检查游戏是否结束，以及玩家是否获胜：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ending:<span class="type">Bool</span>;</span><br><span class="line"><span class="keyword">var</span> _won:<span class="type">Bool</span>;</span><br></pre></td></tr></table></figure><p>两个变量添加于类体的顶部。</p></li><li><p>下一步，位于<code>update()</code>函数，<code>super.update(elapsed)</code>的调用后方的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_ending)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在游戏结束时开始准备开始切换state，不需要做其他任何事情所以return。</p></li><li><p>下一步，依然在<code>update()</code>函数中，把原来的逻辑代码修改为如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!_combatHud.visible)</span><br><span class="line">&#123;</span><br><span class="line">    _health = _combatHud.playerHealth;</span><br><span class="line">    _hud.updateHUD(_health, _money);</span><br><span class="line">    <span class="keyword">if</span>(_combatHud.outcome == DEFEAT)</span><br><span class="line">    &#123;</span><br><span class="line">        _ending = <span class="literal">true</span>;</span><br><span class="line">        FlxG.camera.fade(FlxColor.BLACK, <span class="number">.33</span>, <span class="literal">false</span>, doneFadeOut);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(_combatHud.outcome == VICTORY)</span><br><span class="line">        &#123;</span><br><span class="line">            _combatHud.e.kill();</span><br><span class="line">            <span class="keyword">if</span>(_combatHud.e.etype == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _won = <span class="literal">true</span>;</span><br><span class="line">                _ending = <span class="literal">true</span>;</span><br><span class="line">                FlxG.camera.fade(FlxColor.BLACK, <span class="number">.33</span>, <span class="literal">false</span>, doneFadeOut);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _combatHud.e.flicker();</span><br><span class="line">        &#125;</span><br><span class="line">        _inCombat = <span class="literal">false</span>;</span><br><span class="line">        _player.active = <span class="literal">true</span>;</span><br><span class="line">        _grpEnemies.active = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里所做的事情为检查结果是否为<code>DEFEAT</code>，如果是则设结束flag为真，并告诉摄像机开始渐隐（fading out），渐隐结束后调用<code>doneFadeOut()</code>。</p><p>相似的，如果结果为<code>VICTORY</code>，并且被击败的敌人类型为1（也就是Boss），则设<code>won</code>flag为真，并开始渐隐。</p></li><li><p>当摄像机渐隐为黑色之后，我们将调用该函数，它用于切换状态至<code>GameOverState</code>（我们在之后添加该类），并传递玩家是否获胜的信息以及玩家收集了多少金币：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doneFadeOut</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    FlxG.switchState(<span class="keyword">new</span> <span class="type">GameOverState</span>(_won, _money));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要添加<code>GameOverState</code>类。它是一个十分简单的<code>FlxState</code>对象，用于显示一些信息： “Game Over” 或 “You Win!” （显示哪一个取决于获胜flag的当前值）、以及玩家收集了多少金币。这里我们还将使用flixel的保存/读取功能用以比较历史最高分，如果当前玩家收集的金币比历史记录更多，我们将对当前分数替换历史最高分进行保存，并显示当前最高分。</p><p>最后我们会添加一个返回按钮使玩家可以退回至菜单界面。</p><p>这里是该类的源码：</p><p><a href="https://github.com/HaxeFlixel/flixel-demos/blob/dev/Tutorials/TurnBasedRPG/source/GameOverState.hx" target="_blank" rel="noopener">GameOverState.hx</a></p></li></ol><p>如果你开始测试你的游戏，你将可以通过于战斗阶段死亡或击败Boss而触发<code>GameOverState</code>，接着点击<code>GameOverState</code>状态中的按钮返回至<code>MenuState</code>状态，这样你就可以再一次开始游戏。如果游戏能够如以上描述的正常工作表明你目前没有偏离正轨。不过…目前我们的<code>MenuState</code>看起来有些乏味，所以我们开始为它添加些东西。</p><ol><li><p>让我们为它添加一个标题以及一个选项按钮（于<code>MenuState.hx</code>中）：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _txtTitle:<span class="type">FlxText</span>;</span><br><span class="line"><span class="keyword">var</span> _btnOptions:<span class="type">FlxButton</span>;</span><br></pre></td></tr></table></figure></li><li><p>接着，在<code>create()</code>函数中，我们把它添加至状态中（并移动原来的开始游戏按钮）：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_txtTitle = <span class="keyword">new</span> <span class="type">FlxText</span>(<span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">"HaxeFlixel\nTutorial\nGame"</span>, <span class="number">22</span>);</span><br><span class="line">_txtTitle.alignment = CENTER;</span><br><span class="line">_txtTitle.screenCenter(X);</span><br><span class="line">add(_txtTitle);</span><br><span class="line"></span><br><span class="line">_btnPlay = <span class="keyword">new</span> <span class="type">FlxButton</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Play"</span>, clickPlay);</span><br><span class="line">_btnPlay.x = (FlxG.width / <span class="number">2</span>) - _btnPlay.width - <span class="number">10</span>;</span><br><span class="line">_btnPlay.y = FlxG.height - _btnPlay.height - <span class="number">10</span>;</span><br><span class="line">add(_btnPlay);</span><br><span class="line"></span><br><span class="line">_btnOptions = <span class="keyword">new</span> <span class="type">FlxButton</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Options"</span>, clickOptins);</span><br><span class="line">_btnOptions.x = (FlxG.width / <span class="number">2</span>) + <span class="number">10</span>;</span><br><span class="line"> _btnOptions.y = FlxG.height - _btnOptions.height - <span class="number">10</span>;</span><br><span class="line"> add(_btnOptions);</span><br></pre></td></tr></table></figure></li><li><p>添加一个函数用于当选项按钮被点击时调用：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clickOptions</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    FlxG.switchState(<span class="keyword">new</span> <span class="type">OptionsState</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当选项按钮被点击后切换的<code>OptionState</code>状态类也相当简单，它将包含一个按钮用于使玩家可以清空以保存的数据（如 历史最高分），以及一个简单的<code>FlxBar</code>拉动条用于表示当前游戏的音量级数以及一组按钮用于调整音量级数的高低。它将会保存当前音量的值，所以当游戏开始时它将会记住最后音量级数的设置（我知道我们的游戏现在还没有声音 ;) ）。</p><p>该类的源码：</p><p><a href="https://github.com/HaxeFlixel/flixel-demos/blob/dev/Tutorials/TurnBasedRPG/source/OptionsState.hx" target="_blank" rel="noopener">OptionsState.hx</a></p><p><code>OptionsState</code>类使用了一组精灵序列供音量调节按钮使用（因为他们需要比默认的按钮更小一些），该资源文件需要包含3个帧，分别表现出按钮的三个状态：<code>正常</code>、<code>高亮</code>、以及<code>被按下</code>。我们只需要按此顺序排列这个精灵序列的各个帧，<code>FlxButton</code>会为我们处理剩余的工作。</p><p>再一次，你可以自己做一个，或者使用下面提供的图像资源。将其放置于<code>assets/images</code>文件夹内即可。</p></li></ol><div align="center"><p><img src="//nulllstack.github.io/2019/03/29/HaxeFlixel官方教程11-游戏结束菜单/button.png" alt></p></div><p>   最后，我们需要游戏每次开始时读取已保存的音量设置（如果当前有设置的话），跳转至<code>Main.hx</code>类，并在<code>addChild()</code>函数调用之后的位置添加以下代码：</p>   <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _save:<span class="type">FlxSave </span>= <span class="keyword">new</span> <span class="type">FlxSave</span>();</span><br><span class="line">_save.bind(<span class="string">"flixel-tutorial"</span>);</span><br><span class="line"><span class="keyword">if</span>(_save.data.volume != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    FlxG.sound.volume = _save.data.volume;</span><br><span class="line">&#125;</span><br><span class="line">_save.close();</span><br></pre></td></tr></table></figure><p>   十分简单，它创建一个新的<code>FlxSave</code>对象，将其绑定至我们的<code>&quot;flixel-tutorial&quot;</code>并在之后检查是否有音量值被存储进来，如果有，则将游戏的音量设为该值，之后关闭保存。</p><p>测试游戏，确保正常工作，如果你在设置中修改了音量设置并退出游戏，它将会在下一次进入游戏时保留当前设置的音量值。</p><div align="center"><p><img src="//nulllstack.github.io/2019/03/29/HaxeFlixel官方教程11-游戏结束菜单/0022.png" alt></p></div><p>看起来不错，下一节我们将添加一些音效与音乐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这周情绪一天也没消停过，现在是 2019/3/29 15:06 我已经一周没去上课了，起床冲了咖啡，饭一顿也没吃，开始考虑是不是要去看医生。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/game-over-menu
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程10:UI与战斗系统</title>
    <link href="https://nulllstack.github.io/2019/03/16/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B10-UI%E4%B8%8E%E6%88%98%E6%96%97%E7%B3%BB%E7%BB%9F/"/>
    <id>https://nulllstack.github.io/2019/03/16/HaxeFlixel官方教程10-UI与战斗系统/</id>
    <published>2019-03-15T17:23:28.000Z</published>
    <updated>2019-03-29T08:41:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/ui-and-combat/" target="_blank" rel="noopener">原文</a></p><p>由于这次内容涉及比较多东西，估计摸索的时间会比较长，文本我先翻译完先放上来，之后摸索完整理些细节再另外po一篇作为补充。</p><p>现在我们需要让玩家知道他们在游戏中的行为产生了哪些影响。所以我们需要在屏幕中显示一个HUD用于告诉玩家 当前/最大 血量为多少，以及目前收集了多少金币。表示生命值的图标你可以使用这个图形资源：<img src="//nulllstack.github.io/2019/03/16/HaxeFlixel官方教程10-UI与战斗系统/health.png" alt>,确保你将图像资源保存至<code>assets/images</code>文件夹下。</p><ol><li><p>我们首先新建一个<code>HUD</code>类，它用于保存所有的HUD元素。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> flixel.FlxSprite;</span><br><span class="line"><span class="keyword">import</span> flixel.text.FlxText;</span><br><span class="line"><span class="keyword">import</span> flixel.FlxSprite;</span><br><span class="line"><span class="keyword">import</span> flixel.group.FlxGroup.FlxTypedGroup;</span><br><span class="line"><span class="keyword">import</span> flixel.util.FlxColor;</span><br><span class="line"><span class="keyword">import</span> flixel.FlxG;</span><br><span class="line"><span class="keyword">using</span> flixel.util.FlxSpriteUtil;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HUD</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">FlxTypedGroup</span></span>&lt;<span class="title">FlxSprite</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _sprBack:<span class="type">FlxSprite</span>;</span><br><span class="line">    <span class="keyword">var</span> _txtHealth:<span class="type">FlxText</span>;</span><br><span class="line">    <span class="keyword">var</span> _txtMoney:<span class="type">FlxText</span>;</span><br><span class="line">    <span class="keyword">var</span> _sprHealth:<span class="type">FlxSprite</span>;</span><br><span class="line">    <span class="keyword">var</span> _sprMoney:<span class="type">FlxSprite</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        _sprBack = <span class="keyword">new</span> <span class="type">FlxSprite</span>().makeGraphic(FlxG.width, <span class="number">20</span>, FlxColor.BLACK);</span><br><span class="line">        </span><br><span class="line">        _sprBack.drawRect(<span class="number">0</span>, <span class="number">19</span>, FlxG.width, <span class="number">1</span>, FlxColor.WHITE); </span><br><span class="line">        <span class="comment">/*此处技术细节参考：https://www.kancloud.cn/simon_chang/haxe3manual/183635*/</span></span><br><span class="line">        </span><br><span class="line">        _txtHealth = <span class="keyword">new</span> <span class="type">FlxText</span>(<span class="number">16</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="string">"3 / 3"</span>, <span class="number">8</span>);</span><br><span class="line">        _txtHealth.setBorderStyle(SHADOW, FlxColor.GRAY, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        _txtMoney = <span class="keyword">new</span> <span class="type">FlxText</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="string">"0"</span>, <span class="number">8</span>);</span><br><span class="line">        _txtMoney.setBorderStyle(SHADOW, FlxColor.GRAY, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        _sprHealth = <span class="keyword">new</span> <span class="type">FlxSprite</span>(<span class="number">4</span>, _txtHealth.y + (_txtHealth.height/<span class="number">2</span>) - <span class="number">4</span>, AssetPaths.health__png);</span><br><span class="line">        _sprMoney = <span class="keyword">new</span> <span class="type">FlxSprite</span>(FlxG.width - <span class="number">12</span>, _txtMoney.y + (_txtMoney.height/<span class="number">2</span>) - <span class="number">4</span>, AssetPaths.coin__png);</span><br><span class="line">        _txtMoney.alignment = RIGHT;</span><br><span class="line">        _txtMoney.x = _sprMoney.x - _txtMoney.width - <span class="number">4</span>;</span><br><span class="line">        add(_sprBack);</span><br><span class="line">        add(_sprHealth);</span><br><span class="line">        add(_sprMoney);</span><br><span class="line">        add(_txtHealth);</span><br><span class="line">        add(_txtMoney);</span><br><span class="line">        </span><br><span class="line">        forEach(<span class="function"><span class="keyword">function</span></span>(spr:<span class="type">FlxSprite</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    spr.scrollFactor.<span class="keyword">set</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">/*注意此处的forEach()函数并非一个迭代语句（iterate statement)，它是声明于FlxGroup类中的一个函数具体细节参考官方API文档*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">updateHUD</span></span>(Health:<span class="type">Int </span>= <span class="number">0</span>, Money:<span class="type">Int </span>= <span class="number">0</span>):<span class="type">Void</span></span><br><span class="line"><span class="type">    </span>&#123;</span><br><span class="line">        _txtHealth.text = Std.string(Health) + <span class="string">" / 3"</span>;</span><br><span class="line">        _txtMoney.text = Std.string(Money);</span><br><span class="line">        _txtMoney.x = _sprMoney.x - _txtMoney.width - <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类继承自<code>FlxTypedGroup&lt;FlxSprite&gt;</code>类所以它可以用于保存我们所有的<code>FlxSprite</code>对象。它由5个部分组成：背景（黑色，底部有一条1像粗细的白色细线），两个<code>FlxText</code>对象（一个用于生命值，一个用于当前金币），两个<code>FlxSprite</code>对象（用于在<code>FlxText</code>对象旁边显示图标）。在构造函数的函数体最后几行里我们调用了<code>forEach()</code>遍历当前Group的所有成员并将它们的<code>scrollFactor.x</code>与<code>scrollFactor.y</code>都设为 0，这么做可以使得摄像机在滚动的时候这些对象的位置也会停留在原地（相对于显示屏幕）。</p><p>最后我们声明了一个函数使得从任意位置调用时告诉<code>HUD</code>应该如何显示。</p></li><li><p>现在我们要让它开始实际工作并在玩家不论何时捡起硬币时更新数据。在<code>PlayState</code>类的顶部添加以下变量：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _hud:<span class="type">HUD</span>;</span><br><span class="line"><span class="keyword">var</span> _money:<span class="type">Int </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> _health:<span class="type">Int </span>= <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>在<code>create()</code>函数，于<code>super.create()</code>语句之前的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_hud = <span class="keyword">new</span> <span class="type">HUD</span>();</span><br><span class="line">add(_hud);</span><br></pre></td></tr></table></figure></li><li><p>最后，在<code>playerTouchCoin()</code>函数体中的<code>if</code>语句中任意位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_money++;</span><br><span class="line">_hud.updateHUD(_health, _money);</span><br></pre></td></tr></table></figure></li></ol><p>接着测试你的游戏，HUD应该会在你每次拾起硬币的时候更新显示的内容。</p><p><img src="//nulllstack.github.io/2019/03/16/HaxeFlixel官方教程10-UI与战斗系统/untitled.png" alt></p><p>如果我们有一个使玩家的角色受到伤害的方式，那么我们也需要更新HUD显示的生命值，不过首先我们要确定玩家与敌人战斗的形式。</p><p>现在让我们开始搭建我们的战斗系统。首先，在这里我们并不是要做一个如最终幻想那样庞大的战斗系统，这里只不过是对几个不同的元素如何工作做出一个基本演示。所以我想这里我们要做的是当玩家与敌人发生碰撞时，跳出一个界面，显示玩家与敌人当前的生命值（为了视觉上更为友好，数值显示于一管血条中），并为玩家提供两个选项：<code>战斗</code>或<code>逃跑</code>。</p><p>如果玩家选择了战斗，我们将roll一个随机数用于判断玩家与敌人间的攻击是否击中了对方，如果击中了，将对对方造成一点伤害。如果敌人死亡玩家将脱离战斗状态。而如果玩家选择了逃跑，我们将以同样的方式判断玩家是否成功脱离，如果成功脱离战斗则关闭战斗界面，并使敌人在原地停顿几秒给玩家时间远离它。如果脱离失败了，敌人会乘机攻击玩家。我们还要在战斗界面显示当前攻击是否被闪躲或造成了多少伤害值。</p><p>这些看起来很简单，但实际上这需要几个不同的部分相互协作来实现，他其实是我们到目前为止所作的最复杂的部分。</p><ol><li><p>第一个部分是<code>CombatHUD</code>类。这是一个庞大的类，战斗系统主要的逻辑代码都交由这个类完成。你可以在这里查看完整的源码：</p><p><a href="https://github.com/HaxeFlixel/flixel-demos/blob/dev/Tutorials/TurnBasedRPG/source/CombatHUD.hx" target="_blank" rel="noopener">CombatHUD.hx</a></p><p>花点时间完整的查看这个类的源码搞清楚它是如何工作的，之后再将它添加进你的项目里。</p><p>我们现在已经有了供<code>CombatHUD</code>类使用的大部分资源文件，但是我们还需要一个图形文件，用于当玩家做选择时显示的箭头图形。你可以在<a href="https://github.com/HaxeFlixel/flixel-demos/blob/dev/Tutorials/TurnBasedRPG/assets/images/pointer.png" target="_blank" rel="noopener">这里下载</a>（点击download）（或者自己做一个），确保文件名为<code>pointer.png</code>并把它保存至项目文件夹内的<code>assets/images</code>文件夹内。</p><p><code>CombatHUD</code>类中还使用了一些我们尚未讨论的东西：<em>声音</em>。我们将会在 “声音与音乐” 章节对此进行更深入的探讨，现在请先将以下这些文件下载<code>assets/sounds</code>文件夹下，这样才能让源码正确编译。</p><p>这我就不单独罗列了，github上有，把链接里全部<code>wav</code>文件都下下来：<a href="https://github.com/HaxeFlixel/flixel-demos/tree/dev/Tutorials/TurnBasedRPG/assets/sounds" target="_blank" rel="noopener">链接</a></p></li><li><p>现在你需要为<code>Enemy</code>类添加一个简单的函数：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">changeEnemy</span></span>(EType:<span class="type">Int</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(etype != EType)</span><br><span class="line">    &#123;</span><br><span class="line">        etype = EType;</span><br><span class="line">        loadGraphic(<span class="string">"assets/images/enemy-"</span> + etype + <span class="string">".png"</span>, <span class="literal">true</span>, <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着我们需要把<code>CombatHUD</code>对象添加进<code>PlayState</code>类中，把以下代码添加至<code>PlayState</code>类的顶部：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _inCombat:<span class="type">Bool </span>= <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> _combatHud:<span class="type">CombatHUD</span>;</span><br></pre></td></tr></table></figure></li><li><p>移动到<code>create()</code>函数的位置，在函数体中，在我们添加（add）HUD之后，调用<code>super.create()</code>之前的位置添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_combatHud = <span class="keyword">new</span> <span class="type">CombatHUD</span>();</span><br><span class="line">add(_combatHud);</span><br></pre></td></tr></table></figure></li><li><p>移动到<code>update()</code>函数的位置，将其修改为<strong>仅当</strong>处于非战斗状态时才进行碰撞与重叠检测。位于<code>super.update()</code>调用之后的所有东西应该如以下代码所示：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!_inCombat)</span><br><span class="line">&#123;</span><br><span class="line">    FlxG.collide(_player, _mWalls);</span><br><span class="line">    FlxG.overlap(_player, _grpCoins, playerTouchCoin);</span><br><span class="line">    FlxG.collide(_grpEnemies, _mWalls);</span><br><span class="line">    _grpEnemies.forEachAlive(checkEnemyVision);</span><br><span class="line">    FlxG,overlap(_player, _grpEnmies, playerTouchEnemy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_combatHud.visible)</span><br><span class="line">    &#123;</span><br><span class="line">        _health = _combatHud.playerHealth;</span><br><span class="line">        _hud.updateHUD(_health, _money);</span><br><span class="line">        <span class="keyword">if</span>(_combatHud.outcome == VICTORY)</span><br><span class="line">        &#123;</span><br><span class="line">            _combatHud.e.kill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _combatHud.e.flicker();</span><br><span class="line">        &#125;</span><br><span class="line">        _inCombat = <span class="literal">false</span>;</span><br><span class="line">        _player.active = <span class="literal">true</span>;</span><br><span class="line">        _grpEnemies.active = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们要添加一个条件检测，用于检查玩家是否碰到一个敌人，如果是则调用回调函数以查看我们是否应该开始战斗。</p><p>如果我们处于战斗阶段，我们就持续检测HUD当前是否为可见的，当它为不可见时我们就知道战斗结束了，之后我们就可以对结果进行结算，当结果为<code>VICTORY</code>（我们的四个枚举值的其中一个）时，我们就杀掉敌人（<code>_combatHud.e.kill()</code>），而当玩家选择了逃跑，我们将使该敌人闪烁，用于表示玩家从这一刻起的一小段时间内将是安全的不会与该敌人再次触发战斗。</p></li><li><p>你可能已经发现了我们的<code>Enemy</code>类并没有<code>flicker()</code>函数（注），这是因为我们将使用<code>FlxSpriteUtil</code>类的一个函数来实现这个功能，Haxe提供了一个很nice的语法特性来帮我们完成这个工作。那么在<code>PlayState</code>类文件的顶部，位于其他导入语句（import）之后，添加一行代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> flixel.util.FlxSpriteUtil;</span><br></pre></td></tr></table></figure><p>这将使得我们可以使用<code>FlxSpriteUtil</code>的APIs，如<code>flicker()</code>函数，它可以被用于任何<code>FlxObject</code>对象。具体技术细节参考<a href="https://haxe.org/manual/lf-static-extension.html" target="_blank" rel="noopener">官方文档-静态扩展</a>。</p><p><strong>注：<code>_combatHud.e.flicker()</code>的调用使用了Haxe的语法特性-*<a href="https://www.kancloud.cn/simon_chang/haxe3manual/183635" target="_blank" rel="noopener">静态扩展</a>*，使得我们的<code>Enemy</code>类本身即使没有flicker()函数也可以通过外部类进行扩展。</strong></p></li><li><p>接下来让我们添加一个函数用于处理当玩家触碰到一个敌人的情况：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playerTouchEnemy</span></span>(P:<span class="type">Player</span>, E:<span class="type">Enemy</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(P.alive &amp;&amp; P.exists &amp;&amp; E.alive &amp;&amp; E.exists &amp;&amp; !E.isFlickering())</span><br><span class="line">    &#123;</span><br><span class="line">        startCombat(E);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startCombat</span></span>(E:<span class="type">Enemy</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    _inCombat = <span class="literal">true</span>;</span><br><span class="line">    _player.active = <span class="literal">false</span>;</span><br><span class="line">    _grpEnemies.active = <span class="literal">false</span>;</span><br><span class="line">    _combatHud.initCombat(_health, E);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这里检查玩家与敌人的<code>alive</code>与<code>exists</code>属性是否都为<code>true</code>并且敌人不处于闪烁状态（闪烁状态下的敌人是那些我们刚刚脱离战斗状态的敌人）。如果条件都满足，我们就使之进入战斗状态。</p><p><code>startCombat()</code>函数所做的事情是设置我们的<code>inCombat</code>flag进行赋值（这样做使得我们可以知道是否进行碰撞检测），并使玩家与敌人都进入非活动状态，这样它们将停止逻辑代码的更新（暂停<code>update()</code>的调用）。</p><p>最后我们调用<code>initCombat()</code>函数，使得<code>CombatHUD</code>初始化并开始工作。</p></li><li><p>最后的最后，我们要使闪烁的敌人原地不动，它们应该在玩家逃跑后停顿几秒。</p><p>在<code>Enemy</code>类中，于<code>update()</code>函数体内添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.isFlickering())</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>把这段代码放在函数体的第一行的位置，优先于函数体内其他语句执行。</p><p>注意<code>isFlickering()</code>函数同样来自<code>FlxSpriteUtil</code>类，所以如前面的做法，需要在<code>Enemy</code>类中添加一行<code>using</code>语句：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> flixel.util.FlxSpriteUtil;</span><br></pre></td></tr></table></figure><p>这样就ok了，测试游戏确保能如期正常运行！</p><p><img src="//nulllstack.github.io/2019/03/16/HaxeFlixel官方教程10-UI与战斗系统/0020.png" alt></p><p>下一节我们将涉及获胜于失败状态（<code>PlayState</code>是游玩状态），并整合我们的所有状态（state）。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/ui-and-combat/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于这次内容涉及比较多东西，估计摸索的时间会比较长，文本我先翻
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程9:敌人与基础AI</title>
    <link href="https://nulllstack.github.io/2019/03/08/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B9-%E6%95%8C%E4%BA%BA%E4%B8%8E%E5%9F%BA%E7%A1%80AI/"/>
    <id>https://nulllstack.github.io/2019/03/08/HaxeFlixel官方教程9-敌人与基础AI/</id>
    <published>2019-03-07T17:39:49.000Z</published>
    <updated>2019-03-07T17:42:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/enemies-and-basic-ai/" target="_blank" rel="noopener">原文</a></p><p>如果地牢游戏里没有敌人的话就太名不副实了，所以现在我们来添加一些敌人进去！</p><ol><li><p>现在为你的 Ogmo 项目添加一个新的实体（entity）- 你很快就会习惯于这个工作流：</p><p><img src="//nulllstack.github.io/2019/03/08/HaxeFlixel官方教程9-敌人与基础AI/1.png" alt></p><p>确保你添加了<code>etype</code>值。</p></li><li><p>接着在地图里散布一些敌人，确保其中有且只有一个敌人的<code>etype</code>值为1，其余为0</p><p><img src="//nulllstack.github.io/2019/03/08/HaxeFlixel官方教程9-敌人与基础AI/2.png" alt></p></li><li><p>那么我们想要游戏中存在两种类型的敌人，我们需要为它们提供两组精灵序列图，同样是16x16像素大小、与我们的player精灵序列图一样数量的动作帧。把它们命名为<code>enemy-0.png</code>与<code>enemy-1.png</code>，并保存至<code>assets/images</code>文件夹下，一下提供这两组精灵序列图给你使用（再次感谢 Vicky 为我们创作的图形资源！）：</p><p><img src="//nulllstack.github.io/2019/03/08/HaxeFlixel官方教程9-敌人与基础AI/enemy-0.png" alt></p><p><img src="//nulllstack.github.io/2019/03/08/HaxeFlixel官方教程9-敌人与基础AI/enemy-1.png" alt></p><p>注意：确保你的两个精灵序列图以相同方式工作，它们在每个朝向上（facing）的动画都应该有相同数量的帧。</p></li><li><p>现在让我们来添加一个<code>Enemy</code>类，这个类整体上与我们的<code>Player</code>类十分相似，其中有几处改动：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enemy</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">FlxSprite</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> speed:<span class="type">Float </span>= <span class="number">140</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> etype(<span class="keyword">default</span>, <span class="literal">null</span>):<span class="type">Int</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(X:<span class="type">Float</span>=<span class="number">0</span>, Y:<span class="type">Float</span>=<span class="number">0</span>, EType:<span class="type">Int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(X, Y);</span><br><span class="line">        etype = EType;</span><br><span class="line">        loadGraphic(<span class="string">"assets/images/enemy-"</span> + etype + <span class="string">".png"</span>, <span class="literal">true</span>, <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">        setFacingFlip(FlxObject.LEFT, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        setFacingFlip(FlxObject.RIGHT, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        animation.add(<span class="string">"d"</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>], <span class="number">6</span>, <span class="literal">false</span>);</span><br><span class="line">        animation.add(<span class="string">"lr"</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>], <span class="number">6</span>, <span class="literal">false</span>);</span><br><span class="line">        animation.add(<span class="string">"u"</span>, [<span class="number">6</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>], <span class="number">6</span>, <span class="literal">false</span>);</span><br><span class="line">        drag.x = drag.y = <span class="number">10</span>;</span><br><span class="line">        width = <span class="number">8</span>;</span><br><span class="line">        height = <span class="number">14</span>;</span><br><span class="line">        offset.x = <span class="number">4</span>;</span><br><span class="line">        offset.y = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">draw</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((velocity.x != <span class="number">0</span> || velocity.y != <span class="number">0</span> ) &amp;&amp; touching == FlxObject.NONE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(velocity.x) &gt; Math.abs(velocity.y))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (velocity.x &lt; <span class="number">0</span>)</span><br><span class="line">                    facing = FlxObject.LEFT;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    facing = FlxObject.RIGHT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (velocity.y &lt; <span class="number">0</span>)</span><br><span class="line">                    facing = FlxObject.UP;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    facing = FlxObject.DOWN;</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">switch</span> (facing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> FlxObject.LEFT, FlxObject.RIGHT:<span class="type"></span></span><br><span class="line"><span class="type">                    animation</span>.play(<span class="string">"lr"</span>);</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">case</span> FlxObject.UP:<span class="type"></span></span><br><span class="line"><span class="type">                    animation</span>.play(<span class="string">"u"</span>);</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">case</span> FlxObject.DOWN:<span class="type"></span></span><br><span class="line"><span class="type">                    animation</span>.play(<span class="string">"d"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的不同点在于现在我们有一个新的<code>etype</code>变量，它被我们用于确定哪个enemy的精灵序列图将要被加载，以及我们将处理哪一个精灵等等。</p></li><li><p>接下来我们需要在<code>PlayState</code>中创建一个<code>FlxGroup</code>实例，用于保存我们的enemies对象并把他们加载进地图内，与前面章节对coin对象的操作极为相似。</p><p>位于类的顶部添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _grpEnemies:<span class="type">FlxTypedGroup</span>&lt;Enemy&gt;;</span><br></pre></td></tr></table></figure><p>在构造函数中，位于coin组的实例化之后的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_grpEnemies = <span class="keyword">new</span> <span class="type">FlxTypedGroup</span>&lt;Enemy&gt;();</span><br><span class="line">add(_grpEnemies);</span><br></pre></td></tr></table></figure><p>然后在<code>placeEntities()</code>函数中位于 if/else 语句之后的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(entityName == <span class="string">"enemy"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _grpEnemies.add(<span class="keyword">new</span> <span class="type">Enemy</span>(x + <span class="number">4</span>, y, Std.parseInt(EntityData.<span class="keyword">get</span>(<span class="string">"etype"</span>))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着编译一下游戏测试一下敌人是不是被正确的添加至游戏中。</p></li></ol><p>现在让我们给敌人创造一个大脑。</p><p>为了让我们的敌人能够“思考”，我们将要应用一个简单的 有限状态机（<a href="http://en.wikipedia.org/wiki/Finite_state_machine" target="_blank" rel="noopener">Finite-state Machine(FSM)</a>）。</p><p>简单来说，可以把一个FSM看成是一个一次只能表现一个状态的机器或实体，对应地我们将给予我们的 enemies 对象两种可能存在的状态：渡步（<code>Idle</code>）与追逐（<code>Chase</code>）。当它们看不到玩家时，它们将处于渡步状态下，即无目的的在四周徘徊。直到玩家出现在它们的视野范围内，它们将切换为追逐状态，朝玩家所处位置跑动。</p><ol><li><p>这应该不会很难，首先让我们来创建一个<code>FSM</code>类：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FSM</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> activeState:<span class="type">Void-&gt;Void</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(?InitState:<span class="type">Void-&gt;Void</span>):<span class="type">Void</span></span><br><span class="line"><span class="type">    </span>&#123;</span><br><span class="line">        activeState = InitState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(activeState != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            activeState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着我们稍微对<code>Enemy</code>类做一点修改。</p><p>我们需要在类的顶部定义以下这些变量：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _brain:<span class="type">FSM</span>;</span><br><span class="line"><span class="keyword">var</span> _idleTmr:<span class="type">Float</span>;</span><br><span class="line"><span class="keyword">var</span> _moveDir:<span class="type">Float</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> seesPlayer:<span class="type">Bool </span>= <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> playerPos(<span class="keyword">default</span>, <span class="literal">null</span>):<span class="type">FlxPoint</span>;</span><br></pre></td></tr></table></figure></li><li><p>并在位于构造函数的末尾处添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_brain = <span class="keyword">new</span> <span class="type">FSM</span>(idle);</span><br><span class="line">_idleTmr = <span class="number">0</span>;</span><br><span class="line">playerPos = FlxPoint.<span class="keyword">get</span>();</span><br></pre></td></tr></table></figure></li><li><p>接着添加以下几个函数：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">idle</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seesPlayer)</span><br><span class="line">    &#123;</span><br><span class="line">        _brain.activeState = chase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(_idleTmr &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(FlxG.random.bool(<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            _moveDir = <span class="number">-1</span>;</span><br><span class="line">            velocity.x = velocity.y = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _moveDir = FlxG.random.int(<span class="number">0</span>, <span class="number">8</span>) * <span class="number">45</span>;</span><br><span class="line">            velocity.<span class="keyword">set</span>(speed * <span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">            velocity.rotate(FlxPoint.weak(), _moveDir);</span><br><span class="line">        &#125;</span><br><span class="line">        _idleTmr = FlxG.random.int(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    _idleTmr -= FlxG.elapsed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">chase</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!seesPlayer)</span><br><span class="line">        _brain.activeState = idle;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        FlxVelocity.moveTowardsPoint(<span class="built_in">this</span>, playerPos, Std.int(speed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span></span>(elapsed:<span class="type">Float</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    _brain.update();</span><br><span class="line">    <span class="keyword">super</span>.update(elapsed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其工作方式是这样的：每个敌人将以<code>Idle</code>也就是渡步状态生成，在<code>PlayState</code>中每一个敌人将时刻检查是否看到玩家，如果看到了，它将切换至<code>Chase</code>也就是追逐状态，直到不再能够看到玩家为止。当处于<code>Idle</code>状态下，通常（随机间隔内）选择一个随机的朝向移动（以及一个小概率的止步不前）。当处于<code>Chase</code>状态下时它们会朝玩家所处位置移动。</p></li><li><p>让我们跳回到<code>PlayState</code>类中，添加检测玩家的视野范围的逻辑代码。在<code>update()</code>函数中位于重叠与碰撞检测的代码之后的位置添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FlxG.collide(_grpEnemies, _mWalls);</span><br><span class="line">_grpEnemies.forEeachAlive(checkEnemyVision);</span><br></pre></td></tr></table></figure></li><li><p>接着添加<code>checkEnemyVision()</code>函数：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkEnemyVision</span></span>(e:<span class="type">Enemy</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_mWalls.ray(e.getMidpoint(), _player.getMidpoint()))</span><br><span class="line">    &#123;</span><br><span class="line">        e.seesPlayer = <span class="literal">true</span>;</span><br><span class="line">        e.playerPos.copyFrom(_player.getMidpoint());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    e.seesPlayer = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>至此就完成这一节的所有工作了，编译运行你的游戏确保它能正常工作！</p><p><img src="//nulllstack.github.io/2019/03/08/HaxeFlixel官方教程9-敌人与基础AI/untitled.png" alt></p><p>下一节，我们将为游戏添加一些UI，以及一个 RPG 类型的战斗系统，这样玩家就能够与敌人进行战斗了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/enemies-and-basic-ai/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果地牢游戏里没有敌人的话就太名不副实了，所以现
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>蛋疼的迁移过程</title>
    <link href="https://nulllstack.github.io/2019/03/06/%E8%9B%8B%E7%96%BC%E7%9A%84%E8%BF%81%E7%A7%BB%E8%BF%87%E7%A8%8B/"/>
    <id>https://nulllstack.github.io/2019/03/06/蛋疼的迁移过程/</id>
    <published>2019-03-05T17:28:15.000Z</published>
    <updated>2019-03-05T18:04:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为某些原因想要丢掉原来的GitHub账号还有博客，换身皮囊再继续。</p><p>隔了一天的关系迁移过程有点模糊没什么头绪，我先罗列一下：</p><ol><li>更改本地的GitHub账号</li><li>绑定SSH</li><li>新建一个Repository</li><li>重新部署博客（迁移博客配置文件、迁移博客主题配置文件、安装插件等）</li></ol><p>在我做完 1、2 、3 之后我新建了一个文件夹用于重新生成博客（<code>hexo init</code>），之后尝试进行第 4 步操作。结果大概如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remote: Permission to myNewAccount.git denied to MY_OLD_GITHUB_ACCOUNT</span><br><span class="line">fatal: unable to access &apos;https://github.com/myNewAccount/myNewRepo&apos;: </span><br><span class="line">The requested URL returned error: 403`</span><br></pre></td></tr></table></figure><p>似乎是由于部署博客的过程里往仓库 push 的时候被自动使用了旧账号进行操作，在这之后的2个小时里我不断更新 SSH key 、删掉博客的本地文件再 <code>hexo init</code> 反复折腾，最后发现只需要打开 GitHub Desktop 更新账号，把放博客的新 repo 给 clone 下来就行（重启电脑前不行，重启之后再尝试博客就成功部署上去了）</p><p>部署完不算完，因为我以为每次迁移博客都需要重新 <code>hexo init</code> 所以新博客现在是空的，我原来旧的那些文章都还没放进去，虽然都是食之无味弃之可惜，但是。。。弃之可惜嘛。。。所以我把备份好的 <code>.md</code> 文件直接丢到新博客的 post 文件夹里生成。。。结果又出事了，只有靠前的两三篇文章标题正确显示，剩余的全是“no-title”；这个情况在之前也碰上过，但是由于每次码字都累爆，上传又遇上这种情况就会心烦气躁地 “备份-删除-重新上传、复制-粘贴-重新上传” 地折腾个三四十分钟，问题往往莫名其妙地就能解决。但是这次我怀疑的对象不再是文件本身，我怀疑是 hexo 生成的页面会根据 <code>hexo new &quot;article title&quot;</code> 时生成某个文件、保存文章标题来进行显示。然而事实是我想多了。</p><p>事实上每一次的 <code>hexo new &quot;new article&quot;</code> 生成的 <code>.md</code> 文件里都会自动生成出如下内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: 蛋疼的迁移过程</span><br><span class="line">date: 2019-03-06 01:28:15</span><br><span class="line">tags:</span><br></pre></td></tr></table></figure><p>估计 hexo 生成的页面就是通过这里的 title 获取文章标题进行显示的（我真的很不乐意学HTML之流，我甚至觉得它们比C++还麻烦 :P ），而我在云端备份的文章里都没把这一段内容放进去，所以生成的页面找不到标题就默认给了 no-title 。</p><p>哦对了，想起来一个事儿，在我直接放 <code>.md</code> 文件生成博客之前我看了 hexo 官网的文档，里头提到迁移文章的一个插件“hexo-migrator-rss” ，需要通过<code>npm install hexo-migrator-rss --save</code> 安装之后使用，他可以从RSS迁移所有文章，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo migrate rss &lt;source&gt;</span><br></pre></td></tr></table></figure><p><code>source</code> 可以是文件路径或网址，也就是指向某个“atom.xml”文件就行了，所以我试了一下，结果文章确实都被取回来了，但是都是根据<code>.xml</code>文件的内容生成的，文章内嵌入的图片资源都没能获取到，<strong>原因不明</strong>。似乎很麻烦所以很快就考虑其他解决办法。</p><p>接着我意识到这一切都与是否生成一个新博客不相关的，你要做的只是在博客的配置文件里更改 url、root（可选）、deploy的参数，部署的时候 hexo 只看你的 deploy 参数而已，于是我滚回原来存放博客的文件夹里修改了配置文件，重新部署了一下。。。</p><p>至此迁移工作就完事儿了，挺蛋疼的，30分钟的事情我弄了3个小时，尽管多多少少还是有所收获吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为某些原因想要丢掉原来的GitHub账号还有博客，换身皮囊再继续。&lt;/p&gt;
&lt;p&gt;隔了一天的关系迁移过程有点模糊没什么头绪，我先罗列一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;更改本地的GitHub账号&lt;/li&gt;
&lt;li&gt;绑定SSH&lt;/li&gt;
&lt;li&gt;新建一个Repository&lt;
      
    
    </summary>
    
    
    
      <category term="学习记录" scheme="https://nulllstack.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>作废，迁移</title>
    <link href="https://nulllstack.github.io/2019/03/03/%E4%BD%9C%E5%BA%9F%EF%BC%8C%E8%BF%81%E7%A7%BB/"/>
    <id>https://nulllstack.github.io/2019/03/03/作废，迁移/</id>
    <published>2019-03-02T17:20:21.000Z</published>
    <updated>2019-03-03T18:39:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>从原来的地方搬到这里来了，回头记录一下迁移过程（有点蛋疼），明天还有课已经凌晨两点半了，该睡觉了，晚安:)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从原来的地方搬到这里来了，回头记录一下迁移过程（有点蛋疼），明天还有课已经凌晨两点半了，该睡觉了，晚安:)&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>时隔多日再水一篇</title>
    <link href="https://nulllstack.github.io/2018/09/05/%E6%97%B6%E9%9A%94%E5%A4%9A%E6%97%A5%E5%86%8D%E6%B0%B4%E4%B8%80%E7%AF%87/"/>
    <id>https://nulllstack.github.io/2018/09/05/时隔多日再水一篇/</id>
    <published>2018-09-05T15:18:15.000Z</published>
    <updated>2019-09-12T17:43:05.133Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客本该在几日前写完的，开学前应一老友所需码一篇关于HaxeFlixel开发环境搭建的文章，无奈开学这两天没太适应过来拖延到今晚才开始有心情码字，实际发布时间会晚于tag所标示的时间。</p><p>以下是本次要安装的各种工具：</p><ul><li><a href="#first">Haxe工具集</a><ul><li>Lime</li><li>OpenFL</li><li>Flixel</li><li>Flixel Tools</li></ul></li><li><a href="#second">VisualStudio</a></li><li><a href="#third">VisualStudioCode</a></li></ul><p><a name="first"><h2>安装Haxe工具集与其他依赖项</h2></a></p><p>首先，登陆Haxe的官网<a href="https://haxe.org/download/" target="_blank" rel="noopener">haxe.org</a>下载安装包，安装内容包括一个Haxe的跨平台编译器，一个标准库以及一个命令行工具“haxelib”，它是一个包管理工具，可以用于提交和检索可用的库，目前我只用它来安装一些依赖项而已，下面开始安装其他依赖项。</p><p>打开PowerShell或者CMD，依次执行以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">haxelib install lime</span><br><span class="line">haxelib install openfl</span><br><span class="line">haxelib install flixel</span><br></pre></td></tr></table></figure><p>注意：如果下载过程报错中断显示超时，那么搭个梯子试试或者在命令中加入参数<code>haxelib -notimeout &lt;command&gt;</code>以取消超时。</p><p>Lime是OpenFL用于跨平台编译的一个底层支持，主要用于给不同平台（如Flash，HTML5，C++）提供输入，音频，渲染上下文，网络访问提供统一的底层支持，具体的技术细节我也还没搞懂，所以就不多说了。</p><p>Flixel原本是由<a href="http://www.adamatomic.com/" target="_blank" rel="noopener">Adam “Atomic” Saltsman</a>以ActionScript3.0写就的一套Flash平台的游戏开发框架，由于后来Flash平台日渐衰落，所以喜爱Flixel的人就开始考虑把它移植到其他平台去，正巧Haxe社区已经有人做了Flash整个API的移植版本——也就是OpenFL，于是Flixel就顺其自然的被移植到了Haxe平台上，这样既能做到原来Flash平台做不到的跨平台开发（Adobe在Flash衰落的日子里主动放弃了很多跨平台的支持），同时又能让原来Flash平台上的开发者通过熟悉的API快速上手，投入Haxe平台的怀抱。</p><p>好了，一点点介绍说完了，当以上东西都下完之后再执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haxelib run lime setup flixel</span><br></pre></td></tr></table></figure><p>它会检查你的lime和opemfl是否为最新，以及其他Flixel相关的库（主要是插件，DEMO，UI，模板）。</p><p>如果你跑了以上命令，那么Flixel Tools已经被安装了，但是我们需要启动它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haxelib run flixel-tools setup</span><br></pre></td></tr></table></figure><p>它将会询问你两个问题：</p><p>是否使用命令别名（用于快捷输入，我都是启用的）：y/n</p><p>使用的默认IDE（我们使用VSCode，设置之后通过命令创建模板后将自动通过所选择的编辑器打开）：这里我们选择VisualStudioCode。</p><p>它同样也是一个命令行工具，之后我们新建项目或下载flixel相关的其他库都将通过它来完成。</p><p>到这里先通过几条指令来检查所有东西是不是都安装正确了：</p><p>依次执行以下指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lime</span><br><span class="line">flixel</span><br></pre></td></tr></table></figure><p>如果如下图所示则表明所需要的东西都安装完毕。</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/command.jpg" alt></p></div><p><a name="second"><h2>安装VisualStudio</h2></a></p><p>若想将游戏编译至C++平台上HaxeFlixel似乎只能用MSVC编译器，所以需要安装这个庞大的东西，那么上官网 <a href="https://visualstudio.microsoft.com/" target="_blank" rel="noopener">VisualStudo</a> ，目前推荐安装最新的 Community 2017 版。</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/VS2017.jpg" alt></p></div><p>下载完打开，然后选中如下图所示的勾选项</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/VSInstaller.jpg" alt></p></div><p>但其实我们需要的是VC++的编译器，所以也可以只勾选VC++ 2017 工具</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/VSInstaller2.jpg" alt></p></div><p>安装完直接把VS关掉就行。</p><p><a name="third"><h2>安装VisualStudioCode</h2></a></p><p>我们使用VisualStudioCode（VSCode）作为我们的代码编辑环境，同样登陆<a href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener">VS官网</a>，点击如下图所示下载VSCode：</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/VSCode.jpg" alt></p></div><p>安装完成后打开VSCode打开左侧边栏中的扩展：</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/VSCodeExtension.jpg" alt></p></div><p>如图所示搜索Haxe，选中Haxe Extension Pack并安装，之后再搜索Lime并安装Lime插件：</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/Lime.jpg" alt></p></div><p>完成后重启VSCode。</p><h2>测试项目</h2>至此万事俱备，我们再次打开PowerShell，输入以下指令新建一个HaxeFlixel项目：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flixel tpl &quot;default&quot; -n &quot;HelloWorld&quot;</span><br></pre></td></tr></table></figure><p>这里使用默认模板，并以”HelloWorld”命名在当前目录创建一个新的项目。命令<code>tpl</code>是<code>template</code>的别名，如果在<code>haxelib run flixel-tools setup</code>时启用了别名则可以使用<code>tpl</code>作为缩写快捷输入，default模板在我们执行<code>haxelib run lime setup</code>的时候下载好了，通过它我们可以在使用Flixel命令行工具创建项目时自动生成所需的配置文件，VSCode的配置文件存放于<code>.vscode</code>文件夹下，具体了解看官网文档，同样模板的自定义我自己也没研究过在这里就不讲了，官网资料或者论坛或者StackOverflow或其他什么方式，<strong>自己动手丰衣足食</strong>。</p><div align="center"><p><img src="//nulllstack.github.io/2018/09/05/时隔多日再水一篇/Complete.jpg" alt></p></div><p>动手检查一下Haxe插件是不是工作正常，主要是看看代码提示和补全，随便在那一行哪一个位置<code>Ctrl+Space</code>可以激活VSCode的IntelliSense，如果出现没有提示的情况，看看界面左下角是不是显示Building Cache，如果是这样的话参考我的上一篇博文。</p><p>到这里应该没什么问题了，如果我什么时候想起来要补充点什么再回来更新，晚安 :)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客本该在几日前写完的，开学前应一老友所需码一篇关于HaxeFlixel开发环境搭建的文章，无奈开学这两天没太适应过来拖延到今晚才开始有心情码字，实际发布时间会晚于tag所标示的时间。&lt;/p&gt;
&lt;p&gt;以下是本次要安装的各种工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>摸鱼一把</title>
    <link href="https://nulllstack.github.io/2018/08/16/%E6%91%B8%E9%B1%BC%E4%B8%80%E6%8A%8A/"/>
    <id>https://nulllstack.github.io/2018/08/16/摸鱼一把/</id>
    <published>2018-08-16T14:33:13.000Z</published>
    <updated>2018-08-16T14:55:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>解决了VSCode的Haxe插件时不时卡死building cache，导致代码提示功能无法正常工作的问题。</p><p>打开VSCode<code>文件 -&gt; 首选项 -&gt; 设置</code>在右边窗口用户设置内添加:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "haxe.buildCompletionCache" = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以覆盖默认设置，一个不知所云的热修复，问题暂时得到解决。</p><p>再就是搭建了一个Haxe的学习环境，<code>.vscode</code>文件夹下配置文件为：</p><p>task.json:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // See https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">    // for the documentation about the tasks.json format</span><br><span class="line">    "version": "2.0.0",</span><br><span class="line">    "tasks": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"compile"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"haxe"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"-main"</span>, <span class="string">"Main"</span>, <span class="string">"-cpp"</span>, <span class="string">"output"</span>, <span class="string">"-debug"</span>, <span class="string">"-lib"</span>, <span class="string">"hxcpp-debug-server"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"promptOnClose"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>launch.json:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    "version": "0.2.0",</span><br><span class="line">    "configurations": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"preLaunchTask"</span>: <span class="string">"compile"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Hxcpp"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"hxcpp"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceRoot&#125;/output/Main-debug.exe"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，博客的关于页上分享了我的邮箱地址，有兴趣交流的朋友可以通过邮箱地址联系我，其实只是想知道到底有多少人在看 = =</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解决了VSCode的Haxe插件时不时卡死building cache，导致代码提示功能无法正常工作的问题。&lt;/p&gt;
&lt;p&gt;打开VSCode&lt;code&gt;文件 -&amp;gt; 首选项 -&amp;gt; 设置&lt;/code&gt;在右边窗口用户设置内添加:&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
    
      <category term="学习记录" scheme="https://nulllstack.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程8:拾取物品</title>
    <link href="https://nulllstack.github.io/2018/08/05/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B8-%E6%8B%BE%E5%8F%96%E7%89%A9%E5%93%81/"/>
    <id>https://nulllstack.github.io/2018/08/05/HaxeFlixel官方教程8-拾取物品/</id>
    <published>2018-08-04T17:22:54.000Z</published>
    <updated>2019-09-12T17:52:57.679Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/pickups/" target="_blank" rel="noopener">原文</a></p><p>目前我们有一个小家伙可以在地图内自由行走，让我们为它添加一些可以拾取的东西。我们将要添加一些硬币，当玩家拾起的时候会计入分数。</p><ol><li><p>再一次打开你的Ogmo项目，然后打开<code>Project &gt; Edit Project</code>选项卡。</p></li><li><p>在‘Entities’选项卡内添加一个新的实体。</p></li></ol><div align="center"><p><img src="//nulllstack.github.io/2018/08/05/HaxeFlixel官方教程8-拾取物品/0014.png" alt></p></div><ol start="3"><li>选中 ‘entities’ 图层，在地图中散布一些硬币：</li></ol><div align="center"><p><img src="//nulllstack.github.io/2018/08/05/HaxeFlixel官方教程8-拾取物品/0015.png" alt></p></div><ol start="4"><li><p>我们将使用8x8像素作为硬币的大小，硬币的图像资源你可以使用这个<img src="//nulllstack.github.io/2018/08/05/HaxeFlixel官方教程8-拾取物品/coin.png" alt>,或者是你自己画一个，然后保存至<code>assets/images</code>文件夹下。</p></li><li><p>回到VSCode，新建一个新的类：</p></li></ol><div align="center"><p><img src="//nulllstack.github.io/2018/08/05/HaxeFlixel官方教程8-拾取物品/VSCode1.png" alt></p></div><div align="center"><p><img src="//nulllstack.github.io/2018/08/05/HaxeFlixel官方教程8-拾取物品/VSCode2.png" alt></p></div>6. Coin类十分简单，我们只需要修改一下构造函数：   <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>;</span><br><span class="line"><span class="keyword">import</span> flixel.FlxSprite;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coin</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">FlxSprite</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(X:<span class="type">Float</span>,Y:<span class="type">Float</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(X,Y);</span><br><span class="line">        loadGraphic(AssetPaths.coin__png,<span class="literal">false</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><p>现在回到<code>PlayState</code>类中，我们需要修改一下地图加载的逻辑代码，让它从Ogmo文件中加载实体时如果发现coin将会把<code>Coin</code>对象加入当前状态（state）。</p></li><li><p>首先让我们创建一个<code>FlxGroup</code>对象用于存储所有的硬币，在类中定义所有全局变量的地方添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _grpCoins:<span class="type">FlxTypedGroup</span>&lt;Coin&gt;</span><br></pre></td></tr></table></figure><p><code>FlxGroup</code>类似一个存储Flixel对象（Flixel Object）的数组，以供在许多需要的情况下使用，在这里我们用它来存储所有的硬币所以以<code>FlxTypedGroup&lt;Coin&gt;</code>形式声明。</p><p>在<code>create()</code>函数中位于初始化player之前，添加墙体之后的位置，我们从这里初始化硬币组（coin group）并将其添加至当前状态：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_grpCoins = <span class="keyword">new</span> <span class="type">FlxTypedGroup</span>&lt;Coin&gt;();</span><br><span class="line">add(_grpCoins);</span><br></pre></td></tr></table></figure></li><li><p>接下来我们需要修改<code>placeEntities()</code>函数，让其从Ogmo文件中读取到”coin“实体时将其添加进组中，位于我们的if语句的末尾添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(entityName == <span class="string">"coin"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _grpCoins.add(<span class="keyword">new</span> <span class="type">Coin</span>(x+<span class="number">4</span>,y+<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做将告诉程序创建一个coin对象，将其放置于Ogmo文件中所定义的位置（对其<code>x</code>值+4，<code>y</code>值+4，使得硬币位于瓦砖的居中位置），之后将这个coin对象添加进组。</p></li><li><p>现在我们需要player能够拾取这些硬币，我们将通过检查重叠情况（overlap）的方式来实现，在<code>update()</code>函数中位于<code>FlxG.collide()</code>调用之后的位置添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlxG.overlap(_player,_grpCoins,playerTouchCoin);</span><br></pre></td></tr></table></figure><p>这么做是告诉程序：在每一帧检查player与硬币组之间的重叠情况，如果发生重叠，则调用<code>playerTouchCoin()</code>函数。</p></li><li><p>现在我们来实现<code>playerTouchCoin()</code>回调函数：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playerTouchCoin</span></span>(P:<span class="type">Player</span>,C:<span class="type">Coin</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(P.alive &amp;&amp; P.exists &amp;&amp; C.alive &amp;&amp; C.exists)</span><br><span class="line">    &#123;</span><br><span class="line">        C.kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数检查player与硬币之间是否发生重叠且两者之间的alive与exists属性皆为true，如果是，则对硬币调用<code>kill()</code>函数（我们稍后会添加计分功能）。</p><p>如果你现在运行游戏，当你在地图内行走时触碰到的硬币将会消失。很好，但是有点无趣，让我们为其添加一点小样式。</p></li><li><p>回到<code>Coin</code>类中添加以下几个函数：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">kill</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    alive = <span class="literal">false</span>;</span><br><span class="line">    FlxTween.tween(<span class="built_in">this</span>,&#123;alpha: <span class="type">0</span>, y: <span class="type">y - 16</span>&#125;,<span class="number">.33</span>,&#123;ease: <span class="type">FlxEase</span>.circOut, onComplete: <span class="type">finishKill</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishKill</span></span>(<span class="literal">_</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    exists = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><p>目前为止遇到一些Haxe语法上的问题待解决暂时先翻译到这里，我先去看看Haxe官方的文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/pickups/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前我们有一个小家伙可以在地图内自由行走，让我们为它添加一些可以拾取的东西
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程7:摄像机与缩放</title>
    <link href="https://nulllstack.github.io/2018/08/02/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B7-%E6%91%84%E5%83%8F%E6%9C%BA%E4%B8%8E%E7%BC%A9%E6%94%BE/"/>
    <id>https://nulllstack.github.io/2018/08/02/HaxeFlixel官方教程7-摄像机与缩放/</id>
    <published>2018-08-02T09:33:46.000Z</published>
    <updated>2019-09-12T17:43:48.224Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/zoom-and-cameras/" target="_blank" rel="noopener">原文</a></p><p>当你开始运行你的游戏，你将会看到，目前场景内的所有东西看起开都非常非常小，我们将要通过设置缩放来改变游戏内物体的能见度，以此让玩家得以看清角色每个细微的动作。要做到缩放很简单：</p><ol><li><p>打开<code>Main.hx</code>文件，这个类用于游戏的初始化工作，如果你想要的话看看有哪些东西你需要修改的，但这里我们只需要改变其中的几个参数。</p></li><li><p>修改<code>new FlxGame()</code>的宽度与高度参数为<code>320</code>与<code>240</code>（原来的值的一半）。</p></li><li><p>如果你现在开始运行游戏，你将看到所有东西都被放大了，但是player会越出屏幕的可视范围，因此我们需要告诉摄像机紧跟player的当前位置，再一次打开<code>PlayState</code>文件。</p></li><li><p>在构造函数内，位于添加player之后，<code>super.create()</code>之前的位置添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlxG.camera.follow(_player,TOPDOWN,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这样做将会告诉摄像机以<code>TOPDOWN</code>视角跟踪player的位置，以1为取值赋给<code>lerp</code>参数（这样做将会让摄像机的移动更为平滑一些）</p></li></ol><p>完事了！测试游戏的运行结果看看效果如何。</p><div align="center"><p><img src="//nulllstack.github.io/2018/08/02/HaxeFlixel官方教程7-摄像机与缩放/results.png" alt></p><p>下一节，让我们为player添加一些可以在地图内拾起的东西。</p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/zoom-and-cameras/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当你开始运行你的游戏，你将会看到，目前场景内的所有东西看
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程6:加载Tilemap</title>
    <link href="https://nulllstack.github.io/2018/08/02/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B6-%E5%8A%A0%E8%BD%BDTilemap/"/>
    <id>https://nulllstack.github.io/2018/08/02/HaxeFlixel官方教程6-加载Tilemap/</id>
    <published>2018-08-02T08:07:00.000Z</published>
    <updated>2019-09-12T17:58:06.514Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/loading-the-tilemap/" target="_blank" rel="noopener">原文</a></p><p>搭配Ogmo与HaxeFlixel框架一起使用的其中一大好处就是它内置了一些类用于加载与使用tilemap，这些类并不是来自HaxeFlixel框架的标准库，所以我们需要安装 flixel-addons 库才能访问到这些类。</p><ol><li><p>打开命令提示符键入以下命令：</p><p><code>haxelib install flixel-addons</code></p><p>正确运行后haxelib命令行工具将会开始安装一个新的库，下载安装后关闭命令提示符。</p></li><li><p>回到 VisualStudio Code 中打开<code>Project.xml</code>文件，我们需要告诉我们的项目引入 flixel-addons 库。</p></li><li><p>查看如下所示的那一行（VSCode中可以按<code>F3</code>打开查找框，键入关键字符合条件的行会高亮显示）：</p><p><code>&lt;!--&lt;haxelib name=&quot;flixel-addons&quot; /&gt;--&gt;</code></p><p>修改为以下所示：</p><p><code>&lt;haxelib name=&quot;flixel-addons&quot; /&gt;</code></p><p>保存修改，现在你已经可以使用 flixel-addons 库了（在我这边最近VSCode的Haxe插件有点问题需要重启VSCode）。</p></li><li><p>回到<code>PlayState</code>类中，在<code>_player</code>变量的定义下方添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _map:<span class="type">FlxOgmoLoader</span>;</span><br><span class="line"><span class="keyword">var</span> _mWalls:<span class="type">FlxTilemap</span>;</span><br></pre></td></tr></table></figure><p><strong>备注：需要<code>import flixel.tile.FlxTilemap;</code>以及<code>import  flixel.addons.editor.ogmo.FlxOgmoLoader;</code>，从现在开始需要<code>import</code>新类的地方我不再提示，若自己动手的过程里出现找不到类之类的问题，检查是否忘记<code>import</code>了，不知道某个类在哪个包下就看看<a href="https://api.haxeflixel.com/flixel/addons/editors/tiled/TiledMap.html" target="_blank" rel="noopener">官方API文档</a>，搜索栏里找一下相关的类。</strong></p><p>这里我们告诉程序创建一个用于存储我们的 Ogmo map 的对象，然后再创建一个将从 Ogmo map 生成的<code>FlxTilemap</code>对象。</p><p>如果你现在使用的是Tiled作为创建地图的编辑器，把<code>_map</code>变量的类型改为<code>TileMap</code>。</p></li><li><p>在<code>create()</code>函数里，建立player对象之前的位置添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_map = <span class="keyword">new</span> <span class="type">FlxOgmoLoader</span>(AssetPaths.room_001__oel);</span><br><span class="line">_mWalls = _map.loadTilemap(AssetPaths.tiles__png,<span class="number">16</span>,<span class="number">16</span>,<span class="string">"walls"</span>);</span><br><span class="line">_mWalls.follow();</span><br><span class="line">_mWalls.setTileProperties(<span class="number">1</span>,FlxObject.NONE);</span><br><span class="line">_mWalls.setTileProperties(<span class="number">2</span>,FlxObject.ANY);</span><br><span class="line">add(_mWalls);</span><br></pre></td></tr></table></figure><p>这里将我们上一节中创建的地图文件加载进<code>FlxOgmoLoader</code>对象里，之后从它的 ‘walls’ 图层生成我们的<code>FlxTilemap</code>对象并设置其第1块瓦砖（序列图中表示地板的那一块）为不进行碰撞检测，第2块瓦砖（序列图中表示墙体的那块瓦砖）为从任意方向进行碰撞检测。接着将我们的 tilemap 添加进当前状态（PlayState）。</p><p>如果你使用的是Tiled，替换为以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_map = <span class="keyword">new</span> <span class="type">TiledMap</span>(AssetPaths.room_001__tmx)</span><br><span class="line">_mWalls = <span class="keyword">new</span> <span class="type">FlxTilemap</span>();</span><br><span class="line">_mWalls.loadMapFromArray(<span class="keyword">cast</span>(_map.getLayer(<span class="string">"walls"</span>), TiledTileLayer).tileArray, _map.width, _map.height, AssetPaths.tiles__png, _map.tileWidth, _map.tileHeight, FlxTilemapAutoTiling.OFF, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">_mWalls.follow();</span><br><span class="line">_mWalls.setTileProperties(<span class="number">2</span>, FlxObject.NONE);</span><br><span class="line">_mWalls.setTileProperties(<span class="number">3</span>, FlxObject.ANY);</span><br><span class="line">add(_mWalls);</span><br></pre></td></tr></table></figure></li><li><p>现在，我们需要把我们的player放置于地图中正确的位置上，所以下面把对player实例化的代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_player = <span class="keyword">new</span> <span class="type">Player</span>(<span class="number">20</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_player = <span class="keyword">new</span> <span class="type">Player</span>();</span><br><span class="line">_map.loadEntities(placeEntities,<span class="string">"entities"</span>);</span><br></pre></td></tr></table></figure><p>我们告诉<code>_map</code>对象遍历其‘entities’图层，并从中调用回调函数<code>placeEntities()</code>（我们稍后将实现这个函数）。</p><p><code>TiledMap</code>没有内置的<code>loadEntities()</code>函数，所以我们需要自己实现一个：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmpMap:<span class="type">TiledObjectLayer </span>= <span class="keyword">cast</span> _map.getLayer(<span class="string">"entities"</span>);</span><br><span class="line"><span class="keyword">for</span>(e <span class="keyword">in</span> tmpMap.object)</span><br><span class="line">&#123;</span><br><span class="line">    placeEntities(e.type,e.xmlData.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现在我们开始实现<code>placeEntities()</code>函数，当我们对地图调用<code>loadEntities()</code>函数的时候，它会传递一个实体的名字以及该实体的 XML 数据到某个我们需要的函数中。在我们的函数中我们需要利用这些信息做一些工作，代码如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">placeEntities</span></span>(entityName:<span class="type">String</span>,entityData:<span class="type">Xml</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x:<span class="type">Int </span>= Std.parseInt(entityData.<span class="keyword">get</span>(<span class="string">"x"</span>));</span><br><span class="line">    <span class="keyword">var</span> y:<span class="type">Int </span>= Std.parseInt(entityData.<span class="keyword">get</span>(<span class="string">"y"</span>));</span><br><span class="line">    <span class="keyword">if</span>(entityName == <span class="string">"player"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _player.x = x;</span><br><span class="line">        _player.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个函数被传递进一个实体的名字为“player”的时候，它会把player对象的<code>x</code>和<code>y</code>值设为该实体的<code>x</code>与<code>y</code>值（将他们的值从<code>String</code>类型转换为<code>Int</code>类型）。</p></li><li><p>现在我们需要为当前状态添加碰撞，以此让player遇到墙体的时候会一头撞上而不是穿行而过。在<code>update()</code>函数中，位于<code>super.update(elapsed);</code>的后一行的位置添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlxG.collide(_player,_mWalls);</span><br></pre></td></tr></table></figure><p>这行代码所做的事是在<code>update()</code>中不断检查player与墙体之间的重叠状态，如果当前两者有任何重叠的情况发生，那么两个对象将会自动分离开。</p></li><li><p>最后，我们需要对player进行一些微小的调整，让玩家以更好的时机越过大门是个好点子；默认情况下，我们的player sprite是与其瓦砖大小相同的（16x16像素），这会让player越过大门的时候仿佛需要挤过如针缝大小的门，我们通过改变sprite的大小与偏移量（offset）来补救这一问题。这么做并不会改变player实际显示的图像，只会改变其碰撞盒（hitbox）的大小。</p><p>在<code>Player</code>类的构造函数构造函数里，位于设置<code>drag</code>值的代码下方，添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setSize(<span class="number">8</span>,<span class="number">14</span>);</span><br><span class="line">offset.<span class="keyword">set</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>备注：依我的结果来看以上代码需要在<code>loadGraphic()</code>之后添加才能正确设置碰撞盒。由于我的<code>drag</code>放置的位置先与<code>loadGraphic()</code>所以按教程的步骤结果碰撞盒的位置并不正确</strong></p></li><li><p>现在运行你的项目，你已经能够控制player在地图内走动了。</p><div align="center"><p><img src="//nulllstack.github.io/2018/08/02/HaxeFlixel官方教程6-加载Tilemap/results.png" alt></p></div></li></ol><p>下一节，我们将对摄像机（camera）进行一些微调。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/loading-the-tilemap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搭配Ogmo与HaxeFlixel框架一起使用的其
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程5:创建Tilemap</title>
    <link href="https://nulllstack.github.io/2018/07/31/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B5-%E5%88%9B%E5%BB%BATilemap/"/>
    <id>https://nulllstack.github.io/2018/07/31/HaxeFlixel官方教程5-创建Tilemap/</id>
    <published>2018-07-31T09:23:09.000Z</published>
    <updated>2018-07-31T11:00:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/creating-a-tilemap/" target="_blank" rel="noopener">原文</a></p><p>现在，是时候为player创建一个可供活动的环境地图了！我们将使用一个叫 <em>Ogmo Editor</em> 的工具来创建 Tilemap；Ogmo是一个免费的 Tilemap编辑器，可以非常完美的与HaxeFlixel框架协作，对于这节教程而言，我们将创建一个只有 2块瓦砖 的 Tilesheet，用于表示墙体和地板。</p><p>你可以自己画一个16x16大小每块瓦砖的序列图，或者使用这里的图形资源：</p><p><img src="//nulllstack.github.io/2018/07/31/HaxeFlixel官方教程5-创建Tilemap/untitled.png" alt></p><p>（注意：该序列一共有3块tile，第一块tile应该是透明的）</p><ol><li><p>首先访问此链接：<a href="http://www.ogmoeditor.com/" target="_blank" rel="noopener">http://www.ogmoeditor.com/</a> 下载安装并运行编辑器。</p><p>注意：Ogmo 只有Windows版本，如果你想使用其他的编辑器，你可以试试<a href="http://www.mapeditor.org/" target="_blank" rel="noopener">Tile</a>，他也是一个免费的编辑器，但是功能稍微复杂一些。</p></li><li><p>从<code>Project &gt; New Project</code>创建并选择一个名称命名一个项目，保存至<code>assets/data</code>文件夹下。</p></li><li><p>按以下所示对每一个选项卡进行设置：</p><div align="center">![](HaxeFlixel官方教程5-创建Tilemap/1.png)<div align="center">![](HaxeFlixel官方教程5-创建Tilemap/2.png)<div align="center">![](HaxeFlixel官方教程5-创建Tilemap/3.png)<div align="center">![](HaxeFlixel官方教程5-创建Tilemap/4.png)<div align="center">![](HaxeFlixel官方教程5-创建Tilemap/5.png)</div></div></div></div></div></li><li><p>点击Apply保存你的修改，目前窗口应该如下所示：</p><div align="center">![](HaxeFlixel官方教程5-创建Tilemap/6.png)</div></li><li><p>确保你已选中“walls”图层，然后通过右边工具栏选择所需工具来绘制一个简单的地图。确保地图以walls瓦砖闭合（这样player就不能越出墙体的范围），并且以floor瓦砖将其填满。最后的地图应该如下所示：</p><div align="center">![](HaxeFlixel官方教程5-创建Tilemap/7.png)</div></li><li><p>现在切换至“entities”图层，然后将player瓦砖放置其中一个房间的某处：</p><div align="center">![](HaxeFlixel官方教程5-创建Tilemap/8.png)</div></li><li><p>通过<code>Level &gt; Save Level</code>保存，以<code>room-001.oel</code>命名，保存至<code>assets/data</code>文件夹内。</p></li><li><p>地图的创建工作到此就完成了，确保你已经保存修改，然后退出。</p></li></ol><p>下一节，我们将学习如何加载一个新创建的tilemap到游戏里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/creating-a-tilemap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在，是时候为player创建一个可供活动的环境地图
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>一点整理</title>
    <link href="https://nulllstack.github.io/2018/07/30/%E4%B8%80%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>https://nulllstack.github.io/2018/07/30/一点整理/</id>
    <published>2018-07-29T16:58:48.000Z</published>
    <updated>2018-07-30T10:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>对前面学习过程中感到疑惑的部分做了一些研究，在这里把这些东西记上一笔，加深印象同时便于日后查阅。</p><p>第3节基础工作中，对角色的移动通过给<code>FlxSprite</code>对象的<code>velocity</code>（继承自<code>FlxObject</code>类）属性进行赋值:<code>velocity.set(speed,0)</code>来实现，需要注意的是虽然<code>FlxSprite</code>对象的<code>velocity</code>属性是<code>FlxPoint</code>类型，但是它并不是用于表示当前<code>FlxSprite</code>对象的坐标点。</p><blockquote><p>HaxeFlixl对<code>FlxPoint</code>类型的描述：Stores a 2D floating point coordinate.（存储一个以浮点数表示的二维坐标系内的点的坐标）</p></blockquote><p>当通过<code>velocity.set(speed,0)</code>对<code>velocity</code>进行赋值之后，<code>FlxSprite</code>对象会以<code>speed</code>值作为x轴的速度，以<code>0</code>为y轴的速度进行移动，之后我们通过<code>velocity.rotate(FlxPoint.weak(0,0),angle)</code>对<code>velocity</code>的<code>x</code>和<code>y</code>进行旋转，<code>rotate()</code>函数具有两个参数，<code>Pivot</code>和<code>Angle</code>；这个函数通过一个给定的旋转支点对该<code>FlxPoint</code>对象以给定角度进行旋转，这里需要再强调一次，<strong>记住:<code>FlxSprite</code>的<code>velocity</code>属性不用于表示其坐标！而是表示该<code>FlxSprite</code>对象当前的x轴与y轴的移动速度</strong>；事实上当使用<code>FlxSprite</code>的<code>velocity</code>实现sprite的匀速运动时，还需要配合<code>FlxSprite</code>的另一个属性<code>drag</code>使用，该属性继承自<code>FlxObject</code>类，对其赋一个合适的值来使<code>velocity</code>归零，归零的速率由<code>drag</code>的取值决定；所以<code>velocity</code>的<code>x</code>,<code>y</code>值归零状态下都是在游戏画布的左上角（也就是<code>(0,0)</code>坐标点）也就是<code>velocity</code>的起点，那么当我们对其进行旋转时为了方便我们需要让旋转中心与<code>velocity</code>的起点重合，所以在使用<code>velocity.rotate()</code>时我们对第一个参数传递一个处于<code>(0,0)</code>坐标的<code>FlxPoint</code>对象作为对其进行旋转的旋转中心。</p><p>由于之前对<code>velocity</code>进行旋转操作时认为旋转中心应该位于sprite的中心位置，进而发现实验结果与期望不符，通过查阅官网的API文档有了以上的发现，下面让我们抛开<code>FlxSprite</code>的<code>velocity</code>属性，以一个普通的<code>FlxPoint</code>对象进行旋转操作加深理解：</p><ol><li><p>打开命令行窗口，输入<code>flixel template &quot;default&quot; -n &quot;FlxPointTest&quot;</code>之后<code>回车</code>，在当前目录下创建一个以默认模板生成并命名为“FlxPointTest”的HaxeFlixel项目。</p><p>之后自己画一个16x16大小的方块以PNG格式保存至项目文件夹下的assets/image文件夹内，图方便的话可以用我这里做好的：</p><div align="center">![](一点整理/Point.png)</div></li><li><p>然后在source文件夹内创建一个新的haxe文件，命名为Player.hx。然后拷贝我下面的代码进去：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> flixel.FlxSprite;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">FlxSprite</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(?X:<span class="type">Float</span>,?Y:<span class="type">Float</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(X,Y);</span><br><span class="line">        loadGraphic(AssetPaths.Point__png,<span class="literal">false</span>,<span class="number">16</span>,<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span></span>(elapsed:<span class="type">Float</span>):<span class="type">Void</span></span><br><span class="line"><span class="type">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.update(elapsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着修改source文件夹下的PlayState.hx：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> flixel.FlxState;</span><br><span class="line"><span class="keyword">import</span> flixel.FlxG;</span><br><span class="line"><span class="keyword">import</span> flixel.FlxGame;</span><br><span class="line"><span class="keyword">import</span> flixel.math.FlxPoint;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayState</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">FlxState</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> _player:<span class="type">Player</span>;</span><br><span class="line"><span class="keyword">var</span> blockSet:<span class="type">Array</span>&lt;Player&gt; = <span class="keyword">new</span> <span class="type">Array</span>();</span><br><span class="line"><span class="keyword">var</span> position:<span class="type">FlxPoint </span>= <span class="keyword">new</span> <span class="type">FlxPoint</span>(FlxG.width/<span class="number">2</span>,FlxG.height/<span class="number">2</span><span class="number">-64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">0.</span>.<span class="number">.4</span>)</span><br><span class="line">&#123;</span><br><span class="line">blockSet[i] = <span class="keyword">new</span> <span class="type">Player</span>(position.x,position.y);</span><br><span class="line">position.rotate(FlxPoint.weak(FlxG.width/<span class="number">2</span>,FlxG.height/<span class="number">2</span>),<span class="number">90</span>);</span><br><span class="line"><span class="built_in">trace</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">0.</span>.<span class="number">.4</span>)</span><br><span class="line">&#123;</span><br><span class="line">add(blockSet[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">super</span>.create();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span></span>(elapsed:<span class="type">Float</span>):<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line"><span class="keyword">super</span>.update(elapsed);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>blockSet</code>数组用于存储<code>Player</code>类的实例，<code>position</code>是一个<code>FlxPoint</code>类的实例，用于实例化<code>Player</code>实例的时候传入<code>Player</code>实例的初始坐标。</p><p>第一个循环体是这次实验的关键，创建四个<code>Player</code>实例，初始坐标使用<code>position</code>的<code>x</code>和<code>y</code>值，每个<code>Player</code>实例之间都以画布的中心位置为旋转点对position进行90度旋转。</p></li></ol><p>以下为运行结果：</p><div align="center">![](一点整理/results.png)</div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对前面学习过程中感到疑惑的部分做了一些研究，在这里把这些东西记上一笔，加深印象同时便于日后查阅。&lt;/p&gt;
&lt;p&gt;第3节基础工作中，对角色的移动通过给&lt;code&gt;FlxSprite&lt;/code&gt;对象的&lt;code&gt;velocity&lt;/code&gt;（继承自&lt;code&gt;FlxObje
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
      <category term="学习记录" scheme="https://nulllstack.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程4:精灵序列与动画</title>
    <link href="https://nulllstack.github.io/2018/07/27/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B4-%E7%B2%BE%E7%81%B5%E5%BA%8F%E5%88%97%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
    <id>https://nulllstack.github.io/2018/07/27/HaxeFlixel官方教程4-精灵序列与动画/</id>
    <published>2018-07-27T09:19:10.000Z</published>
    <updated>2018-12-23T13:44:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/sprites-and-animation/" target="_blank" rel="noopener">原文</a></p><p>目前，我们有了一个可以在屏幕中自由走动的 player 了，这很好，但是我们不希望它看起来只是一块蓝色方块，所以让我们为它添加一些图像。</p><p>首先选择一个你希望使用的图像编辑器（我用的是 <a href="https://www.aseprite.org/" target="_blank" rel="noopener">Aseprite</a> 在steam上可以购买）；你可以画任何你想要画的东西，然后把它保存为带透明通道的<code>.png</code>格式。我们的精灵序列将由16x16像素大小每帧组成，角色面朝四个可能的方向上都有两个不同的帧（面朝左和右我们将使用相同的两个帧，因为我们稍后会翻转它们）</p><p>你可以自己画，或者使用我朋友 Vicky Hedgecock 为这个教程创建的图像文件：</p><p><img src="//nulllstack.github.io/2018/07/27/HaxeFlixel官方教程4-精灵序列与动画/player.png" alt></p><p>将你的文件保存至<code>assets/images</code>文件夹下。</p><p>现在我们需要把 player 的图像文件加载进 sprite。所以再一次打开你的<code>Player</code>类。</p><ol><li><p>从构造函数中删掉<code>makeGraphic()</code>函数的调用，用以下代码取而代之：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadGraphic(AssetPaths.player_png,<span class="literal">true</span>,<span class="number">16</span>,<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>这样做将会告诉你的 sprite 使用<code>player.png</code>文件作为其显示用的图像，而且是带动画效果的，长和高为16像素。<strong>AssetPaths是一个由整洁的Haxe宏生成的类，它根据Project.xml的assets标签的内容构建变量。（由谷歌翻译，原句放下面）</strong>。宏稍微有些复杂，但是在某个节点上值得深入研究一下，但在这里我们先只是将<code>AssetPaths</code>视为一个便于在代码中引用我们资源文件的手段。</p><blockquote><p>原句：<code>AssetPaths</code> is a class generated by a neat <a href="http://haxe.org/manual/macro.html" target="_blank" rel="noopener">Haxe macro</a> which builds its variables from the contents of your <code>Project.xml</code>‘s assets tag.</p></blockquote></li><li><p>接下来，我们需要允许 sprite 基于其朝向进行翻转。这样做便于精灵序列节省一组朝向（只需要朝左）的帧，而不需要两组（既有朝左又有朝右）。</p><p>添加如下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setFacingFlip(FlxObject.LEFT,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">setFacingFlip(FlxObject.RIGHT,<span class="literal">true</span>,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>这两行代码意思是当 player 面朝左侧时不做任何翻转（因为我们的精灵序列里已经有面朝左侧的状态了），当 player 面朝右侧时进行水平翻转；如果我们想要的话，可以用相同的方式进行上下翻转。</p></li><li><p>现在我们需要基于精灵序列定义一组动画，在此例中我们要每个动画都以一个过渡动作（精灵序列中双脚平行的那一帧）结束动画序列的播放。因此需要在 player 每一段动画结束时都会返回至正确的帧。<br>添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animation.add(<span class="string">"lr"</span>,[<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>],<span class="number">6</span>,<span class="literal">false</span>);</span><br><span class="line">animation.add(<span class="string">"u"</span>,[<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>],<span class="number">6</span>,<span class="literal">false</span>);</span><br><span class="line">animation.add(<span class="string">"d"</span>,[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>],<span class="number">6</span>,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p> 对构造函数的修改到此就完成了，还有最后一步，修改<code>movement()</code>函数告诉 player sprite 作何朝向。所以，让我们对设置 player 角度的那节代码稍作修改，修改之后看起来如下所示：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mA:<span class="type">Float </span>= <span class="number">0</span>; <span class="comment">// 一个临时变量用于表示角度</span></span><br><span class="line"><span class="keyword">if</span> (_up)  <span class="comment">// 玩家按下UP键</span></span><br><span class="line">&#123;</span><br><span class="line">    mA = <span class="number">-90</span>; <span class="comment">// 将角度设为-90度 (时针12点的位置)</span></span><br><span class="line">    <span class="keyword">if</span> (_left)</span><br><span class="line">        mA -= <span class="number">45</span>; <span class="comment">// 如果玩家同时还按下了LEFT键, 则从目前的角度减去45度 - 这将会朝左上角移动</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_right)</span><br><span class="line">        mA += <span class="number">45</span>; <span class="comment">// 同上, 如果玩家同时还按下了RIGHT键, 则加45度 (往右上角移动)</span></span><br><span class="line">    facing = FlxObject.UP; <span class="comment">// sprite应该朝向上方</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_down) <span class="comment">// 玩家按下DOWN键</span></span><br><span class="line">&#123;</span><br><span class="line">    mA = <span class="number">90</span>; <span class="comment">// 将角度设为90度 (时针6点的位置)</span></span><br><span class="line">    <span class="keyword">if</span> (_left)</span><br><span class="line">        mA += <span class="number">45</span>; <span class="comment">// 当玩家同时按下LEFT按键则增加45度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_right)</span><br><span class="line">        mA -= <span class="number">45</span>; <span class="comment">// 或者当玩家按下RIGHT的话则减去45度</span></span><br><span class="line">    facing = FlxObject.DOWN; <span class="comment">// sprite朝向下方</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_left) <span class="comment">// 当玩家按下LEFT但没有按下UP或者DOWN时</span></span><br><span class="line">&#123;</span><br><span class="line">    mA = <span class="number">180</span>; <span class="comment">// 将角度设为180度 (时针9点钟位置)</span></span><br><span class="line">    facing = FlxObject.LEFT; <span class="comment">// sprite朝向左方</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_right) <span class="comment">// 玩家按下RIGHT但没有按下UP或DOWN时</span></span><br><span class="line">&#123;</span><br><span class="line">    mA = <span class="number">0</span>; <span class="comment">// 设角度为0度 (时钟3点钟位置)</span></span><br><span class="line">    facing = FlxObject.RIGHT; <span class="comment">// 设 sprite 朝向右方 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// determine our velocity based on angle and speed</span></span><br><span class="line"><span class="comment">// 基于angle与speed的值决定player的速度</span></span><br><span class="line">velocity.<span class="keyword">set</span>(speed, <span class="number">0</span>);</span><br><span class="line">velocity.rotate(FlxPoint.weak(<span class="number">0</span>, <span class="number">0</span>), mA);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> ((velocity.x != <span class="number">0</span> || velocity.y != <span class="number">0</span>) &amp;&amp; touching == FlxObject.NONE) <span class="comment">// 如果 player 是在移动的 (在任一坐标轴上的速度不为0), 我们需要改变 Player 的动画以契合它目前的朝向</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (facing)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> FlxObject.LEFT, FlxObject.RIGHT:<span class="type"></span></span><br><span class="line"><span class="type">            animation</span>.play(<span class="string">"lr"</span>);</span><br><span class="line">        <span class="keyword">case</span> FlxObject.UP:<span class="type"></span></span><br><span class="line"><span class="type">            animation</span>.play(<span class="string">"u"</span>);</span><br><span class="line">        <span class="keyword">case</span> FlxObject.DOWN:<span class="type"></span></span><br><span class="line"><span class="type">            animation</span>.play(<span class="string">"d"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 每当这个函数被调用，它将会检查当前哪一个方向的按键被玩家按下，并基于判断决定 sprite 目前应该是哪个朝向，应该使用哪段动画。</p></li><li><p>保存修改，然后运行项目你将看到你的 player 在运动时有了动画而且动画朝向正确。</p><p><img src="//nulllstack.github.io/2018/07/27/HaxeFlixel官方教程4-精灵序列与动画/untitled.png" alt></p></li></ol><p>下一节，我们将对地图与碰撞进行讨论。</p><hr><h3 id="次日更新"><a href="#次日更新" class="headerlink" title="次日更新"></a>次日更新</h3><p>补充：昨晚检查运行结果发现sprite的动画实际与教程中所述有出入，事实上在<code>animation.add()</code>添加动画时，若传递的<code>Looped</code>参数值为<code>false</code>那么当调用<code>animation.play()</code>时动画序列会根据<code>Frames</code>参数传入的值，定义动画序列，逐帧播放一次，最后止于最后一帧的位置，如教程中角色朝向左右两方时使用的是<code>animation.add(&quot;lr&quot;,[3,4,3,5],6,false)</code>这样的调用，其<code>Frames</code>参数传递的是一个<code>Array</code>类型的值：<code>[3,4,3,5]</code>，用于表示角色朝向左右两方时使用的动画序列，且<code>Looped</code>值为<code>false</code>这意味着动画不循环播放，那么当玩家按压左右方向键时sprite会按精灵序列图的第3，4，3，5帧顺序播放，当玩家松开按键时动画会从当前帧继续播放至第5帧后停止，再举个例子当player朝向上方时根据教程给出的定义，<code>animation.add(&quot;u&quot;,[6,7,6,8],6,false)</code>如此<code>Frame</code>值为<code>[6,7,6,8]</code>那么当玩家释放上方向键时sprite的动画会播放至第8帧的位置停止；player面朝下方时定义的动画序列为<code>[0,1,0,2]</code>，当玩家松开按键时动画播放至第2帧位置后停止。</p><p>为解决这个问题我翻找了一下原教程的项目源码，发现不知道是原作者疏忽还是在教程后续才补充的原因，总之在这一节教程中漏了一段代码，这段代码用于实现这一节教程所说的 <strong>“我们要每个动画都以一个过渡动作（精灵序列中双脚平行的那一帧）结束动画序列的播放。因此需要在 player 每一段动画结束时都会返回至正确的帧。”</strong>，那么下面给出解决这个小bug的方法：</p><p>在<code>Player</code>类中判定用户输入的那条条件语句<code>if(_up || _down || _left || _right)</code>之后的位置添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(animation.curAnim != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    animation.curAnim.curFrame = <span class="number">0</span>;</span><br><span class="line">    animation.curAnim.pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>curAnim</code>表示当前使用的是那一段动画序列（此节教程中定义了三段动画序列分别是 “lr”，”u”，”l”），<code>curFrame</code>表示当前动画序列的哪一帧（动画序列的帧索引从0开始）。</p><p>注意：<code>curFrame</code>并不表示整个精灵序列的帧索引，而是通过<code>animation.add()</code>定义的动画序列的帧索引，比如通过<code>animation.add(&quot;lr&quot;,[3,4,3,5],6,false</code>添加的动画序列有4帧，那么当sprite使用<code>lr</code>这段动画序列时对<code>animation.curAnim.curFrame</code>赋值为0，sprite实际上显示的是整张精灵序列的第3帧的图像。</p><p>所以这段代码的意思就是当玩家不按压任何移动按键时则判断当前动画序列是否<strong>不为</strong><code>null</code>，是则将当前动画序列的当前帧设为0，并暂停动画序列的播放。由于三段动画序列的第一帧位置分别是：3，6，0 ，也就是精灵序列中角色立定状态的图像，所以当玩家不进行任何移动操作时，sprite的动画都能返回至正确的帧（立定状态）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/sprites-and-animation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前，我们有了一个可以在屏幕中自由走动的 pl
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程3:基础工作</title>
    <link href="https://nulllstack.github.io/2018/06/14/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B3-%E5%9F%BA%E7%A1%80%E5%B7%A5%E4%BD%9C/"/>
    <id>https://nulllstack.github.io/2018/06/14/HaxeFlixel官方教程3-基础工作/</id>
    <published>2018-06-13T17:11:48.000Z</published>
    <updated>2018-07-29T07:36:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/groundwork/" target="_blank" rel="noopener">原文</a></p><p>现在，是时候思考一下我们要做什么样的游戏，以及我们要如何去实现。</p><p>我们将要做一个十分简单的回合制的“地牢行者（dungeon crawler）”小游戏，玩家将控制一个角色在地图内自由行走，与敌人战斗并收集金币。</p><p>所以，我们要如何将这些设计转换到 HaxeFlixel 中实现？</p><ul><li>首先，我们需要我们需要为我们的游戏建立一个“世界” - 也就是说我们需要一个<code>FlxState</code>对象作为一个容纳游戏内容的容器。</li><li>接着是地牢的设计，我们将使用<code>FlxTilemap</code>对象来表示地牢，地牢的地图我们会使用另一个工具来绘制</li><li>我们将使用一个<code>FlxSprite</code>对象来表示玩家的角色，他是一个被玩家控制的精灵序列（sprite）。</li><li>敌人也是使用<code>FlxSprite</code>对象来表示，而且我们将会用一种特别的方式实现几种不同类型的敌人。</li><li>我们当然还需要一套 HUD/界面接口 用于方便玩家知道自己做了哪些事情产生了哪些结果。我们将通过组合<code>FlxGroup</code>，<code>FlxSprite</code>，<code>FlxText</code>，<code>FlxButton</code>对象与其他一些东西来实现。</li></ul><p>我们将会把以上这些工作一个一个实现。</p><p>首先，让我们先来创建一个简单的菜单，在最后我们会实现一个复杂的<code>MenuState</code>提供按钮以实现更多选项，但是目前我们只需要一个显式“Play”的按钮其功能将实现从菜单切换至<code>PlayState</code>。</p><ol><li><p>删除我们前面为<code>PlayState</code>添加的”Hello World”测试的代码。</p><p>现在在<code>PlayState.hx</code>文件所在的同一个文件夹下创建一个新的文件命名为<code>MenuState.hx</code>（<strong>未填写</strong>）。然后你只需要把<code>PlayState.hx</code>中的代码拷贝进这个文件里（但是把类名改为<code>MenuState</code>）：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuState</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">FlxState</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br></pre></td></tr></table></figure><p>在类声明之后，我们要定义一个新的变量，你在想要在这个类的任何位置中使用的变量都应该在这个地方定义，我们现在要定义一个<code>FlxButton</code>类型的变量，作为我们的“Play”按钮，所以在这个位置输入：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _btnPlay:<span class="type">FlxButton</span>;</span><br></pre></td></tr></table></figure><p>注意：如果你使用的是 FlashDevelop ，那么现在IDE会因为你的<code>FlxButton</code>变量的定义而自动在类声明的上方加入一段 import 代码（<code>import flixel.ui.FlxButton;</code>），如果跟我一样是用 VSCode 的话那就自己手动码一下吧。</p></li><li><p>现在，在<code>create()</code>函数里位于<code>super.create()</code>的前一行敲入以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_btnPlay = <span class="keyword">new</span> <span class="type">FlxButton</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="string">"play"</span>,clickPlay);</span><br><span class="line">add(_btnPlay);</span><br></pre></td></tr></table></figure><p>这将会创建一个<code>FlxButton</code>对象并赋值给<code>_btnPlay</code>变量，我们告诉他要在<code>(0,0)</code>坐标位置（在游戏画面的左上角）处创建一个按钮，并在其上显示 “Play” ，当玩家点击它时，调用<code>clickPlay()</code>函数（我们暂时还没有实现<code>clickPlay()</code>函数），然后将这个对象添加到舞台上以显示与交互。暂时不要担心按钮的位置，我们稍后将会调整。</p></li><li><p>接下来我们需要定义<code>clickPlay()</code>函数，在类体内那个地方都行，但不要位于其他函数体内的位置，敲入以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clickPlay</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    FlxG.switchState(<span class="keyword">new</span> <span class="type">PlayState</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数里它调用了<code>FlxG.switchState()</code>，它的工作是从当前的状态（目前而言也就是<code>MenuState</code>）切换状态至一个新的<code>PlayState</code>实例。</p></li><li><p>从技术上讲，目前为止我们所要实现的功能已经能正常工作了，你可以运行游戏并且会按我们的预期工作，但是我们还差几件事情没有做。首先，我们的按钮需要放置在一个更合理的位置，我们当然可以在创建按钮对象的时候通过传递 x 和 y 坐标值的方式来定义它的位置，但是这里有一个更简单的方法，回到<code>create()</code>函数里，在我们创建<code>FlxButton</code>对象之后，<code>super.create()</code>之前的位置（我会放在按钮对象被到舞台上之前的位置，但是这行代码放在其之后结果也是一样的）添加一行新的代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_btnPlay.screenCenter();</span><br></pre></td></tr></table></figure><p><code>screenCenter()</code>函数的功能是将对象的坐标放在水平或垂直抑或（默认的）这两个方向上的中心位置。调用我们的按钮对象上的这个函数，它将会被放置于游戏画面的中心位置。</p></li><li><p>然后我们需要确保游戏是从<code>MenuState</code>状态启动的。打开<code>Main.hx</code>文件，把对<code>PlayState</code>的引用替换成<code>MenuState</code>。</p></li><li><p>如果你开始启动调试，它会显示一个黑色画面，其中间是我们的 “Play” 按钮，点击它会跳转到另一个黑色画面。如果你的结果如上所述，那么就表示一切正常！GREAT！</p></li></ol><p>之后我们还需要创建一个能够在画面里自由行走的简单的 player 精灵（player sprite)。</p><p>首先，我们需要创建一个新的<code>Player</code>类，你可以把类理解为一个容纳了一系列函数的模板，你可以在项目中使用它们，而且还能够通过继承（extend）变为一个新的版本，你可以把继承理解成描摹纸（小时候描画的那种几乎透明的很薄的纸），当你要对一个类进行继承的时候，就类似于你铺了一张新的描摹纸在它上面 - 你依然可以看到上一张纸的内容并且能够描下来，而且你还能在其上添加更多新的东西。</p><p>我们将要通过继承<code>FlxSprite</code>类来创建我们自己的<code>Player</code>类。</p><ol><li><p>在资源管理器里，右键点选 source 文件夹然后点击创建文件：</p><p><img src="//nulllstack.github.io/2018/06/14/HaxeFlixel官方教程3-基础工作/img1.jpg" alt></p><p>新文件命名为<code>Player.hx</code>然后双击打开。</p></li><li><p>由于 VSCode 环境下目前我还不知道有什么方法可以通过UI界面选择一个文件的父类再自动生成文件，所以下面需要手动敲码。</p></li><li><p>正确添加之后界面大概会像这样：</p><p><img src="//nulllstack.github.io/2018/06/14/HaxeFlixel官方教程3-基础工作/img2.jpg" alt></p></li><li><p>然后在<code>Player.hx</code>文件里敲入以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> flixel.FlxSprite;</span><br><span class="line"><span class="keyword">import</span> flixel.system.FlxAssets.FlxGraphicAsset;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">FlxSprite</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(?X:<span class="type">Float</span>=<span class="number">0</span>, ?Y:<span class="type">Float</span>=<span class="number">0</span>, ?SimpleGraphic:<span class="type">FlxGraphicAsset</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(X,Y,SimpleGraphic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个标准的<code>FlxSprite</code>子类的结构，我们为了使用需要稍微修改一下。</p></li><li><p>首先，去掉构造函数的<code>SimpleGraphic</code>参数，我们的<code>Player</code>精灵用不着这个参数。</p><p>所以：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(?X:<span class="type">Float</span>=<span class="number">0</span>, ?Y:<span class="type">Float</span>=<span class="number">0</span>, ?SimpleGraphic:<span class="type">FlxGraphicAsset</span>)</span><br></pre></td></tr></table></figure><p>改写成：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(?X:<span class="type">Float</span>=<span class="number">0</span>, ?Y:<span class="type">Float</span>=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>还有：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>(X,Y,SimpleGraphic);</span><br></pre></td></tr></table></figure><p>改写成：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>(X,Y);</span><br></pre></td></tr></table></figure><p>在类里面，我们使用 “super” 关键字来引用父类。所以在我们的 <code>new()</code>/构造函数 中，通过调用<code>super(X,Y)</code>我们是表示将它关联至父类，此例中也就是<code>FlxSprite</code>类，并调用父类构造函数，把传递给我们的 <code>X</code> 和 <code>y</code> 也传递给父类构造函数。</p><p>这里有点细节：<a href="https://www.kancloud.cn/simon_chang/haxe3manual/184189" target="_blank" rel="noopener">Haxe中的继承</a></p></li><li><p>然后我们为了知道我们的精灵在哪我们为它创建一个 占位符图像（placeholder image），所以在<code>super(X,Y)</code>之后添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeGraphic(<span class="number">16</span>,<span class="number">16</span>,FlxColor.BLUE);</span><br></pre></td></tr></table></figure><p>（注意添加<code>import</code>代码导入<code>FlxColor</code>类：<code>import flixel.util.FlxColor;</code>）</p><p>我们这里所做的事情是把这个对象创建为一个 16x16 大小的蓝色放块。</p></li><li><p>现在我们要创建<code>Player</code>对象的实例确保这个对象能够正常工作，并把它添加到<code>PlayState</code>状态里。它暂时还不能移动或做其他任何事情，这个我们稍后会实现它，现在先保存<code>Player.hx</code>文件（<code>Ctrl+S</code>），然后回到<code>PlayState</code>文件里，我们要定义一个<code>Player</code>类的变量，在类体第一行位置添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _player:<span class="type">Player</span>;</span><br></pre></td></tr></table></figure><p>然后在<code>creat()</code>函数里<code>super.create()；</code>之前：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_player = <span class="keyword">new</span> <span class="type">Player</span>(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">add(_player);</span><br></pre></td></tr></table></figure><p>这里所做的事情很简单，为我们的<code>_player</code>变量赋值了一个<code>Player</code>类的实例，告诉他放在<code>(20,20)</code>坐标位置处，并把它添加进<code>PlayState</code>状态里。</p></li><li><p>如果你现在开始调试（可以通过<code>F5</code>打开调试），点击“Play”按钮你应该能看到以下运行结果：</p><p><img src="//nulllstack.github.io/2018/06/14/HaxeFlixel官方教程3-基础工作/img3.jpg" alt></p><p>接下来我们来实现移动功能！</p></li></ol><p>我们要如何实现player在画面中自由走动的功能？我们要同时支持方向键与 WASD 键实现8个方向上的移动：上，下，左，右以及对角方向。玩家会以一个相对固定的速度移动，但是在停下来的时候会有一个轻微的减速效果来丰富交互体验。</p><p>首先，我们先为 player 定义一个移动速度以及一个减速度量：</p><ol><li><p>在<code>Player</code>类里面，构造函数的上一行添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> speed:<span class="type">Float </span>= <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>接着在构造函数里，位于<code>makeGraphic()</code>的调用之前的位置，我们需要加入一点<code>drag</code>（这是一个<code>FlxSprite</code>对象的属性，我不知道怎样翻译比较准确，大概就是可以产生一个拖曳效果）：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drag.x = drag.y = <span class="number">1600</span>;</span><br></pre></td></tr></table></figure><p>在 HaxeFlixel 中<code>drag</code>是实现当对象停止移动时产生减速运动的方式之一。它可以帮助我们当玩家停止按压任何移动按键时，阻止 player 精灵一直朝某个方向移动，我们稍后会调整<code>drag</code>的数值。</p></li><li><p>尽管处理 player 运动的方式有多种多样，但我们可以简单的把处理运动的功能放在 player 类里边；我们要添加几个函数用于跟踪玩家的输入并给予反馈，敲入代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">movement</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>在这个函数里，我们将定义一组辅助变量用于在之后的代码里表示当前哪个按键被玩家按压：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _up:<span class="type">Bool </span>= <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> _down:<span class="type">Bool </span>= <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> _left:<span class="type">Bool </span>= <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> _right:<span class="type">Bool </span>= <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>接下来我们要知道玩家希望朝哪个方向移动，我们通过检查当前处于按压状态的按键来获知：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_up = FlxG.keys.anyPressed([UP,W]);</span><br><span class="line">_down = FlxG.keys.anyPressed([DOWN,S]);</span><br><span class="line">_left = FlxG.keys.anyPressed([LEFT,A]);</span><br><span class="line">_right = FlxG.keys.anyPressed([RIGHT,D]);</span><br></pre></td></tr></table></figure><p><code>anyPressed()</code>函数可以获取列表中的按键目前是否处于按压状态；通过传递一个键值数组（数组元素就是按键的名字）当数组中任何一个按键被按压时它会返回<code>true</code>。稍后我们还会使用其他几个类似的函数来检查其他的按键状态。</p></li><li><p>接下来我们需要处理方向冲突的情况，比如当玩家同时按下上和下时，player 会原地不动：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_up &amp;&amp; _down)</span><br><span class="line">&#123;</span><br><span class="line">    _up = _down = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(_left &amp;&amp; _right)</span><br><span class="line">&#123;</span><br><span class="line">    _left = _right = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来我们要完善真正实现 player 移动的代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_up || _down || _left || _right)</span><br></pre></td></tr></table></figure></li><li><p>然后我们要确定 player 以多快的速度朝哪个方向移动，通常很多第一次实现此类功能的人会下意识的觉得这里开始应该这样实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">velocity.x = speed;</span><br><span class="line">velocity.y = speed;</span><br></pre></td></tr></table></figure><p>尽管技术上讲这样做确实能够使某个物体实现上下左右方向的移动，但是这样做会使得对角方向的移动比上下左右的移动速度更快；可以试想一下矩形的对角线肯定比矩形的任何一条单边更长。这里我们应该使用一点三角函数的知识来计算每个方向的移动速度。</p><p>我们首先需要知道当玩家按下按键时 player 朝向哪个方位角，对于<code>FlxSprite</code>对象而言，0度角朝向右边，而 -90度（或 270度） 则是朝向上（也就是说正角是顺时针方向的，这一点与数学上的定义有些出入）。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mA:<span class="type">Float </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(_up)</span><br><span class="line">&#123;</span><br><span class="line">    mA = <span class="number">-90</span>;</span><br><span class="line">    <span class="keyword">if</span>(_left)</span><br><span class="line">    mA -= <span class="number">45</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(_right)</span><br><span class="line">    mA += <span class="number">45</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(_down)</span><br><span class="line">&#123;</span><br><span class="line">    mA = <span class="number">90</span>;</span><br><span class="line">    <span class="keyword">if</span>(_left)</span><br><span class="line">    mA += <span class="number">45</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(_right)</span><br><span class="line">    mA -= <span class="number">45</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(_left)</span><br><span class="line">mA = <span class="number">180</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(_right)</span><br><span class="line">mA = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这里所做的事情是创建了一个临时变量用于保存我们的角度，然后基于玩家当前按压的按键改变其角度值。</p></li><li><p>现在我们知道了 player 应该朝哪个方位角移动，之后我们还需要知道以多少速率（velocity）朝这个方向移动，我们通过为<code>velocity.x</code>赋值<code>speed</code>与<code>velocity.y</code>赋值<code>0</code>，然后围绕<code>(0,0)</code>坐标对这个点（point：<code>velocity</code>是一个<code>FlxPoint</code>对象）进行<code>mA</code>度的旋转来实现。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">velocity.<span class="keyword">set</span>(speed,<span class="number">0</span>);</span><br><span class="line">velocity.rotate(FlxPoint.weak(<span class="number">0</span>,<span class="number">0</span>),mA);</span><br></pre></td></tr></table></figure><p>最后闭合<code>if</code>语句的花括号，然后…这就是<code>movement()</code>函数的所有逻辑代码了。</p></li><li><p>最后剩下的一件事情就是<code>override</code>重写<code>update()</code>函数，在里面调用我们的<code>movement()</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override public function update(elapsed:Float):Void</span><br><span class="line">&#123;</span><br><span class="line">    movement();</span><br><span class="line">    super.update(elapsed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你要记住，<code>update()</code>函数在游戏运行中是每帧调用一次的，所以每当<code>PlayState</code>的<code>update()</code>被调用时，也会调用它所有成员的<code>update()</code>函数这其中包括我们的 player 对象的<code>update()</code>函数。如此一来也会调用我们的<code>movement()</code>逻辑，相应地调整player的<code>velocity</code>属性值，接着他会调用<code>super.update()</code>，这会将刚刚修改过的<code>velocity</code>的值用于计算精灵（player sprite）的下一个位置。</p></li></ol><p>哇哦~ 看起来似乎步骤比实际功能要更繁琐一些。如果你现在尝试运行游戏看看结果如何，你将发现你能够使用方向键和WASD键控制 player 在屏幕中游走了。</p><p>下一节我们将开始创建一个 精灵序列（sprite sheet） 让 player 看起来更地道一些！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/groundwork/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在，是时候思考一下我们要做什么样的游戏，以及我们要如何去实现。&lt;/
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程2:创建项目</title>
    <link href="https://nulllstack.github.io/2018/06/12/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B2-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
    <id>https://nulllstack.github.io/2018/06/12/HaxeFlixel官方教程2-创建项目/</id>
    <published>2018-06-12T05:22:13.000Z</published>
    <updated>2018-06-12T15:45:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于官网教程使用的环境是 HaxeDevelop/FlashDevelop IDE 作为代码的编辑，调试环境，而我是使用 VSCode ，所以环境的搭建我打算另外做一篇教程，并且在必要的时候对系列教程的原文稍作修改以适应我所使用的环境，而官网的教程我就直接从创建项目的部分开始搬运。</p></blockquote><p><a href="http://haxeflixel.com/documentation/creating-a-new-project/" target="_blank" rel="noopener">原文</a></p><h3 id="2-创建一个新的项目"><a href="#2-创建一个新的项目" class="headerlink" title="2-创建一个新的项目"></a>2-创建一个新的项目</h3><p>现在我们要确定我们需要的东西都安装妥当，并为我们的游戏建立所需的框架。所以我们首先创建一个新的项目，使用 VSCode 打开项目并测试它是否正常构建并运行程序。</p><ol><li><p>在命令行窗口（<code>开始-运行-cmd-回车</code>）敲入以下指令：</p><p><code>flixel tpl -n &quot;FlixelTut&quot;</code></p><p>这个指令会在当前目录使用一个空白的模板创建一个新的 Flixel 项目并放置于 FlixelTut 文件夹内（因为我们以 FlixelTut 命名了该项目）</p></li><li><p>如果你跟我一样使用 VSCode 作为开发环境，并且在 <code>haxelib run flixel-tools setup</code> 的时候配置了 VSCode 作为 flixel 创建项目的默认编辑器，并设置为创建新模板或 Demo 时自动启动，那么现在 VSCode 会自动启动并打开该项目。</p></li><li><p>打开 VSCode 的资源管理器。</p></li><li><p>在资源管理器里，你能够看到项目的结构，包含了模板为我们生成的所有文件。</p><p><img src="//nulllstack.github.io/2018/06/12/HaxeFlixel官方教程2-创建项目/img1.JPG" alt></p></li><li><p>接下来我们要确定我们的项目能够正确的构建与运行。默认情况下，一个崭新的 Flixel 模板项目会从 PlayState 启动游戏。所以从资源管理器双击打开 source 文件夹下的 PlayState 文件。这是一个十分基础的 FlxState 子类的实例。你可以设想一下把 FlxState 看作是一个 “场景（scenes）” 。当你的游戏开始运行时有且只有一个 “状态（state）” 处于活动状态。玩家看得见摸得着的东西都是被“添加（added）”进该状态的，并且通常会把不共享资源的状态相互隔离。</p><p>通常相互隔离的状态负责游戏的不同部分，比如游戏的开始菜单（MenuState）与游戏状态（PlayState），这些状态之间的关系有点像一个个泡泡（这个实在不知道如何翻译）</p><blockquote><p>They are great for having different sections of your game that are sort of in a bubble from one another, such as a <code>MenuState</code> (which we will add later) and the <code>PlayState</code> (where the game is actually played).</p></blockquote><p>稍后你将会看到，但目前为止 PlayState 只有包含了两个函数：<code>create()</code> 与 <code>update()</code>函数。当一个状态被加载进来，他的<code>create()</code>函数会立即被调用。你应该在这里对状态做一些初始化工作。</p><p><code>update()</code> 是所有奇妙的事物发生的地方，他会在游戏运行时按每帧一次的频率调用（默认情况下游戏是 每秒60帧 - 60fps）。当一个 <code>FlxState</code> 对象的 <code>update()</code> 被调用时，它也会调用被添加进该状态的对象的 <code>update()</code> 函数。这基本上就是你的游戏背后的工作原理。稍后我们会更详细的讨论。现在，我们只是想看看我们搭建的东西是不是能够正常运行，所以接下来让我们添加一个简单的 <code>FlxText</code> 对象到这个状态里。</p></li><li><p>在文件的最上方，位于 <code>import flixel.FlxState;</code> 这一行下方添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flixel.text.FlxText;</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>在 <code>create()</code> 函数里，位于 <code>super.create();</code> 的前一行的位置添加以下代码:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="keyword">new</span> <span class="type">FlxText</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="string">"Hello, World!"</span>));</span><br></pre></td></tr></table></figure><p>然后保存你的修改（<code>Ctrl + s</code>）</p></li><li><p>The Moment of Truth! 点击 VSCode 左侧的小虫子图标打开调试窗口，然后点击绿色小箭头。</p><p><img src="//nulllstack.github.io/2018/06/12/HaxeFlixel官方教程2-创建项目/img2.jpg" alt></p><p>如果你看到以下结果那么一切都很顺利：</p><p><img src="//nulllstack.github.io/2018/06/12/HaxeFlixel官方教程2-创建项目/img3.jpg" alt></p><p>行了！你成功构建并运行了你的第一个 HaxeFlixel 项目！</p><blockquote><p>“Big things have small beginnings.”  —— 《Prometheus》</p></blockquote><p>下一节，我们将正式为我们的游戏做一些设计，并开始把每个设想实现整合。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;由于官网教程使用的环境是 HaxeDevelop/FlashDevelop IDE 作为代码的编辑，调试环境，而我是使用 VSCode ，所以环境的搭建我打算另外做一篇教程，并且在必要的时候对系列教程的原文稍作修改以适应我所使用的环境，而官网的教程
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程:开篇</title>
    <link href="https://nulllstack.github.io/2018/06/11/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B-%E5%BC%80%E7%AF%87/"/>
    <id>https://nulllstack.github.io/2018/06/11/HaxeFlixel官方教程-开篇/</id>
    <published>2018-06-11T15:39:01.000Z</published>
    <updated>2018-06-11T15:42:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/tutorial/" target="_blank" rel="noopener">原文</a></p><p>欢迎来到 HaxeFlixel ！在这系列教程中，你将学习如何使用 HaxeFlixel 从头到尾创建一个完整的游戏，每一步骤都会被打碎成小片段以帮助你度过难关。</p><p>这一系列教程可以面向 Flash，Windows，Aandroid 进行构建。但我们多数时候是编译到 Flash 平台。</p><p>我们将要搭建一个 <strong>dungen crawler</strong> 小游戏。</p><p>首先，让我聊一点关于为何你应该选择 HaxeFlixel :</p><p>HaxeFlixel 的由来要追溯到由 <a href="http://www.adamatomic.com/" target="_blank" rel="noopener">Adam ‘Atomic’ Saltsman</a> 开发的 <a href="http://flixel.org/" target="_blank" rel="noopener">AS3 Flixel 框架</a>。如果你有玩过 <a href="http://www.adamatomic.com/canabalt/" target="_blank" rel="noopener">Canabalt</a>，那么你就见过过了这个框架的早期版本。HaxeFlixel 继承了 Flixel 的一般结构，从 Flash 平台分离出来并整合进强大的开源多平台语言 <a href="http://haxe.org/" target="_blank" rel="noopener">Haxe</a> 中，所以你编写的游戏就可以简单的发布到各个平台上（Windows，Flash，iOS，Android等）。</p><p>当你使用 HaxeFlixel 编写代码时尽管有些变化但与编写 AS3 代码没有太多差别。此外它拥有大量的内置特性 - 类，实用程序，以及函数 - 当你碰上一些常见或复杂的事情时它们可以帮你解决。并且因为 HaxeFlixel 是开源的，当你发现某些事情它做不到，那你可以修改它的源码，同时如果你的修改对其他人是有帮助的，可以把它们<a href="http://haxeflixel.com/documentation/contributing/" target="_blank" rel="noopener">添加进 library</a>。</p><p>它是一个简单易用的代码库（library），而且给予了你足够的自由去实现你能够想到的任何事情，却不会被死板的接口而限制住。</p><p>你可以从这里了解到更多有关于 HaxeFlixel ：<a href="http://haxeflixel.com/documentation/about/" target="_blank" rel="noopener">链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/tutorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎来到 HaxeFlixel ！在这系列教程中，你将学习如何使用 Ha
      
    
    </summary>
    
    
    
      <category term="HaxeFlixel" scheme="https://nulllstack.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld!</title>
    <link href="https://nulllstack.github.io/2018/06/10/HelloWorld/"/>
    <id>https://nulllstack.github.io/2018/06/10/HelloWorld/</id>
    <published>2018-06-10T14:06:04.000Z</published>
    <updated>2018-06-10T14:43:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>折腾了两天，总算是把博客重新部署回来了，博客的订阅源算是可以用了，欢迎视奸 :) 。</p></blockquote><p>由于最近在研究一个2D游戏框架——<a href="http://haxeflixel.com/" target="_blank" rel="noopener">HaxeFlixel</a>，为了自己回顾每天的学习进程，打算在学习过程里把一些东西整理一下放到博客上来，日后也可以分享给其他感兴趣的人学习。目前在跟HaxeFlixel官网的教程走一遍，由于还没有看到与这个框架有关的中文资料，接下来一段时间我跟到哪就顺便翻译到博客上来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;折腾了两天，总算是把博客重新部署回来了，博客的订阅源算是可以用了，欢迎视奸 :) 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于最近在研究一个2D游戏框架——&lt;a href=&quot;http://haxeflixel.com/&quot; target=&quot;_b
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
