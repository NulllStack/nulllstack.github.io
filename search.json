                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        [{"title":"Haxe编程入门","date":"2020-05-02T22:45:08.000Z","url":"/2020/05/03/Haxe编程入门/","tags":["Haxe"],"content":"Still work-in-progress…原文链接嗨！ 这是一篇 Haxe 语言编程的快速入门指南，Haxe 是一门强类型语言，许多人（包括我自己）使用它来开发游戏、app、网站以及许许多多其他的东西。我将会介绍一些计算机基础相关的内容，所以你不必担心自己之前没有过编程经验。跟随这篇教程，你不需要下载任何东西，只需要前往 try.haxe.org 即可在网页端在线编译每个小节的例程。Part One - 介绍如果你还在犹豫是否应该使用 Haxe 来开发你的下一个项目，那么尝试询问自己以下几个问题：类似 Java, C++, PHP, 或 AS3 这样的面向对象编程语言你使用起来是否感到舒适？你是否希望你的下一个项目在多平台下运行（HTML5, Flash, Windows, Mac/OSX, Linux, Android, iOS 等）？你是否对开源项目以及社区感到有兴趣？你是否为了学习 Haxe 而来到这篇教程？如果以上问题有任何一个的回答是 “yes” 那么或许 Haxe 对你而言会是个不错的选择！那么 Haxe 的源码看起来长啥样呢？你可以通过两个斜杠（//）在你的源码中创建一个“行注释”，你的程序编译时，编译器将会自动忽略位于双斜杠之后与双斜杠同行的任何内容，我将会在我的例程中加入一些这样的注释对代码进行批注，所以你应该注意一下这些内容。如果这些代码现在对你而言就是天书的话，不要紧！在接下来的一个小时里你将学会编写比上面有趣得多的代码！Part Two - 类（Classes）一个类即是数据的组织结构，它由一个名称，一个路径以及零或多个成员构成。前往 try.haxe.org ，你将会得到如下代码：你可以看到这个类被命名为 Test ，但是它的路径被隐式声明为其所在的根目录了。如果你想显式地声明其路径的话，你可以在代码的顶部位置添加以下这行代码：此处由于并没有在 package 之后声明一个路径，所以这个语句会将路径隐式定义为源码所在的根目录，但是如果你在自己的编辑器中构建自己的程序，且你的源码由如下目录结构构成：那么你就需要将路径定义为：如果你是在 try.haxe.org 中编写代码，那么你现在不需要担心路径的问题，但是如果你开始在本机编写程序那么这里给出的信息将会很有用。最后，try.haxe.org 给出的源码中有一个成员，是一个名为 main() 的函数。类成员由类体的一对封闭的花括号（{}）所包围。注意，一个代码块由一对封闭的花括号（{}）组成，且其中的每一条指令都由一个分号（;）表示结束。类中还可以包含另外一种形式的类成员 - 变量（variable） ！Part Three - 变量（Variables）一个变量是一个被给定名字的对象或值，通过名字你可以引用或改变其值。在 Haxe 中有以下几种基础类型的变量：Bool（单词 boolean 的缩写）：这种类型可存储两种值 - 真（true）或 假（false）Int （单词 Integer 的缩写）：这种类型可用于存储整数值如： -14 或 256。 也可以以十六进制表示 0xF000D。Float（即浮点数 (floating-point number)）：即具备小数位的数字（注意你可以为一个要求使用 Float 类型的位置使用 Int 类型的值代替，但是反之则不行）。String：用于存储一串字符如 “Hello World!” 你可以通过使用一对双引号或单引号括住一串字符来创建一个字符串如：&quot;double quotation marks&quot; 或 &#39;single quotation marks&#39; 。让我们来添加其中几种到我们的代码中：现在，让我们稍微修改一下trace()的调用使其引用我们我们的变量！这里你可能会注意到我们在一些单词前放置了一个美元符号。这是由于在 Haxe 中有一个称为 字符串插入（String Interpolation） 的语言特性，这一语言特性使得我们可以在字符串中插入一个变量或是一个表达式，但是只有当该字符串是由一对单引号括住的形式出现时才能使用这一语言特性。Part Four - 对象（Objects）一个对象即是一个类的 实例（instance） 。你可以理解为一个类即是用于创建对象时所使用的蓝图。让我们来把那些个人信息组织进一个名为 Person 的类中吧。在你的代码的最下方添加以下代码：注意一下 new() 函数，任何可以被实例化为对象的类都应该具备一个 new() 函数 - 这是一个类的构造函数（constructor），被用于初始化对象的代码都位于其中。现在让我们回到 Test 类中，并整理一下代码：如果你现在尝试运行代码，那么你将会被甩一脸报错（实际上就一条报错 :P）：Unknown identifier : name这是由于我们把变量 name 放到 Person 类里面了！这个类被用于实例化我们的变量 buck ，所以我们现在需要通过buck.name这样的形式来访问这些变量。这称为 点成员访问符（dot notation) ，通过对变量使用点成员访问符（.）可以访问所有该变量的公开成员（public members）！所以让我们来修复一下错误的代码为：现在点击 Build + Run 之后你会看到…emmm…奇怪的运行结果：为什么会这样呢？这里有个事情你需要记住，你在 Haxe 中使用 字符串插入 这一语言特性时，如果你要插入的是一个表达式，那么这个表达式必须被一对花括号 {} 所包围：让我们再添加一行代码加深理解：一个表达式可以是一个函数的调用、一组方程式或是一个赋值操作。最后做为一个练习，你可以尝试创建你自己的类，为其添加一些变量或函数，比如，你可以创建一个名为 Mario 的类并为其添加以下变量：speed:Floatlives:Inthas_mushroom:Bool以及以下函数：jump()crouch()run()Part Five - 可见性（Visibility）你是否注意到了我们的某些变量被标记为 public ？这样做是为了让其他类可以通过这组变量所在的类的实例访问到这组变量。这就是为什么 Test 类得以访问 buck.name。所有类成员都可以被修饰为 public 或 private。在 Haxe 中如果有成员没有被修饰为 public，则该成员会被隐式修饰为 private。如果在你的类中有这样一个函数或变量，它只能在其所处的类中被使用，那么最好将其修饰为 private。这样做可以使代码有更好的封装，且使得日后更易于对代码进行维护。以上代码编译后会报错，因为 joe.secret 被修饰为私有的（private)在函数体内或者其他代码块之中也可以声明变量，但是它们的可见性只能在他们所在的代码块所覆盖的范围里。以上代码编译后报错，这是由于 example_two 于代码块内声明，但是我们于代码块所覆盖的范围之外尝试访问它。如果一个函数或变量被修饰为 static 则表示你不需要通过实例化它所处的类的对象来访问它。这样做对于常数值或函数而言相当有用，因为我们可以在程序的任意位置访问它！仔细观察一下我们是如何在其他类中不通过实例化 Constants 与 Util 来访问这些常量与函数的。这样做有一个很显著的好处即当我们想要修改程序中任意位置的 max_speed 的值时，我们只需要在一处地方进行修改即可！Part Six - 函数（Functions）在前面的小节中我们已经编写了不少函数了，但是在这一节中我们将花点时间学习如何编写它。这是一个基本的函数的例子：这是一个完整的函数，但是我们还不能在 Test 类中使用它，首先我们需要先将它修饰为 static ，这样做static function main()才能够访问到它。 像这样我们就可以使用它了，接着让我们对这个函数做一些定制化的修改！我们刚刚为我们的函数添加了一个名为 to_who 的参数。参数可以被看作是当你调用函数时提供其值的一个变量，该变量可以在该函数内部被访问到。同时，我们为参数提供了一个默认的值 ‘World’ ，这个时候我们只要不修改 Test.main() 中的函数调用则运行结果跟修改前是一模一样的。但是如果我们想要改变运行结果，我们可以通过调用 hello() 时提供自己的名字来让程序向自己打招呼！如果我们想要从函数取得该字符串而不是通过 trace() 函数将其输出到输出窗口时怎么办？这时候 return 就帮得上忙了。一个函数运行时可以 返回（return） 一个值，这个功能相当有用！让我们修改一下 hello() 函数使其返回一串字符串而不是将其输出至控制台窗口：你可以看到我们通过添加 :String 至函数声明末尾的位置，为我们的函数指明我们想要它返回的值或对象的数据类型。这一书写形式和为变量的声明指定数据类型时十分类似！接着在 hello() 函数的函数体中我们通过关键字 return 将欲返回的值返回出去。如果函数体中出现了 return 关键字，那么位于其后（此处不是指书写上的顺序而是指程序的执行顺序）的代码将不会被执行。接着让我们通过 main() 函数来输出其所返回的字符串！那么让我们来快速的剖析一下下面给出的代码：你现在不需要考虑这段代码的功能（尽管我很想尝试向你解释），让我们先来看看它的构成。public - 修饰该函数为可在该函数所处的类外部被访问到static - 即表示你不需要实例化具有该成员函数的类即可使用它function - 即表示它是一个函数（function）get_random_number - 这是函数的名字，为函数命名时你应该尽量使用具备阐述性的名字，这样做的好处是当你阅读你所写的代码时，如果你看到了某个函数的调用，即可通过其名字得知该函数所做的工作而不需要查看其实现的源码，命名时应该尽量使其简单易懂且能能尽量保持代码的语境连贯。(min:Float, max:Float) - 这个函数为了完成它的工作需要在其被调用时提供两个 Float 参数，分别用于表示最小值与最大值。:Float - 这是函数返回值类型，你可以在任何需要提供 Float 类型值位置使用此函数。接着是一个函数体，它由一对封闭的花括号{}构成，其中有一个 return 关键字以及一段紧随其后的方程式，方程的计算结果总是返回一个 Float 类型的值。PS：其实这个函数是用于获取一个随机数，调用该函数需提供两个 Float 类型的浮点数值作为参数，分别表示最小值和最大值，而函数执行结果是返回一个介于这两个值之间的带小数位的随机数（最小值 &lt;= 返回结果 &lt; 最大值），有意思的是函数体中的表达式 min + Math.random() * (max - min) 使得调用该函数时，不论所提供的两个浮点值大小的先后顺序（如 get_random_number(5, 10) 或 get_random_number(10, 5)），总能正确返回介于这两个浮点数之间的一个随机数（5 &lt;= 计算结果 &lt; 10）。Part Seven - If &amp; Else在大多数程序中，你或许需要使用带分支的逻辑结构来给予程序额外的功能！ if 语句被用于检查某个条件是否为 真（true) ，如果条件为真，则执行随后的代码块。在上面的代码中，我们想要让函数检查顾客是否符合老年人的折扣标准，如果是，则以折扣价对待。为了满足这个功能，我们使用语句 if(customer.age &gt;= 65) 来实现。如果顾客的年龄大于等于 65 岁，则程序会执行随后的代码块（代码块会对总价施以 10% 的折扣）。如果年龄小于 65，则程序会掠过后面的代码块执行随后的指令（此例即返回最后的合计价格sub_total）。你也可以把上面的代码改写为另一种形式：当 if 语句有一个与之对应的 else 语句出现时，位于 else 语句之后的代码块会在 if 语句的条件不满足时被执行！你还可以使用一个 else if 语句来添加另外一个表达式作为条件的分支，比方说，如果你的经理临时起意想要在每周二为每一位顾客提供折扣价，但与此同时他并不希望长者能因此享有叠加的折扣时怎么办？注意我们使用表达式 day == ‘Tuesday’ 而不是 day = ‘Tuesday’。如果你想要检查某个东西是不是与另外一个东西相等时，必须使用两个等于号（==）作为连接两物进行比较的操作符。而如果你是希望将某个值赋值给某一个变量，则使用单个等于号（=）放置于变量名称之后，欲赋值的值之前来完成。这段代码可以正常运行，但是你观察一下可以发现其中存在重复的代码 sub_total = sub_total * 0,90 ！尽管如此，这段代码绝对不会在一次程序的迭代中被运行两次（因为这是一个二选一的逻辑结构）。编程过程中一件有趣的事情之一时尽力使我们编写的代码以更优雅的形式出现，如果你编写的代码中存在冗余的部分，那么一定有方法使其变得更简洁！我们可以使用一个 逻辑或操作符（||）来判断两个表达式之间的某一个是否为真！以上代码我们通过判断顾客是否满足老年人折扣标准，或者今天是否是星期二，只要满足两个条件中的其中一条，那么顾客即可享有折扣价。如此一来我们的代码就显得更简洁优雅了，现在让我们再设想一下要是我们的经理今天心情极差，所以他想要让长者只有在周二时才可享有老年人优惠。那么我们可以使用 与操作符（&amp;&amp;） 来连接两个条件，用以判断两个条件是否同时满足！以上代码我们通过判断顾客是否满足老年人折扣标准且今天是否是周二，只有当两个条件同时满足时，代码块才会被执行。而如果想要判断某个条件是否不为真，则可以使用一个感叹号（!）以表示你想要判断该命题是否不为true需要注意的是 if 语句总会期望一个 Bool 类型的值作为条件，因此你不可以写出类似 if(1) 这样的语句，因为这里的字面值 1 是 Int 类型的。（有别于C++）Part Eight - 循环（Loops）有时候我们想要某个代码块被重复执行多次不要担心，你不需要像这样做。让我们通过 while() 循环来帮我们完成这项工作！俗话说的好，适当的偷懒是一种美德！现在让我们来看看这里发生了什么！var i:Int = 99; - 首先我们声明了一个变量用于计数，通常在这种情况下我喜欢以 i 来命名该变量，因为 i 可以被看作是单词 iterator（迭代器） 的缩写while(i &gt; 0) - 类似于 if(i &gt; 0) 只不过这里的代码块会被循环往复不停的被执行直至条件表达式的值为假，尽管这样做有点危险，比方如果你的表达式的求值结果有可能永远也不会为假，那么就会陷入死循环。trace(‘$i bottles of … on the wall!’); - 我们通过使用 字符串插入（String Interpolation） 配合循环体来唱一首呆萌的歌！i–; - 这里是最为重要的部分！我们通过对变量 i 进行递减操作来使得下一次循环的迭代会少一瓶酒（bottle）（并且确保我们的循环体不会陷入死循环的情况之中）。++ 与 -- 是被用于对变量自身进行 加1（++） 或 减1（–） 的两个快捷记法，我们也可以通过 递增/减赋值操作符-=/+= 实现相同的操作，比如 i -= 1 或 i += 1，如果酒保一次递给我们两瓶啤酒的话我们可以这么写：i -= 2，自增/自减操作符与递增/减赋值操作符都是为了实现与 i = i - 1 这样的代码相似的功能（只不过使用上更为简便）。在 Haxe 中还有另外一种循环体，即 for 循环！Haxe 中的 for循环 十分的简洁优雅！for(i in 0 ... 99)光是这一行代码就完成了大部分工作！我们设定了一个迭代变量 i 并且给它指定了一个 0…99 的迭代范围，与此同时我们不再需要在代码块中对 i 进行递增或递减的修改操作！并且 for() 循环永远也不会陷入死循环的境地！因此相比起 while() 循环我更爱用 for() 循环。Part Nine - 数组（Arrays）一个数组用于表示一组值的集合，在许多时候你会想要对一组数字、字符串或对象进行引用。让我们来学习如何使用数组。fruits 数组的名字:Array 指明变量的数据类型，此例中即数组&lt; String &gt; 告诉我们的数组要存储哪一种类型的值，在此例中我们要它存储一组字符串的集合[square brakets] 方括号所囊括的即使我们所要存储的值你可以看到我已经添加了 4 个字符串至我们数组中，你也可以像下面这样把他们写在同一行里：但是我比较喜欢纵向查看一组数据，所以我更愿意使用第一种写法，不过怎样写完全由你自己决定！你可以通过数组的索引来访问数组中的元素！要想取得数组中的第一个元素你需要使用 array[0] 来访问，这是由于在 Haxe 中数组的索引下标是从 0 开始的，你还能通过 array.length 来查看数组中有多少个元素：有几种方式可以对数组的元素进行更改，但是这里我要先介绍两个方法（method 函数的另一种称呼。PS：具体为什么会有两种名词是由于方法这一说法是从面向对象语言中衍生的）：push() - 该函数用于对在数组末尾塞入（push）一个元素。remove() - 该函数用于在数组中拿走（remove）一个元素。你可以利用循环语句对数组中每个元素进行遍历，可以通过几种方式来做到，首先第一种类似于访问数组元素的通常操作：第二种方式你可以指定 for() 循环直接遍历数组的元素！看看这样做的代码多么简洁！你可以直接在 for() 循环的语块中直接使用数组的元素而不需要通过索引进行访问！如果你想要在这种形式下获取当前元素的下标，你可以通过 fruits.indexOf(fruit) 来查看！如果查找的元素不在数组中，则 array.indexOf(item) 会返回 -1。数组是一个用于存储一长串数据的好方法，你甚至还能嵌套地将数组存储进数组中！如你所见，一切都开始怪异了起来，所以当你使用嵌套的数组时需要谨慎对待。Part Ten - 继承（Inheritence）Still work-in-progress…"},{"title":"20200503","date":"2020-05-02T20:15:05.000Z","url":"/2020/05/03/20200503/","content":"Trying to learn how to love myself before love some one else."},{"title":"HaxeFlixel官方教程6-加载Tilemap(更新)","date":"2020-04-29T09:48:36.000Z","url":"/2020/04/29/HaxeFlixel官方教程6-加载Tilemap-更新/","tags":["HaxeFlixel"],"content":"原文使用 Ogmo 编辑器配合 HaxeFlixel 的一大好处是框架已经内置了一组类（class）用于方便的加载 Ogmo 创建的地图。不过这组类并不是以 HaxeFlixel 的标准库形式提供的，所以我们需要先安装 flixel-addons 库用于访问这组类。首先打开命令行窗口并键入：该命令用于安装 HaxeFlixel 的插件库，安装完成后关闭命令行窗口。回到 VSCode 并打开工程中的 Project.xml 文件，我们需要告诉我们的项目我们要导入 flixel-addons 库至我们的项目中。找到以下这行代码：将其修改为：保存修改，现在你可以开始使用 flixel-addons 库提供的接口了！回到我们的 PlayState 类中，位于 player 变量的定义下方添加以下代码：这里我们首先创建了一个对象用于存储我们的 Ogmo 地图，之后又创建了另外一个对象用于保存从 Ogmo 地图中生成的 FlxTilemap 。在 create() 中，位于 player 对象的设置之前的位置添加以下代码：这里我们从关卡文件中加载数据至我们的 FlxOgmo3Loader 对象、从 walls 图层中生成 FlxTilemap 并设置 瓦片1（表示地面的瓦片）的碰撞为无碰撞，瓦片2（表示墙面的瓦片）的碰撞为从任意方向发生碰撞。最后将 tilemap 添加至当前的 状态（state）中。现在我们需要将我们的 player 对象放置于地图中正确的位置上，所以修改我们初始化 player 的代码：修改为：这里我们告诉 map 对象遍历所有 entities 图层中的实体，并对其调用 placeEntities() 函数（我们下面就来实现该函数）。当我们调用地图的 loadEntities() 函数时，它会传递所有已放置的实体的数据至一个我们所需要接收数据的函数中。在我们的函数中，我们需要获取这组数据并利用它们做某些事情。这里我们的函数如下所示：这个函数如果获取到了传递进来的实体名为 “player” ，它将会设 player 对象的x与y坐标至对应实体的x与y坐标的值的位置上。现在我们需要为我们的状态添加碰撞检测，这样 player 碰到到墙面时就会一头撞上而不是穿行而过。所以位于update()中，super.update(elapsed)之后的位置添加以下代码：这里所做的工作是每一次 update() 的迭代都会检测 player 与 walls 之间的重叠情况，如果发生重叠则两个对象之间会自动分离。最后我们需要适当调整一下 player 的属性。由于默认情况下 player sprite 的大小与瓦片的大小是一致的（16x16) ，这导致 player 在穿越与自身大小一致的门口时犹如 “穿针引线” ，往往会由于一点点的偏差卡在门口动弹不得。所以我们需要适当的修改player sprite的大小 与 offset ，这样做不会改变精灵序列实际显示的效果，只会对其碰撞盒的大小产生影响。所以在 Player 类的构造函数中，位于 drag 属性的设置下方添加以下代码：修改了 player 的碰撞盒之后，为了便于确定其修改后的大小，我们可以将其可视化，以Debug模式编译并运行项目之后，你可以通过 F2 功能键唤起 HaxeFlixel 自带的 Debugging 工具点击右上角那个立方体图示的按钮即可渲染出游戏中出现的碰撞盒：凑近点看你可以通过碰撞盒发现现在player的大小要比瓦砖更小一点了。"},{"title":"HaxeFlixel官方教程5-创建Tilemap(更新)","date":"2020-04-29T08:57:26.000Z","url":"/2020/04/29/HaxeFlixel官方教程5-创建Tilemap-更新/","tags":["HaxeFlixel"],"content":"最近官方更新了新一代 Ogmo 编辑器 —— Ogmo3 的支持，于官方教程中更替了旧版的教程，所以顺便也翻译过来吧。现在，是时候为我们的玩家创建一个可供活动的地图了，首先我们需要使用一个叫做 Ogmo编辑器 的工具，Ogmo是一个免费的 Tilemap 编辑器，可以很完美的融入 Haxeflixel 的工作流。在这部分教程中我们将使用一个 “两瓦片（2-tile)” 的 tile序列图（tilesheet）用于分别表示墙面与地面。你可以自己做一个 16x16(加注*) 大小的 tile序列 或者使用下面提供的这组序列图：（注意：序列图的第一块“瓦片”其实是透明的）（加注*：实际自己做序列图的时候尺寸应该是24x16，因为实际序列图由三块瓦片组成，第一片是透明的，其用于表示“空白”瓦片，询问了一下 Flixel 的核心成员 Will 给出的解释是由于许多编辑器，包括HaxeFlixe引擎本身是通过下标 0 来索引“空白”瓦片的，但是Ogmo是使用 -1 索引来表示空白瓦片的（除 tilesheet 的第一块瓦片是透明的则使用这一块瓦片表示空白），因此如果不在 tilesheet 的第一块位置放置一块透明瓦片，在Ogmo中编辑的时候空白位置没问题，但是在Flixel中加载的时候就可能会引起 bug ， 比如，原本需要空白的位置被瓦片填充或是原本需要显示的瓦片没有显示（Flixel默认不显示第一块瓦片）的情况）下载并安装 Ogmo Editor 3，并启动。点击 New Project 并定位至 assets/data 文件夹下（你的游戏工程里的文件夹）并保存为 turnBasedRPG.ogmo。在 General 选项卡下，你可以重命名项目、设置关卡（level）的默认大小等。把其中的选项按如下图中所示设置：在Layer选项卡下，创建一个实体层（Entity Layer）并命名为 entities 以及一个瓦片层（Tile Layer）并命名为 walls ：在 Entities 选项卡下，创建一个名为 player 的实体（Entity）：最后，在 Tilesets 选项卡下创建一个名为 tiles 的瓦片集（tileset）并加载先前创建好的瓦片序列图：完成以上工作之后点击 Save ，接着你会被带至如下窗口：确保你目前位于 walls 图层，并且已正确选择屏幕上方的对应工具，然后开始绘制你的地图吧。确保你的地图由墙面形成一个闭环（这样玩家就不能跑出地图以外的区域），并且其内由地面完全填充，最后绘制完的地图应该类似下面这样：现在，切换至 entities 图层并将 player 实体放置于地图中的某一个位置：最后的最后， Ctrl+S 将关卡保存为 room-001.json 至 assets/data 文件夹下。到这里 Ogmo 的基本使用就介绍完了，下一节我们将介绍如何将我们创建好的关卡加载至我们的游戏中。"},{"title":"No organism Except myself","date":"2020-04-10T17:01:46.000Z","url":"/2020/04/11/No-organism-Except-myself/","content":"对一件不再有趣的事情或一段令人失望的关系付之一笑之后就可以结束了吧。你们和我总得先死一个，为什么不能是你们。"},{"title":"20200320","date":"2020-03-20T05:21:54.000Z","url":"/2020/03/20/20200320/","content":"做着越来越多违心的事，说着越来越多违心的话。在明知其无聊的圈子里越来越麻木。到底还是因为自己太菜。"},{"title":"一个常量引用未定义操作引发的Bug","date":"2020-03-19T12:35:46.000Z","url":"/2020/03/19/一个常量引用未定义操作引发的Bug/","content":"最近逛贴吧碰上一个灵魂提问，随后请教了几位大佬给出了很详细的解答，但是囿于知识面不全暂时还不是很通透，遂在此记上一笔，日后回来补充详细信息。事情是这样的，声明一个常量引用并绑定至一常量，创建一个指针指向该引用，随后对该指针进行解引用，强制类型转换并赋值；这样一番操作之后会引发一个bug，指针与引用所访问的值已经被修改，但同时被间接访问的常量本身值却保持不变；以下是代码片段：以下是反汇编后汇编代码：一个简单的解释是由于 c 为常量，编译器会为 c 的调用提供一个固定的值（该常量定义时的初始值）进行替换，所以当对常量 c 所在内存地址的内容进行修改的时候，除对 c 的间接访问会被修改外，对 c 的直接访问都保持原值不变。例子中对 c 的内存区域进行修改的操作是一种 “未定义操作”。补充：CSDN文章中对编译过程中，编译器处理常量的工作有较为详细的解释。"},{"title":"C/C++文件读写的一点事儿","date":"2020-01-10T14:45:34.000Z","url":"/2020/01/10/C-C-文件读写的一点事儿/","content":"折腾C/C++基础，踩了两个坑。首先是关于fstream.tellg()调用的问题。第二是关于fstream 对象对文本文件读写 换行符  的问题。先说第二点吧，我们都知道 endl 操作符是在缓冲区末尾添加一个换行并清空缓冲区，这个操作对文件流的写入作用也是一样的：以这种方式写入数据到 filename.txt 的时候每次都会写入三个数据，分别用空格分隔开，并且在行末添加一个/n换行。但是当我用 ifstream 打开该文件进行读取并尝试通过 seekg(n, ios::cur) 向前移动 n 字节指针位置的时候，每一次指针都没对上我想要的位置。下面给出一个例子来说明问题。假设 user_data.txt 文件内容如下：cpp：在跟发小尬聊的时候提到这个问题，他觉得是由于内存中对齐存放导致的问题，但是我感觉这种底层存放的操作应该不会对文件内容本身的读写造成影响，但还是找了相关资料，目前而言感觉还蛮复杂的，日后再深入。因此我又找了其他资料有了如下发现：原文链接历史：  在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。  　于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。  这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。  　后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。  　Unix 系统里，每行结尾只有“&lt;换行&gt;”，即“\\n”；Windows系统里面，每行结尾是“ &lt;回车&gt;&lt;换 行&gt;”，即“\\r\\n”；Mac系统里，每行结尾是“&lt;回车&gt;”。一个直接后果是，Unix/Mac系统下的文件在Windows里打 开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。由于 Windows 下对文本文件进行写入的时候，\\n换行符会被替换为\\r\\n两个字符，因此以endl对 user_data.txt 写入数据的时候行末会有两个字节的占用。纯手写的 txt 也可以发现这一点：sth.txt 的内容仅仅是敲了个回车写了个换行，但是依然占用了2个字节。这个问题对二进制文件进行读写操作的时候不会存在。下面说说第一个碰上的坑。ok，这个问题我现在还是很懵，就在我写这篇博客，尝试复现问题并给予描述的时候。尽管这个问题可以通过换一个编译器解决（从MinGW换到MSVC），下面我尝试一下能不能描述明白问题。首先，我们先来看一下 cppreference.com 对 tellg() 函数的描述：简单来说就是用于获取一个值，获取失败时返回 -1 ，成功则返回当前指针的位置。行吧，看起来很好理解，由于ifstream对象进行读入的时候是按字节读入的，指针位置也会随之后移，读到哪移动到哪，每读一个字节后移一位。在前面的问题中我们也通过 tellg() 来获取指针位置的状态。然而那是在我换了MSVC编译器之后 tellg() 的行为才符合我的预期，那么在MinGW环境下编译的结果如何呢，下面还是例子来说明：首先是cpp的源码：假设当前user_data.txt只有两行内容：输出：如果增加 user_data.txt 内容的行数：输出：可以发现指针位置偏移多了1个字节的量，而且以此类推user_data.txt的内容增加多少行 tellg() 返回的指针位置就会偏移多少个字节。但是tellg()的这个行为在MSVC环境下编译是不会存在的，不论user_data.txt的内容有多少行程序都会输出一样的结果：尽管MinGW环境下 tellg() 的行为很奇怪，但是更怪的是这并不影响我们使用它配合 ios::cur 来进行寻位操作：cpp源码：user_data.txt（一共11行数据）：MSVC环境输出：MinGW环境输出：如输出所示两个环境下都能通过seekg(-(iofile.tellg()), ios::cur)把指针移回到文件的开始位置。至于为什么会出现这样奇怪的问题我也没搞懂，网上找了一下相关资料有的人说是 MinGW 的编译器 bug，有的人则说这是 MinGW 在 Windows 下编译的正常行为（后者我认为靠谱一点）。我找到的相关资料：StackOverflow、猿问暂时就先到这吧，文件读写就先放一边了，抓紧折腾点别的。"},{"title":"openFrameworks文件结构","date":"2019-12-31T17:09:44.000Z","url":"/2020/01/01/openFrameworks文件结构/","tags":["openFrameworks"],"content":"把下好的oF解压，从现在开始我们将以该文件夹作为 oF 根目录，你可以把 oF 的根目录放置于任何位置。但是有一件事需要强调，oF 已经被设计为一个 “独立的（self-contained）” 结构，所有依赖项都被整合好放在同一个文件夹里了，也就是说你可以把这整个文件夹移动到任何磁盘下使用，甚至可以打包带走带去机房上课的时候写着玩 :P。如果你有其他版本的 oF 那么请保持他们之间的相互独立，不要尝试把两个版本的文件混在一起。打开解压出来的文件夹，它包含了一些其他文件夹，我们将在下面给出详细解释。现在我们先找到 examples 文件夹并尝试编译其中的项目。examples/graphics/graphicsExample。如果你使用的是OS X操作系统，那么打开graphicsExample.xcodeproj。如果你使用的是 Visual Studio，那么选择打开 “.sln” 文件。注：由于我一直是使用 Windows ，从现在开始其它系统相关的内容我都不再区分，只讲 Windows 相关的部分。现在你的 IDE 将自动打开并加载该例子，找到“运行” 按钮或选项并点击它，例子源码将会开始被编译（首次编译因为因为需要编译 oF 库，可能需要多花一点时间）。你会看到许多文件开始被编译，放心，大部份文件只会在 oF 库被重构或首次编译时需要编译。如果以上工作进行顺利的话，将会弹出一个窗口并显示你刚刚所编译的例子中的内容。如果图形例程能够正常工作的话，花点时间看一遍其他 oF 实例并尝试运行他们；通常来讲在你打开一个新的项目之前先把当前的 项目/工作目录 完全关闭会是一个好习惯。一旦 oF 库完成了首次编译，之后项目的编译速度会快很多！openFrameworks 文件结构在 oF 根目录中你可以找到以下这些文件夹：Addons“addons”文件夹中包含了已内置的“核心”插件。插件是一些额外的扩展了 oF 功能的代码片段，插件通常由第三方用户编写并分享出来。而“核心”插件是那些被用户频繁使用的插件于是被选择作为官方 oF 库的内置插件。他们被 oF 的核心开发者维护与编写。访问该链接：ofxAddons 可以找到由社区贡献的大量额外的插件。Apps该文件夹用于存放你新建的项目；你当前的 oF 中默认存放了一个名为 “myApps” 的文件夹于 “apps” 文件夹内，当你新建项目的时候项目生成器会默认使用该文件夹（注1）。还有重要的一点需要注意，项目对 libs 文件夹的引用是使用相对路径来定位的；需要注意的点是你的项目应该一直位于相对路径所指从当前文件夹开始到 libs 文件夹之间的深度中（如../../../libs即 表示项目文件夹所在的路径应该类似oF根目录/apps/myApps/mySketch这样），如果你随便更改了项目文件夹的存放路径它们将找不到编译所需的其他部分内容（注2）。注1：推荐使用 projectGenerator 来管理项目，理由后面会给出解释。注2：如果你尝试用文本编辑器打开项目文件（.sln以及.vcxproj）你会看到其中有些地方有一段相对地址如../../../libs把这一段的路径改为绝对地址你就可以把这个项目文件夹放在硬盘上的任何一个位置也能确保正确编译，但不推荐这么做。Examples该文件夹用于存放例程，其中的例程按主题分类排序，几乎涵盖了 oF 的各个方面，每个实例都以保持简单并专注于解决特定主题的问题为主，因此当你需要在你的项目中完成某些类似的工作，这里的例程会相对简单且易于理解，可以作为你着手解决问题的一个起点。libs这里面存放了 oF 用于编译你的项目时使用的各种库文件，其中包含的库有如 FreeType 库用于平面设计（Typography）的支持、FreeImage 库用于图像加载、glfw 库用于窗体实现（Windowing 不知道翻译对不对，没用过）；以及其他用于编译 oF 项目的依赖项还有 oF 的源码也都在这个文件夹内，如果你想看源码的话就在这里面翻找吧。other这里面存放了 Arduino 相关的例程，在 examples/communication 文件夹下你可以找到串口（serial）例程，当你的项目使用了 Arduino 的时候可以用这里的例程检查 Arduino 是否正确连接并正常工作。projectGenerator现在 oF 附加了一个简单的项目生成器用于简化项目的创建流程。这个工具使用了一个项目模板（位于 scripts 文件夹下）用于项目的创建与修改（项目名称、使用的插件等）。同时用项目生成器创建的项目可以被存放于磁盘的任意目录下（实际上已存在的项目若存放路径发生变动，需使用生成器导入该项目并点击 Update ”刷新“ 项目依赖项的引用信息）。最后，原文罗列了 oF 的 API 以及可用的插件与相关用途，我就不在这里罗列了，直接丢两个链接更具 “时效性” 毕竟这些东西随时可能更新随时可能发生变动，最重要的是：码字真的很麻烦。 :PAPI 文档：openFrameworks Doc插件目录：ofxAddons（其实前文以及给过了）emmm…再就是在豆瓣上发现官方文档的 ofBook 已经有大佬翻译了我后面想要翻译的部分了，虽然后半段机翻成分较多，但是也足够我看了….没必要重复劳动，加上我写这些东西目的也是出于方便自己查阅，所以….后面我再更新就是整理与总结向的内容了，翻译的文章视情况更新把。Farewell"},{"title":"openFrameworks Philosophy","date":"2019-12-29T18:59:30.000Z","url":"/2019/12/30/openFrameworks-Philosophy/","content":"po 完上一篇博客之后发现那个垃圾排版与Typora编辑时呈现的排版完全不一致，恶心到我了，甚至开始考虑是否继续使用博客，反正主要是给自己看的，何必如此折腾煞费苦心 :(openFrameworks 的发展尝试遵循以下几个目标：它应该是合作性（Collaborative）的，简单易用的，连贯且直观的，跨平台的，强大且可扩展的。以上目标也由 “与人协作” （”do it with others – DIWO”）的哲学观所驱动。合作性（Collaborative）openFrameworks 的开发是协作完成的，它的蓬勃发展得益于许多经常参与讨论、在插件与项目中完成协作的人的贡献。我们鼓励大家使用oF并为社区的生态环境做出贡献。我们使用了分布式版本控制系统 “git”，这意味着大家可以提出建议，为项目添加新的 branch、做一些实验性的扩展；如果你看过 GitHub 上的网络图（network diagram）便不难发现它呈现出一种奇怪的图示，四处编织着新的分支，某个部分的代码被拆分后又在另一头重组。整个社区遍布全球各地，共同维护着oF的核心代码：他们修补BUG，提交新请求以及构建他们所需的新的工具，这是一个 全球性的项目，如果你在美国一觉醒来并开始查看电子邮件，发现邮箱里充满着来自亚洲与欧洲的程序员提交的新的需求或者 issue 是很常见的事情。有超过70人为核心代码做出直接的贡献，还有数百人以fork或其他形式为社区做出贡献。简单性（Simplicity）openFrameworks尝试在有用（usability）与 简单（Simplicity）之间寻找平衡，最早期的oF核心库被用于教授C++与OpenGL，后由时间的推移其核心库的例程随着更多高级功能的加入变为了最适合学习的途径，因此我们随着oF的发布创建了更多的例程，为实验提供更多简单、易于拆解的学习起点。我们希望oF可以尽可能的简单，特别是为那些从其他语言或开发环境入坑的朋友，C++是一门“庞杂”的语言，它的庞杂还意味着每个人使用C++编写的规范可以很不一样。如果你去书店你会发现C++相关的书可以有数百本之多。我们希望创建一个你只需要一两本书来入门而不需要成为一名专家就能够使用的代码库，其代码规范、编程模式及编程范式（the patterns, approaches and style of the code）是简单且直观的。我们刻意在某种程度上与Processing对齐，两者的某些函数都是相似的，为的是能够让大家在两个框架间的使用能够更自然的过渡。连贯且直观（Consistent and Intuitive）openFrameworks是连贯且直观的：它运转于一些常规（least surprise）的原则之上，所以你从oF中的所学也可以在其他领域有所用。初学者可以从oF中学习到常见的编程模式（programming patterns）而高级用户在其他语言或工具集中所学的知识也在oF中也有用武之地。oF的箴言是“学生排在第一位”，许多关于oF的发展的指导方针是基于 “在5或10年以前我会喜欢什么样的工具” 这样的思考的。我们希望代码的模式（pattern）尽可能简单地易于输入。这意味着有如在视频播放器中使用“play”与“stop”命名的具“自我阐释性（self-exlanatory)” 的函数命名法以及类似的变量的命名法会更直观。我们就直观方面有过许多讨论，都是为了让代码尽可能的简洁明了，使得你可以在输入代码的过程中，在自动补全的帮助下也能够学习oF。跨平台（Cross-platfiorm）openFrameworks是一个跨平台的工具包，它尽可能多的支持各种开发环境与操作系统，当你下载好oF之后你可以选择你需要的开发环境与目标平台进行开发，oF已经包含了相关的项目与例程供学习与使用。难以移植（Difficult-to-port）的部分代码被提供于插件（addons）中而不是核心代码中。oF被设计为可工作于多个平台：OSX，Windows，Linux， iOS，Android，嵌入式ARM Linux系统，以及如BlackBerry和PlayBook这样的处于实验性阶段的平台。openFrameworks的开发人员已经想出了一些聪明的方法使得oF可以访问其他语言的接口如Android平台下的Java以及iOS平台下的Ojective-C。跨平台库的一个喜闻乐见的点在于你可以将你的想法从一个平台导出至另一个平台，你可以在笔记本上迭代原型并快速地在你的手机上检验运行结果。它使得你的想法能够先落地而不需要担心冗余的跨平台工作。功能强大的（Powerful）openFrameworks功能强大，它使你能够借助如OpenCV之类的高级库，访问你的硬件如显卡进行加速，或者连接摄像头之类的外设。我们选择使用C++编写oF是因为它是一门足够“低级”的语言同时又可以以现代高级语言的方式进行编程。由于它可以认为是C语言的扩展，所以它可以编写一些很底层的东西，可以以老式C语言的方式编写，也可以以现代C++的形式编写。我们试图在oF中以简单、清晰、但功能强大的形式接纳这两种编程方法。同时，使用C++也使得我们能够直接访问许多已由C或C++编写的库的接口而不需要依赖其他语言的包装器（wrapper）。openFrameworks本质上包装（wrap）了其他库如：OpenGL、Cairo、FreeType、FreeImage、以及OpenCV，你可以把oF设想为一层介于用户代码（由你编写的代码）与这些库之间的代码层。由于不同库的使用上，编程方法与风格各不相同所以我们把各个库进行了统一的包装并提供一个更为连贯且直观的形式。可扩展的（Extensible）openFrameworks是可扩展的。如果你发现它缺少某些你需要的东西你可以简单地通过创建一个插件来扩展它。oF的核心插件通常包装了其他的库而不是直接以加入新功能的形式来解决问题。当oF包装了新的库的同时这些库也为进一步的扩展提供了新的途径。oF的愿景是成为你开发过程中的一个可靠的臂膀或脚手架。能够使得oF的核心库更轻量化的一点是避免尽可能多的往里纳入所有新的东西，取而代之的是oF有一个插件体系允许用户之间共享额外的代码，库以及方法使得在必要时可以将其 “编织” 进项目里。oF的插件可以是一段代码片段，或是更为复杂的库如OpenNI、Tesseract或Box2d的一个封装。插件名字的前缀通常是“ofx”，为的是可以使你方便的区分oF的核心与非核心代码，另外，我们为oF纳入了“核心插件（core addons）”，这些插件是我们认为大家通常会需要但并不是每一个项目都会需要用到的插件比如 ofxOpenCv 插件。我们试图通过  网站组织与支持社区开发插件，该网站通过自动检索Github中标题包含 “ofx” 一词的仓库（repos）收集插件目录，目前已有超过1500个插件收录在册。与他人协作（Do it with others – DIWO）这个部分有点懒得翻了，大概就是鼓励大家多合作多分享，共同探索 creative coding 的乐趣。（完 :D）"},{"title":"HaxeFlixel官方教程12:音效与音乐","date":"2019-04-04T18:22:05.000Z","url":"/2019/04/05/HaxeFlixel官方教程12-音效与音乐/","tags":["HaxeFlixel"],"content":"打算一次翻译完剩下的部分之后去弄点别的事情，HaxeFlixel相关的东西很闲的时候再回来整理。原文目前我们为游戏所做的各个部分已经整合起来了，不过它还缺少一点东西…它还没有声音。我们依然保持这个游戏简单化。我们将使用一个可循环的单音轨音频文件用于游戏运行时循环播放。我们也会为各种不同的动作添加一些简单的音效。在 HaxeFlixel 中播放音频文件是十分简单的事情。首先，你需要创建一段音乐还有其他音效。来自 FatBard 的 Patrick Crecelius 为本教程提供了一段音乐（建议在直接上GitHub从asstes/music文件夹内下载），你可以随意使用，或者可以自己做。我们还使用了 Bfxr 制作了一些音效，如果你喜欢的话可以使用这些音效文件或者自己做一套。如果你一步步跟着教程走下来的话那么在 “UI与战斗系统” 一节中你已经下载过这些音效文件了。以下列出这些文件确保你确实完整下载了这些文件：coin.wav - 用于玩家拾起硬币时使用的音效combat.wav - 战斗开始时使用的音效fled.wav - 当玩家成功逃离战斗时使用的音效hurt.wav - 玩家或敌人击中对方时使用的音效lose.wav - 玩家于战斗中死亡时使用的音效miss.wav - 玩家或敌人攻击miss时使用的音效select.wav - 用于按钮以及玩家于选项栏进行选择时使用的音效step.wav - 用于玩家以及敌人的脚步声的音效win.wav - 当玩家于战斗中获胜时使用的音效音效文件链接：GitHub当你准备完这些声音文件之后把音乐文件放置于assets/music文件夹下，把音效文件放置于asstes/sounds文件夹下。现在让我们修改代码来使用这些声音文件：首先打开MenuState.hx文件，由于我们需要让音乐从游戏启动那一刻开始并不管如何都不停循环，所以我们要从create()内添加它。我们同时还检查了音乐是否已经处于播放（比如玩家从GameOver状态切换至MenuState的时候音乐其实已经是在播放了），我们不希望在这个时候做不必要的重放。现在编译启动游戏之后它应该可以播放音乐了。接下来我们需要让按钮被点击的时候播放一段音效。很简单，我们只需要告诉按钮的onUP属性（注）加载一段声音。在MenuState的create()函数中，开始按钮的初始化之后的位置添加：现在你可以对选项按钮做同样的事情（将以上代码的_btnPlay替换为_btnOptions）。对于游戏中剩下的每一个按钮 - 位于OptionsState状态中的四个，以及位于GameOver状态中的那一个；它们的代码已经写好了，但作为课后练习你可以去这两个文件中看看是如何实现的。注：不知道什么原因，FlxButton的onUp等属性在官方API文档中是没有被列出来的，但是源码中能找到，还带注释，它们的类型为FlxButtonEvent，是FlxButton模块中的私有类，该类为FlxButton的辅助类用于FlxButton的事件处理。两个类型的关系可参考：模块子类型。这里记上一笔日后回来整理需要注意一下。下一步让我们为玩家添加脚步声，我们不想要每次需要播放同一个声音的时候都创建与销毁一个新的声音对象（sound object），所以我们要创建一个FlxSound对象以便复用。在Player类体的顶部添加：然后我们需要在构造函数的某处加载脚步声文件。接着跳到movement()函数中，在检查玩家是否处于移动的条件语句（if((velocity.x != 0 || velocity.y != 0) &amp;&amp; touching == FlxObject.NONE)）中第一行位置添加：FlxSound有一个灵活的小特性，如果你告诉它播放一个声音而它已经在播放了（并且你没有设置forceRestartflag为真）那么它不会再次播放。这意味着我们可以轻易地在玩家移动时按每一帧进行调用以播放声音，而且声音听起来就像是在不断循环。但当玩家不再移动时停止声音的播放，并处于静止状态时声音不会重放。现在我们也为敌人创建脚步声，与上面不同的是我们现在不是一直以满格的音量重复播放脚步声，而是基于敌人与玩家间的距离来改变音量的高低，实际上实现起来比听起来简单得多，首先我们在Enemy类体的顶部添加一个变量：接着与对Player类的设置一样，添加以下代码到构造函数中：你可能注意到了我们把声音设为.4（40%），这是由于地图中将会有多个敌人存在，而他们的脚步声可能会很吵闹（另外，怪物有可能是光着脚不穿鞋的，不是吗？）加载所有文件之后我们为声音设置了邻近跟踪，传入了该敌人的x与y坐标并告诉它追踪的目标为FlxG.camera.target对象（也就是我们的玩家）。最后我们告诉它声音的传播半径稍微比屏幕一半宽度多一点点，这样我们就能够听到稍微越出屏幕的敌人的声音。如此一来我们就能够听到 基于敌人与摄像机目标之间的距离 计算出的或大或小的脚步声了。接下来我们要在敌人的update()函数中，位于super.update()调用之后的位置检查敌人是否处于移动状态，并且没有撞到墙上去。如果他们处于移动状态，我们将把脚步声放到这个敌人所处的位置上（放置于其精灵（sprite）的底部，也就是它的脚上），之后开始播放脚步声。接下来我们跳到PlayState中，在PlayState中我们只需要一个声音文件，用于拾起硬币的时候播放，尽管你可以把它放到Coin类中，但是由于有可能一次会载入多枚硬币，并且我们实际上一次只能捡一枚硬币（所以音效不需要重叠（overlap）），把一个单独的硬币音效加载进PlayState可以为我们的性能节省一些开销。就像添加其他音效一样，初始化变量：在create()中加载音效：之后在playerTouchCoin()函数中，在if语句里添加：这一次我们将使用forceRestart，这样当玩家拾起紧挨在一起的多枚硬币的时候新触发的声音会紧接而上。剩下的音效由于都用于战斗阶段，所以会被放到CombatHUD类里面。假设你已经下载了CombatHUD类文件，那么这些音效的相关代码就已经在里面写好了，不过作为一种课后练习，去完整浏览一遍也是个好主意，这样做有助于你在下一个项目中更好的理解声音的工作方式。初始化变量：加载音效：也许你知道它们会被放在哪些地方使用了，但我还是要过一遍。于 initCombat 中：于 finishFadeIn 中：于update()函数中，位于三个按钮的按压判定相关的if语句（if(_fire), else if(_up), else if(_down)）中添加：于 makeChoice 中，位于 “命中” 的逻辑代码（在_damages[1].text = &quot;1&quot;;之后）的位置添加：于闪躲的逻辑代码中添加：再往下，如果玩家逃脱（位于cutcome = ESCAPE之后的位置）添加：于enemyAttack()中敌人的攻击命中玩家时：如果他们的攻击被miss了：最后，在 DoneDamageOut() 中，位于 outcome = DEFEAT 之后的位置添加：位于 outcome = VICTORY 之后的位置添加：添加声音的工作到此就结束了，编译并运行你的游戏，现在你可以听到我们添加的所有音效了（确保你把系统的声音打开了）下一节我们将使游戏可以跨平台运行。"},{"title":"HaxeFlixel官方教程11:游戏结束菜单","date":"2019-03-29T08:39:03.000Z","url":"/2019/03/29/HaxeFlixel官方教程11-游戏结束菜单/","tags":["HaxeFlixel"],"content":"这周情绪一天也没消停过，现在是 2019/3/29 15:06 我已经一周没去上课了，起床冲了咖啡，饭一顿也没吃，开始考虑是不是要去看医生。原文我们的游戏现在开始最后的整合阶段，现在我们需要为其添加一个胜负功能使其更像一个完整的游戏，对于我们这个简单的游戏而言，我们想要让玩家如果在战斗阶段死亡，则游戏结束，或者是玩家击败了Boss即获胜，这两个情况下都会跳转至同一个FlxState状态下，它将显示最终得分并允许玩家从这里重新开始游戏。让我们从PlayState开始，我们需要设一个flag用于检查游戏是否结束，以及玩家是否获胜：两个变量添加于类体的顶部。下一步，位于update()函数，super.update(elapsed)的调用后方的位置添加：我们在游戏结束时开始准备开始切换state，不需要做其他任何事情所以return。下一步，依然在update()函数中，把原来的逻辑代码修改为如下：这里所做的事情为检查结果是否为DEFEAT，如果是则设结束flag为真，并告诉摄像机开始渐隐（fading out），渐隐结束后调用doneFadeOut()。相似的，如果结果为VICTORY，并且被击败的敌人类型为1（也就是Boss），则设wonflag为真，并开始渐隐。当摄像机渐隐为黑色之后，我们将调用该函数，它用于切换状态至GameOverState（我们在之后添加该类），并传递玩家是否获胜的信息以及玩家收集了多少金币：我们需要添加GameOverState类。它是一个十分简单的FlxState对象，用于显示一些信息： “Game Over” 或 “You Win!” （显示哪一个取决于获胜flag的当前值）、以及玩家收集了多少金币。这里我们还将使用flixel的保存/读取功能用以比较历史最高分，如果当前玩家收集的金币比历史记录更多，我们将对当前分数替换历史最高分进行保存，并显示当前最高分。最后我们会添加一个返回按钮使玩家可以退回至菜单界面。这里是该类的源码：GameOverState.hx如果你开始测试你的游戏，你将可以通过于战斗阶段死亡或击败Boss而触发GameOverState，接着点击GameOverState状态中的按钮返回至MenuState状态，这样你就可以再一次开始游戏。如果游戏能够如以上描述的正常工作表明你目前没有偏离正轨。不过…目前我们的MenuState看起来有些乏味，所以我们开始为它添加些东西。让我们为它添加一个标题以及一个选项按钮（于MenuState.hx中）：接着，在create()函数中，我们把它添加至状态中（并移动原来的开始游戏按钮）：添加一个函数用于当选项按钮被点击时调用：当选项按钮被点击后切换的OptionState状态类也相当简单，它将包含一个按钮用于使玩家可以清空以保存的数据（如 历史最高分），以及一个简单的FlxBar拉动条用于表示当前游戏的音量级数以及一组按钮用于调整音量级数的高低。它将会保存当前音量的值，所以当游戏开始时它将会记住最后音量级数的设置（我知道我们的游戏现在还没有声音 ;) ）。该类的源码：OptionsState.hxOptionsState类使用了一组精灵序列供音量调节按钮使用（因为他们需要比默认的按钮更小一些），该资源文件需要包含3个帧，分别表现出按钮的三个状态：正常、高亮、以及被按下。我们只需要按此顺序排列这个精灵序列的各个帧，FlxButton会为我们处理剩余的工作。再一次，你可以自己做一个，或者使用下面提供的图像资源。将其放置于assets/images文件夹内即可。   最后，我们需要游戏每次开始时读取已保存的音量设置（如果当前有设置的话），跳转至Main.hx类，并在addChild()函数调用之后的位置添加以下代码：      十分简单，它创建一个新的FlxSave对象，将其绑定至我们的&quot;flixel-tutorial&quot;并在之后检查是否有音量值被存储进来，如果有，则将游戏的音量设为该值，之后关闭保存。测试游戏，确保正常工作，如果你在设置中修改了音量设置并退出游戏，它将会在下一次进入游戏时保留当前设置的音量值。看起来不错，下一节我们将添加一些音效与音乐。"},{"title":"HaxeFlixel官方教程10:UI与战斗系统","date":"2019-03-15T17:23:28.000Z","url":"/2019/03/16/HaxeFlixel官方教程10-UI与战斗系统/","tags":["HaxeFlixel"],"content":"原文由于这次内容涉及比较多东西，估计摸索的时间会比较长，文本我先翻译完先放上来，之后摸索完整理些细节再另外po一篇作为补充。现在我们需要让玩家知道他们在游戏中的行为产生了哪些影响。所以我们需要在屏幕中显示一个HUD用于告诉玩家 当前/最大 血量为多少，以及目前收集了多少金币。表示生命值的图标你可以使用这个图形资源：,确保你将图像资源保存至assets/images文件夹下。我们首先新建一个HUD类，它用于保存所有的HUD元素。这个类继承自FlxTypedGroup&lt;FlxSprite&gt;类所以它可以用于保存我们所有的FlxSprite对象。它由5个部分组成：背景（黑色，底部有一条1像粗细的白色细线），两个FlxText对象（一个用于生命值，一个用于当前金币），两个FlxSprite对象（用于在FlxText对象旁边显示图标）。在构造函数的函数体最后几行里我们调用了forEach()遍历当前Group的所有成员并将它们的scrollFactor.x与scrollFactor.y都设为 0，这么做可以使得摄像机在滚动的时候这些对象的位置也会停留在原地（相对于显示屏幕）。最后我们声明了一个函数使得从任意位置调用时告诉HUD应该如何显示。现在我们要让它开始实际工作并在玩家不论何时捡起硬币时更新数据。在PlayState类的顶部添加以下变量：在create()函数，于super.create()语句之前的位置添加：最后，在playerTouchCoin()函数体中的if语句中任意位置添加：接着测试你的游戏，HUD应该会在你每次拾起硬币的时候更新显示的内容。如果我们有一个使玩家的角色受到伤害的方式，那么我们也需要更新HUD显示的生命值，不过首先我们要确定玩家与敌人战斗的形式。现在让我们开始搭建我们的战斗系统。首先，在这里我们并不是要做一个如最终幻想那样庞大的战斗系统，这里只不过是对几个不同的元素如何工作做出一个基本演示。所以我想这里我们要做的是当玩家与敌人发生碰撞时，跳出一个界面，显示玩家与敌人当前的生命值（为了视觉上更为友好，数值显示于一管血条中），并为玩家提供两个选项：战斗或逃跑。如果玩家选择了战斗，我们将roll一个随机数用于判断玩家与敌人间的攻击是否击中了对方，如果击中了，将对对方造成一点伤害。如果敌人死亡玩家将脱离战斗状态。而如果玩家选择了逃跑，我们将以同样的方式判断玩家是否成功脱离，如果成功脱离战斗则关闭战斗界面，并使敌人在原地停顿几秒给玩家时间远离它。如果脱离失败了，敌人会乘机攻击玩家。我们还要在战斗界面显示当前攻击是否被闪躲或造成了多少伤害值。这些看起来很简单，但实际上这需要几个不同的部分相互协作来实现，他其实是我们到目前为止所作的最复杂的部分。第一个部分是CombatHUD类。这是一个庞大的类，战斗系统主要的逻辑代码都交由这个类完成。你可以在这里查看完整的源码：CombatHUD.hx花点时间完整的查看这个类的源码搞清楚它是如何工作的，之后再将它添加进你的项目里。我们现在已经有了供CombatHUD类使用的大部分资源文件，但是我们还需要一个图形文件，用于当玩家做选择时显示的箭头图形。你可以在这里下载（点击download）（或者自己做一个），确保文件名为pointer.png并把它保存至项目文件夹内的assets/images文件夹内。CombatHUD类中还使用了一些我们尚未讨论的东西：声音。我们将会在 “声音与音乐” 章节对此进行更深入的探讨，现在请先将以下这些文件下载assets/sounds文件夹下，这样才能让源码正确编译。这我就不单独罗列了，github上有，把链接里全部wav文件都下下来：链接现在你需要为Enemy类添加一个简单的函数：接着我们需要把CombatHUD对象添加进PlayState类中，把以下代码添加至PlayState类的顶部：移动到create()函数的位置，在函数体中，在我们添加（add）HUD之后，调用super.create()之前的位置添加以下代码：移动到update()函数的位置，将其修改为仅当处于非战斗状态时才进行碰撞与重叠检测。位于super.update()调用之后的所有东西应该如以下代码所示：这里我们要添加一个条件检测，用于检查玩家是否碰到一个敌人，如果是则调用回调函数以查看我们是否应该开始战斗。如果我们处于战斗阶段，我们就持续检测HUD当前是否为可见的，当它为不可见时我们就知道战斗结束了，之后我们就可以对结果进行结算，当结果为VICTORY（我们的四个枚举值的其中一个）时，我们就杀掉敌人（_combatHud.e.kill()），而当玩家选择了逃跑，我们将使该敌人闪烁，用于表示玩家从这一刻起的一小段时间内将是安全的不会与该敌人再次触发战斗。你可能已经发现了我们的Enemy类并没有flicker()函数（注），这是因为我们将使用FlxSpriteUtil类的一个函数来实现这个功能，Haxe提供了一个很nice的语法特性来帮我们完成这个工作。那么在PlayState类文件的顶部，位于其他导入语句（import）之后，添加一行代码：这将使得我们可以使用FlxSpriteUtil的APIs，如flicker()函数，它可以被用于任何FlxObject对象。具体技术细节参考官方文档-静态扩展。注：_combatHud.e.flicker()的调用使用了Haxe的语法特性-*静态扩展*，使得我们的Enemy类本身即使没有flicker()函数也可以通过外部类进行扩展。接下来让我们添加一个函数用于处理当玩家触碰到一个敌人的情况：我们在这里检查玩家与敌人的alive与exists属性是否都为true并且敌人不处于闪烁状态（闪烁状态下的敌人是那些我们刚刚脱离战斗状态的敌人）。如果条件都满足，我们就使之进入战斗状态。startCombat()函数所做的事情是设置我们的inCombatflag进行赋值（这样做使得我们可以知道是否进行碰撞检测），并使玩家与敌人都进入非活动状态，这样它们将停止逻辑代码的更新（暂停update()的调用）。最后我们调用initCombat()函数，使得CombatHUD初始化并开始工作。最后的最后，我们要使闪烁的敌人原地不动，它们应该在玩家逃跑后停顿几秒。在Enemy类中，于update()函数体内添加以下代码：把这段代码放在函数体的第一行的位置，优先于函数体内其他语句执行。注意isFlickering()函数同样来自FlxSpriteUtil类，所以如前面的做法，需要在Enemy类中添加一行using语句：这样就ok了，测试游戏确保能如期正常运行！下一节我们将涉及获胜于失败状态（PlayState是游玩状态），并整合我们的所有状态（state）。"},{"title":"HaxeFlixel官方教程9:敌人与基础AI","date":"2019-03-07T17:39:49.000Z","url":"/2019/03/08/HaxeFlixel官方教程9-敌人与基础AI/","tags":["HaxeFlixel"],"content":"原文如果地牢游戏里没有敌人的话就太名不副实了，所以现在我们来添加一些敌人进去！现在为你的 Ogmo 项目添加一个新的实体（entity）- 你很快就会习惯于这个工作流：确保你添加了etype值。接着在地图里散布一些敌人，确保其中有且只有一个敌人的etype值为1，其余为0那么我们想要游戏中存在两种类型的敌人，我们需要为它们提供两组精灵序列图，同样是16x16像素大小、与我们的player精灵序列图一样数量的动作帧。把它们命名为enemy-0.png与enemy-1.png，并保存至assets/images文件夹下，一下提供这两组精灵序列图给你使用（再次感谢 Vicky 为我们创作的图形资源！）：注意：确保你的两个精灵序列图以相同方式工作，它们在每个朝向上（facing）的动画都应该有相同数量的帧。现在让我们来添加一个Enemy类，这个类整体上与我们的Player类十分相似，其中有几处改动：主要的不同点在于现在我们有一个新的etype变量，它被我们用于确定哪个enemy的精灵序列图将要被加载，以及我们将处理哪一个精灵等等。接下来我们需要在PlayState中创建一个FlxGroup实例，用于保存我们的enemies对象并把他们加载进地图内，与前面章节对coin对象的操作极为相似。位于类的顶部添加：在构造函数中，位于coin组的实例化之后的位置添加：然后在placeEntities()函数中位于 if/else 语句之后的位置添加：接着编译一下游戏测试一下敌人是不是被正确的添加至游戏中。现在让我们给敌人创造一个大脑。为了让我们的敌人能够“思考”，我们将要应用一个简单的 有限状态机（Finite-state Machine(FSM)）。简单来说，可以把一个FSM看成是一个一次只能表现一个状态的机器或实体，对应地我们将给予我们的 enemies 对象两种可能存在的状态：渡步（Idle）与追逐（Chase）。当它们看不到玩家时，它们将处于渡步状态下，即无目的的在四周徘徊。直到玩家出现在它们的视野范围内，它们将切换为追逐状态，朝玩家所处位置跑动。这应该不会很难，首先让我们来创建一个FSM类：接着我们稍微对Enemy类做一点修改。我们需要在类的顶部定义以下这些变量：并在位于构造函数的末尾处添加：接着添加以下几个函数：其工作方式是这样的：每个敌人将以Idle也就是渡步状态生成，在PlayState中每一个敌人将时刻检查是否看到玩家，如果看到了，它将切换至Chase也就是追逐状态，直到不再能够看到玩家为止。当处于Idle状态下，通常（随机间隔内）选择一个随机的朝向移动（以及一个小概率的止步不前）。当处于Chase状态下时它们会朝玩家所处位置移动。让我们跳回到PlayState类中，添加检测玩家的视野范围的逻辑代码。在update()函数中位于重叠与碰撞检测的代码之后的位置添加：接着添加checkEnemyVision()函数：至此就完成这一节的所有工作了，编译运行你的游戏确保它能正常工作！下一节，我们将为游戏添加一些UI，以及一个 RPG 类型的战斗系统，这样玩家就能够与敌人进行战斗了！"},{"title":"蛋疼的迁移过程","date":"2019-03-05T17:28:15.000Z","url":"/2019/03/06/蛋疼的迁移过程/","tags":["学习记录"],"content":"因为某些原因想要丢掉原来的GitHub账号还有博客，换身皮囊再继续。隔了一天的关系迁移过程有点模糊没什么头绪，我先罗列一下：更改本地的GitHub账号绑定SSH新建一个Repository重新部署博客（迁移博客配置文件、迁移博客主题配置文件、安装插件等）在我做完 1、2 、3 之后我新建了一个文件夹用于重新生成博客（hexo init），之后尝试进行第 4 步操作。结果大概如下所示：似乎是由于部署博客的过程里往仓库 push 的时候被自动使用了旧账号进行操作，在这之后的2个小时里我不断更新 SSH key 、删掉博客的本地文件再 hexo init 反复折腾，最后发现只需要打开 GitHub Desktop 更新账号，把放博客的新 repo 给 clone 下来就行（重启电脑前不行，重启之后再尝试博客就成功部署上去了）部署完不算完，因为我以为每次迁移博客都需要重新 hexo init 所以新博客现在是空的，我原来旧的那些文章都还没放进去，虽然都是食之无味弃之可惜，但是。。。弃之可惜嘛。。。所以我把备份好的 .md 文件直接丢到新博客的 post 文件夹里生成。。。结果又出事了，只有靠前的两三篇文章标题正确显示，剩余的全是“no-title”；这个情况在之前也碰上过，但是由于每次码字都累爆，上传又遇上这种情况就会心烦气躁地 “备份-删除-重新上传、复制-粘贴-重新上传” 地折腾个三四十分钟，问题往往莫名其妙地就能解决。但是这次我怀疑的对象不再是文件本身，我怀疑是 hexo 生成的页面会根据 hexo new &quot;article title&quot; 时生成某个文件、保存文章标题来进行显示。然而事实是我想多了。事实上每一次的 hexo new &quot;new article&quot; 生成的 .md 文件里都会自动生成出如下内容：估计 hexo 生成的页面就是通过这里的 title 获取文章标题进行显示的（我真的很不乐意学HTML之流，我甚至觉得它们比C++还麻烦 :P ），而我在云端备份的文章里都没把这一段内容放进去，所以生成的页面找不到标题就默认给了 no-title 。哦对了，想起来一个事儿，在我直接放 .md 文件生成博客之前我看了 hexo 官网的文档，里头提到迁移文章的一个插件“hexo-migrator-rss” ，需要通过npm install hexo-migrator-rss --save 安装之后使用，他可以从RSS迁移所有文章，命令如下：source 可以是文件路径或网址，也就是指向某个“atom.xml”文件就行了，所以我试了一下，结果文章确实都被取回来了，但是都是根据.xml文件的内容生成的，文章内嵌入的图片资源都没能获取到，原因不明。似乎很麻烦所以很快就考虑其他解决办法。接着我意识到这一切都与是否生成一个新博客不相关的，你要做的只是在博客的配置文件里更改 url、root（可选）、deploy的参数，部署的时候 hexo 只看你的 deploy 参数而已，于是我滚回原来存放博客的文件夹里修改了配置文件，重新部署了一下。。。至此迁移工作就完事儿了，挺蛋疼的，30分钟的事情我弄了3个小时，尽管多多少少还是有所收获吧。"},{"title":"作废，迁移","date":"2019-03-02T17:20:21.000Z","url":"/2019/03/03/作废，迁移/","content":"从原来的地方搬到这里来了，回头记录一下迁移过程（有点蛋疼），明天还有课已经凌晨两点半了，该睡觉了，晚安:)"},{"title":"时隔多日再水一篇","date":"2018-09-05T15:18:15.000Z","url":"/2018/09/05/时隔多日再水一篇/","tags":["HaxeFlixel"],"content":"这篇博客本该在几日前写完的，开学前应一老友所需码一篇关于HaxeFlixel开发环境搭建的文章，无奈开学这两天没太适应过来拖延到今晚才开始有心情码字，实际发布时间会晚于tag所标示的时间。以下是本次要安装的各种工具：Haxe工具集LimeOpenFLFlixelFlixel ToolsVisualStudioVisualStudioCode安装Haxe工具集与其他依赖项首先，登陆Haxe的官网haxe.org下载安装包，安装内容包括一个Haxe的跨平台编译器，一个标准库以及一个命令行工具“haxelib”，它是一个包管理工具，可以用于提交和检索可用的库，目前我只用它来安装一些依赖项而已，下面开始安装其他依赖项。打开PowerShell或者CMD，依次执行以下指令：注意：如果下载过程报错中断显示超时，那么搭个梯子试试或者在命令中加入参数haxelib -notimeout &lt;command&gt;以取消超时。Lime是OpenFL用于跨平台编译的一个底层支持，主要用于给不同平台（如Flash，HTML5，C++）提供输入，音频，渲染上下文，网络访问提供统一的底层支持，具体的技术细节我也还没搞懂，所以就不多说了。Flixel原本是由Adam “Atomic” Saltsman以ActionScript3.0写就的一套Flash平台的游戏开发框架，由于后来Flash平台日渐衰落，所以喜爱Flixel的人就开始考虑把它移植到其他平台去，正巧Haxe社区已经有人做了Flash整个API的移植版本——也就是OpenFL，于是Flixel就顺其自然的被移植到了Haxe平台上，这样既能做到原来Flash平台做不到的跨平台开发（Adobe在Flash衰落的日子里主动放弃了很多跨平台的支持），同时又能让原来Flash平台上的开发者通过熟悉的API快速上手，投入Haxe平台的怀抱。好了，一点点介绍说完了，当以上东西都下完之后再执行以下命令：它会检查你的lime和opemfl是否为最新，以及其他Flixel相关的库（主要是插件，DEMO，UI，模板）。如果你跑了以上命令，那么Flixel Tools已经被安装了，但是我们需要启动它：它将会询问你两个问题：是否使用命令别名（用于快捷输入，我都是启用的）：y/n使用的默认IDE（我们使用VSCode，设置之后通过命令创建模板后将自动通过所选择的编辑器打开）：这里我们选择VisualStudioCode。它同样也是一个命令行工具，之后我们新建项目或下载flixel相关的其他库都将通过它来完成。到这里先通过几条指令来检查所有东西是不是都安装正确了：依次执行以下指令如果如下图所示则表明所需要的东西都安装完毕。安装VisualStudio若想将游戏编译至C++平台上HaxeFlixel似乎只能用MSVC编译器，所以需要安装这个庞大的东西，那么上官网 VisualStudo ，目前推荐安装最新的 Community 2017 版。下载完打开，然后选中如下图所示的勾选项但其实我们需要的是VC++的编译器，所以也可以只勾选VC++ 2017 工具安装完直接把VS关掉就行。安装VisualStudioCode我们使用VisualStudioCode（VSCode）作为我们的代码编辑环境，同样登陆VS官网，点击如下图所示下载VSCode：安装完成后打开VSCode打开左侧边栏中的扩展：如图所示搜索Haxe，选中Haxe Extension Pack并安装，之后再搜索Lime并安装Lime插件：完成后重启VSCode。测试项目至此万事俱备，我们再次打开PowerShell，输入以下指令新建一个HaxeFlixel项目：这里使用默认模板，并以”HelloWorld”命名在当前目录创建一个新的项目。命令tpl是template的别名，如果在haxelib run flixel-tools setup时启用了别名则可以使用tpl作为缩写快捷输入，default模板在我们执行haxelib run lime setup的时候下载好了，通过它我们可以在使用Flixel命令行工具创建项目时自动生成所需的配置文件，VSCode的配置文件存放于.vscode文件夹下，具体了解看官网文档，同样模板的自定义我自己也没研究过在这里就不讲了，官网资料或者论坛或者StackOverflow或其他什么方式，自己动手丰衣足食。动手检查一下Haxe插件是不是工作正常，主要是看看代码提示和补全，随便在那一行哪一个位置Ctrl+Space可以激活VSCode的IntelliSense，如果出现没有提示的情况，看看界面左下角是不是显示Building Cache，如果是这样的话参考我的上一篇博文。到这里应该没什么问题了，如果我什么时候想起来要补充点什么再回来更新，晚安 :)"},{"title":"摸鱼一把","date":"2018-08-16T14:33:13.000Z","url":"/2018/08/16/摸鱼一把/","tags":["学习记录"],"content":"解决了VSCode的Haxe插件时不时卡死building cache，导致代码提示功能无法正常工作的问题。打开VSCode文件 -&gt; 首选项 -&gt; 设置在右边窗口用户设置内添加:以覆盖默认设置，一个不知所云的热修复，问题暂时得到解决。再就是搭建了一个Haxe的学习环境，.vscode文件夹下配置文件为：task.json:launch.json:最后，博客的关于页上分享了我的邮箱地址，有兴趣交流的朋友可以通过邮箱地址联系我，其实只是想知道到底有多少人在看 = ="},{"title":"HaxeFlixel官方教程8:拾取物品","date":"2018-08-04T17:22:54.000Z","url":"/2018/08/05/HaxeFlixel官方教程8-拾取物品/","tags":["HaxeFlixel"],"content":"原文目前我们有一个小家伙可以在地图内自由行走，让我们为它添加一些可以拾取的东西。我们将要添加一些硬币，当玩家拾起的时候会计入分数。再一次打开你的Ogmo项目，然后打开Project &gt; Edit Project选项卡。在‘Entities’选项卡内添加一个新的实体。选中 ‘entities’ 图层，在地图中散布一些硬币：我们将使用8x8像素作为硬币的大小，硬币的图像资源你可以使用这个,或者是你自己画一个，然后保存至assets/images文件夹下。回到VSCode，新建一个新的类：6. Coin类十分简单，我们只需要修改一下构造函数：   现在回到PlayState类中，我们需要修改一下地图加载的逻辑代码，让它从Ogmo文件中加载实体时如果发现coin将会把Coin对象加入当前状态（state）。首先让我们创建一个FlxGroup对象用于存储所有的硬币，在类中定义所有全局变量的地方添加以下代码：FlxGroup类似一个存储Flixel对象（Flixel Object）的数组，以供在许多需要的情况下使用，在这里我们用它来存储所有的硬币所以以FlxTypedGroup&lt;Coin&gt;形式声明。在create()函数中位于初始化player之前，添加墙体之后的位置，我们从这里初始化硬币组（coin group）并将其添加至当前状态：接下来我们需要修改placeEntities()函数，让其从Ogmo文件中读取到”coin“实体时将其添加进组中，位于我们的if语句的末尾添加以下代码：这样做将告诉程序创建一个coin对象，将其放置于Ogmo文件中所定义的位置（对其x值+4，y值+4，使得硬币位于瓦砖的居中位置），之后将这个coin对象添加进组。现在我们需要player能够拾取这些硬币，我们将通过检查重叠情况（overlap）的方式来实现，在update()函数中位于FlxG.collide()调用之后的位置添加以下代码：这么做是告诉程序：在每一帧检查player与硬币组之间的重叠情况，如果发生重叠，则调用playerTouchCoin()函数。现在我们来实现playerTouchCoin()回调函数：这个函数检查player与硬币之间是否发生重叠且两者之间的alive与exists属性皆为true，如果是，则对硬币调用kill()函数（我们稍后会添加计分功能）。如果你现在运行游戏，当你在地图内行走时触碰到的硬币将会消失。很好，但是有点无趣，让我们为其添加一点小样式。回到Coin类中添加以下几个函数：目前为止遇到一些Haxe语法上的问题待解决暂时先翻译到这里，我先去看看Haxe官方的文档。"},{"title":"HaxeFlixel官方教程7:摄像机与缩放","date":"2018-08-02T09:33:46.000Z","url":"/2018/08/02/HaxeFlixel官方教程7-摄像机与缩放/","tags":["HaxeFlixel"],"content":"原文当你开始运行你的游戏，你将会看到，目前场景内的所有东西看起开都非常非常小，我们将要通过设置缩放来改变游戏内物体的能见度，以此让玩家得以看清角色每个细微的动作。要做到缩放很简单：打开Main.hx文件，这个类用于游戏的初始化工作，如果你想要的话看看有哪些东西你需要修改的，但这里我们只需要改变其中的几个参数。修改new FlxGame()的宽度与高度参数为320与240（原来的值的一半）。如果你现在开始运行游戏，你将看到所有东西都被放大了，但是player会越出屏幕的可视范围，因此我们需要告诉摄像机紧跟player的当前位置，再一次打开PlayState文件。在构造函数内，位于添加player之后，super.create()之前的位置添加以下代码：这样做将会告诉摄像机以TOPDOWN视角跟踪player的位置，以1为取值赋给lerp参数（这样做将会让摄像机的移动更为平滑一些）完事了！测试游戏的运行结果看看效果如何。下一节，让我们为player添加一些可以在地图内拾起的东西。"},{"title":"HaxeFlixel官方教程6:加载Tilemap","date":"2018-08-02T08:07:00.000Z","url":"/2018/08/02/HaxeFlixel官方教程6-加载Tilemap/","tags":["HaxeFlixel"],"content":"原文搭配Ogmo与HaxeFlixel框架一起使用的其中一大好处就是它内置了一些类用于加载与使用tilemap，这些类并不是来自HaxeFlixel框架的标准库，所以我们需要安装 flixel-addons 库才能访问到这些类。打开命令提示符键入以下命令：haxelib install flixel-addons正确运行后haxelib命令行工具将会开始安装一个新的库，下载安装后关闭命令提示符。回到 VisualStudio Code 中打开Project.xml文件，我们需要告诉我们的项目引入 flixel-addons 库。查看如下所示的那一行（VSCode中可以按F3打开查找框，键入关键字符合条件的行会高亮显示）：&lt;!--&lt;haxelib name=&quot;flixel-addons&quot; /&gt;--&gt;修改为以下所示：&lt;haxelib name=&quot;flixel-addons&quot; /&gt;保存修改，现在你已经可以使用 flixel-addons 库了（在我这边最近VSCode的Haxe插件有点问题需要重启VSCode）。回到PlayState类中，在_player变量的定义下方添加以下代码：备注：需要import flixel.tile.FlxTilemap;以及import  flixel.addons.editor.ogmo.FlxOgmoLoader;，从现在开始需要import新类的地方我不再提示，若自己动手的过程里出现找不到类之类的问题，检查是否忘记import了，不知道某个类在哪个包下就看看官方API文档，搜索栏里找一下相关的类。这里我们告诉程序创建一个用于存储我们的 Ogmo map 的对象，然后再创建一个将从 Ogmo map 生成的FlxTilemap对象。如果你现在使用的是Tiled作为创建地图的编辑器，把_map变量的类型改为TileMap。在create()函数里，建立player对象之前的位置添加以下代码：这里将我们上一节中创建的地图文件加载进FlxOgmoLoader对象里，之后从它的 ‘walls’ 图层生成我们的FlxTilemap对象并设置其第1块瓦砖（序列图中表示地板的那一块）为不进行碰撞检测，第2块瓦砖（序列图中表示墙体的那块瓦砖）为从任意方向进行碰撞检测。接着将我们的 tilemap 添加进当前状态（PlayState）。如果你使用的是Tiled，替换为以下代码：现在，我们需要把我们的player放置于地图中正确的位置上，所以下面把对player实例化的代码：替换为：我们告诉_map对象遍历其‘entities’图层，并从中调用回调函数placeEntities()（我们稍后将实现这个函数）。TiledMap没有内置的loadEntities()函数，所以我们需要自己实现一个：现在我们开始实现placeEntities()函数，当我们对地图调用loadEntities()函数的时候，它会传递一个实体的名字以及该实体的 XML 数据到某个我们需要的函数中。在我们的函数中我们需要利用这些信息做一些工作，代码如下：当这个函数被传递进一个实体的名字为“player”的时候，它会把player对象的x和y值设为该实体的x与y值（将他们的值从String类型转换为Int类型）。现在我们需要为当前状态添加碰撞，以此让player遇到墙体的时候会一头撞上而不是穿行而过。在update()函数中，位于super.update(elapsed);的后一行的位置添加以下代码：这行代码所做的事是在update()中不断检查player与墙体之间的重叠状态，如果当前两者有任何重叠的情况发生，那么两个对象将会自动分离开。最后，我们需要对player进行一些微小的调整，让玩家以更好的时机越过大门是个好点子；默认情况下，我们的player sprite是与其瓦砖大小相同的（16x16像素），这会让player越过大门的时候仿佛需要挤过如针缝大小的门，我们通过改变sprite的大小与偏移量（offset）来补救这一问题。这么做并不会改变player实际显示的图像，只会改变其碰撞盒（hitbox）的大小。在Player类的构造函数构造函数里，位于设置drag值的代码下方，添加以下代码：备注：依我的结果来看以上代码需要在loadGraphic()之后添加才能正确设置碰撞盒。由于我的drag放置的位置先与loadGraphic()所以按教程的步骤结果碰撞盒的位置并不正确现在运行你的项目，你已经能够控制player在地图内走动了。下一节，我们将对摄像机（camera）进行一些微调。"},{"title":"HaxeFlixel官方教程5:创建Tilemap","date":"2018-07-31T09:23:09.000Z","url":"/2018/07/31/HaxeFlixel官方教程5-创建Tilemap/","tags":["HaxeFlixel"],"content":"原文现在，是时候为player创建一个可供活动的环境地图了！我们将使用一个叫 Ogmo Editor 的工具来创建 Tilemap；Ogmo是一个免费的 Tilemap编辑器，可以非常完美的与HaxeFlixel框架协作，对于这节教程而言，我们将创建一个只有 2块瓦砖 的 Tilesheet，用于表示墙体和地板。你可以自己画一个16x16大小每块瓦砖的序列图，或者使用这里的图形资源：（注意：该序列一共有3块tile，第一块tile应该是透明的）首先访问此链接： 下载安装并运行编辑器。注意：Ogmo 只有Windows版本，如果你想使用其他的编辑器，你可以试试Tile，他也是一个免费的编辑器，但是功能稍微复杂一些。从Project &gt; New Project创建并选择一个名称命名一个项目，保存至assets/data文件夹下。按以下所示对每一个选项卡进行设置：![](HaxeFlixel官方教程5-创建Tilemap/1.png)![](HaxeFlixel官方教程5-创建Tilemap/2.png)![](HaxeFlixel官方教程5-创建Tilemap/3.png)![](HaxeFlixel官方教程5-创建Tilemap/4.png)![](HaxeFlixel官方教程5-创建Tilemap/5.png)点击Apply保存你的修改，目前窗口应该如下所示：![](HaxeFlixel官方教程5-创建Tilemap/6.png)确保你已选中“walls”图层，然后通过右边工具栏选择所需工具来绘制一个简单的地图。确保地图以walls瓦砖闭合（这样player就不能越出墙体的范围），并且以floor瓦砖将其填满。最后的地图应该如下所示：![](HaxeFlixel官方教程5-创建Tilemap/7.png)现在切换至“entities”图层，然后将player瓦砖放置其中一个房间的某处：![](HaxeFlixel官方教程5-创建Tilemap/8.png)通过Level &gt; Save Level保存，以room-001.oel命名，保存至assets/data文件夹内。地图的创建工作到此就完成了，确保你已经保存修改，然后退出。下一节，我们将学习如何加载一个新创建的tilemap到游戏里。"},{"title":"一点整理","date":"2018-07-29T16:58:48.000Z","url":"/2018/07/30/一点整理/","tags":["HaxeFlixel","学习记录"],"content":"对前面学习过程中感到疑惑的部分做了一些研究，在这里把这些东西记上一笔，加深印象同时便于日后查阅。第3节基础工作中，对角色的移动通过给FlxSprite对象的velocity（继承自FlxObject类）属性进行赋值:velocity.set(speed,0)来实现，需要注意的是虽然FlxSprite对象的velocity属性是FlxPoint类型，但是它并不是用于表示当前FlxSprite对象的坐标点。HaxeFlixl对FlxPoint类型的描述：Stores a 2D floating point coordinate.（存储一个以浮点数表示的二维坐标系内的点的坐标）当通过velocity.set(speed,0)对velocity进行赋值之后，FlxSprite对象会以speed值作为x轴的速度，以0为y轴的速度进行移动，之后我们通过velocity.rotate(FlxPoint.weak(0,0),angle)对velocity的x和y进行旋转，rotate()函数具有两个参数，Pivot和Angle；这个函数通过一个给定的旋转支点对该FlxPoint对象以给定角度进行旋转，这里需要再强调一次，记住:FlxSprite的velocity属性不用于表示其坐标！而是表示该FlxSprite对象当前的x轴与y轴的移动速度；事实上当使用FlxSprite的velocity实现sprite的匀速运动时，还需要配合FlxSprite的另一个属性drag使用，该属性继承自FlxObject类，对其赋一个合适的值来使velocity归零，归零的速率由drag的取值决定；所以velocity的x,y值归零状态下都是在游戏画布的左上角（也就是(0,0)坐标点）也就是velocity的起点，那么当我们对其进行旋转时为了方便我们需要让旋转中心与velocity的起点重合，所以在使用velocity.rotate()时我们对第一个参数传递一个处于(0,0)坐标的FlxPoint对象作为对其进行旋转的旋转中心。由于之前对velocity进行旋转操作时认为旋转中心应该位于sprite的中心位置，进而发现实验结果与期望不符，通过查阅官网的API文档有了以上的发现，下面让我们抛开FlxSprite的velocity属性，以一个普通的FlxPoint对象进行旋转操作加深理解：打开命令行窗口，输入flixel template &quot;default&quot; -n &quot;FlxPointTest&quot;之后回车，在当前目录下创建一个以默认模板生成并命名为“FlxPointTest”的HaxeFlixel项目。之后自己画一个16x16大小的方块以PNG格式保存至项目文件夹下的assets/image文件夹内，图方便的话可以用我这里做好的：![](一点整理/Point.png)然后在source文件夹内创建一个新的haxe文件，命名为Player.hx。然后拷贝我下面的代码进去：接着修改source文件夹下的PlayState.hx：blockSet数组用于存储Player类的实例，position是一个FlxPoint类的实例，用于实例化Player实例的时候传入Player实例的初始坐标。第一个循环体是这次实验的关键，创建四个Player实例，初始坐标使用position的x和y值，每个Player实例之间都以画布的中心位置为旋转点对position进行90度旋转。以下为运行结果：![](一点整理/results.png)"},{"title":"HaxeFlixel官方教程4:精灵序列与动画","date":"2018-07-27T09:19:10.000Z","url":"/2018/07/27/HaxeFlixel官方教程4-精灵序列与动画/","tags":["HaxeFlixel"],"content":"原文目前，我们有了一个可以在屏幕中自由走动的 player 了，这很好，但是我们不希望它看起来只是一块蓝色方块，所以让我们为它添加一些图像。首先选择一个你希望使用的图像编辑器（我用的是 Aseprite 在steam上可以购买）；你可以画任何你想要画的东西，然后把它保存为带透明通道的.png格式。我们的精灵序列将由16x16像素大小每帧组成，角色面朝四个可能的方向上都有两个不同的帧（面朝左和右我们将使用相同的两个帧，因为我们稍后会翻转它们）你可以自己画，或者使用我朋友 Vicky Hedgecock 为这个教程创建的图像文件：将你的文件保存至assets/images文件夹下。现在我们需要把 player 的图像文件加载进 sprite。所以再一次打开你的Player类。从构造函数中删掉makeGraphic()函数的调用，用以下代码取而代之：这样做将会告诉你的 sprite 使用player.png文件作为其显示用的图像，而且是带动画效果的，长和高为16像素。AssetPaths是一个由整洁的Haxe宏生成的类，它根据Project.xml的assets标签的内容构建变量。（由谷歌翻译，原句放下面）。宏稍微有些复杂，但是在某个节点上值得深入研究一下，但在这里我们先只是将AssetPaths视为一个便于在代码中引用我们资源文件的手段。原句：AssetPaths is a class generated by a neat Haxe macro which builds its variables from the contents of your Project.xml‘s assets tag.接下来，我们需要允许 sprite 基于其朝向进行翻转。这样做便于精灵序列节省一组朝向（只需要朝左）的帧，而不需要两组（既有朝左又有朝右）。添加如下代码：这两行代码意思是当 player 面朝左侧时不做任何翻转（因为我们的精灵序列里已经有面朝左侧的状态了），当 player 面朝右侧时进行水平翻转；如果我们想要的话，可以用相同的方式进行上下翻转。现在我们需要基于精灵序列定义一组动画，在此例中我们要每个动画都以一个过渡动作（精灵序列中双脚平行的那一帧）结束动画序列的播放。因此需要在 player 每一段动画结束时都会返回至正确的帧。添加以下代码： 对构造函数的修改到此就完成了，还有最后一步，修改movement()函数告诉 player sprite 作何朝向。所以，让我们对设置 player 角度的那节代码稍作修改，修改之后看起来如下所示： 每当这个函数被调用，它将会检查当前哪一个方向的按键被玩家按下，并基于判断决定 sprite 目前应该是哪个朝向，应该使用哪段动画。保存修改，然后运行项目你将看到你的 player 在运动时有了动画而且动画朝向正确。下一节，我们将对地图与碰撞进行讨论。次日更新补充：昨晚检查运行结果发现sprite的动画实际与教程中所述有出入，事实上在animation.add()添加动画时，若传递的Looped参数值为false那么当调用animation.play()时动画序列会根据Frames参数传入的值，定义动画序列，逐帧播放一次，最后止于最后一帧的位置，如教程中角色朝向左右两方时使用的是animation.add(&quot;lr&quot;,[3,4,3,5],6,false)这样的调用，其Frames参数传递的是一个Array类型的值：[3,4,3,5]，用于表示角色朝向左右两方时使用的动画序列，且Looped值为false这意味着动画不循环播放，那么当玩家按压左右方向键时sprite会按精灵序列图的第3，4，3，5帧顺序播放，当玩家松开按键时动画会从当前帧继续播放至第5帧后停止，再举个例子当player朝向上方时根据教程给出的定义，animation.add(&quot;u&quot;,[6,7,6,8],6,false)如此Frame值为[6,7,6,8]那么当玩家释放上方向键时sprite的动画会播放至第8帧的位置停止；player面朝下方时定义的动画序列为[0,1,0,2]，当玩家松开按键时动画播放至第2帧位置后停止。为解决这个问题我翻找了一下原教程的项目源码，发现不知道是原作者疏忽还是在教程后续才补充的原因，总之在这一节教程中漏了一段代码，这段代码用于实现这一节教程所说的 “我们要每个动画都以一个过渡动作（精灵序列中双脚平行的那一帧）结束动画序列的播放。因此需要在 player 每一段动画结束时都会返回至正确的帧。”，那么下面给出解决这个小bug的方法：在Player类中判定用户输入的那条条件语句if(_up || _down || _left || _right)之后的位置添加以下代码：curAnim表示当前使用的是那一段动画序列（此节教程中定义了三段动画序列分别是 “lr”，”u”，”l”），curFrame表示当前动画序列的哪一帧（动画序列的帧索引从0开始）。注意：curFrame并不表示整个精灵序列的帧索引，而是通过animation.add()定义的动画序列的帧索引，比如通过animation.add(&quot;lr&quot;,[3,4,3,5],6,false添加的动画序列有4帧，那么当sprite使用lr这段动画序列时对animation.curAnim.curFrame赋值为0，sprite实际上显示的是整张精灵序列的第3帧的图像。所以这段代码的意思就是当玩家不按压任何移动按键时则判断当前动画序列是否不为null，是则将当前动画序列的当前帧设为0，并暂停动画序列的播放。由于三段动画序列的第一帧位置分别是：3，6，0 ，也就是精灵序列中角色立定状态的图像，所以当玩家不进行任何移动操作时，sprite的动画都能返回至正确的帧（立定状态）。"},{"title":"HaxeFlixel官方教程3:基础工作","date":"2018-06-13T17:11:48.000Z","url":"/2018/06/14/HaxeFlixel官方教程3-基础工作/","tags":["HaxeFlixel"],"content":"原文现在，是时候思考一下我们要做什么样的游戏，以及我们要如何去实现。我们将要做一个十分简单的回合制的“地牢行者（dungeon crawler）”小游戏，玩家将控制一个角色在地图内自由行走，与敌人战斗并收集金币。所以，我们要如何将这些设计转换到 HaxeFlixel 中实现？首先，我们需要我们需要为我们的游戏建立一个“世界” - 也就是说我们需要一个FlxState对象作为一个容纳游戏内容的容器。接着是地牢的设计，我们将使用FlxTilemap对象来表示地牢，地牢的地图我们会使用另一个工具来绘制我们将使用一个FlxSprite对象来表示玩家的角色，他是一个被玩家控制的精灵序列（sprite）。敌人也是使用FlxSprite对象来表示，而且我们将会用一种特别的方式实现几种不同类型的敌人。我们当然还需要一套 HUD/界面接口 用于方便玩家知道自己做了哪些事情产生了哪些结果。我们将通过组合FlxGroup，FlxSprite，FlxText，FlxButton对象与其他一些东西来实现。我们将会把以上这些工作一个一个实现。首先，让我们先来创建一个简单的菜单，在最后我们会实现一个复杂的MenuState提供按钮以实现更多选项，但是目前我们只需要一个显式“Play”的按钮其功能将实现从菜单切换至PlayState。删除我们前面为PlayState添加的”Hello World”测试的代码。现在在PlayState.hx文件所在的同一个文件夹下创建一个新的文件命名为MenuState.hx（未填写）。然后你只需要把PlayState.hx中的代码拷贝进这个文件里（但是把类名改为MenuState）：在类声明之后，我们要定义一个新的变量，你在想要在这个类的任何位置中使用的变量都应该在这个地方定义，我们现在要定义一个FlxButton类型的变量，作为我们的“Play”按钮，所以在这个位置输入：注意：如果你使用的是 FlashDevelop ，那么现在IDE会因为你的FlxButton变量的定义而自动在类声明的上方加入一段 import 代码（import flixel.ui.FlxButton;），如果跟我一样是用 VSCode 的话那就自己手动码一下吧。现在，在create()函数里位于super.create()的前一行敲入以下代码：这将会创建一个FlxButton对象并赋值给_btnPlay变量，我们告诉他要在(0,0)坐标位置（在游戏画面的左上角）处创建一个按钮，并在其上显示 “Play” ，当玩家点击它时，调用clickPlay()函数（我们暂时还没有实现clickPlay()函数），然后将这个对象添加到舞台上以显示与交互。暂时不要担心按钮的位置，我们稍后将会调整。接下来我们需要定义clickPlay()函数，在类体内那个地方都行，但不要位于其他函数体内的位置，敲入以下代码：在这个函数里它调用了FlxG.switchState()，它的工作是从当前的状态（目前而言也就是MenuState）切换状态至一个新的PlayState实例。从技术上讲，目前为止我们所要实现的功能已经能正常工作了，你可以运行游戏并且会按我们的预期工作，但是我们还差几件事情没有做。首先，我们的按钮需要放置在一个更合理的位置，我们当然可以在创建按钮对象的时候通过传递 x 和 y 坐标值的方式来定义它的位置，但是这里有一个更简单的方法，回到create()函数里，在我们创建FlxButton对象之后，super.create()之前的位置（我会放在按钮对象被到舞台上之前的位置，但是这行代码放在其之后结果也是一样的）添加一行新的代码：screenCenter()函数的功能是将对象的坐标放在水平或垂直抑或（默认的）这两个方向上的中心位置。调用我们的按钮对象上的这个函数，它将会被放置于游戏画面的中心位置。然后我们需要确保游戏是从MenuState状态启动的。打开Main.hx文件，把对PlayState的引用替换成MenuState。如果你开始启动调试，它会显示一个黑色画面，其中间是我们的 “Play” 按钮，点击它会跳转到另一个黑色画面。如果你的结果如上所述，那么就表示一切正常！GREAT！之后我们还需要创建一个能够在画面里自由行走的简单的 player 精灵（player sprite)。首先，我们需要创建一个新的Player类，你可以把类理解为一个容纳了一系列函数的模板，你可以在项目中使用它们，而且还能够通过继承（extend）变为一个新的版本，你可以把继承理解成描摹纸（小时候描画的那种几乎透明的很薄的纸），当你要对一个类进行继承的时候，就类似于你铺了一张新的描摹纸在它上面 - 你依然可以看到上一张纸的内容并且能够描下来，而且你还能在其上添加更多新的东西。我们将要通过继承FlxSprite类来创建我们自己的Player类。在资源管理器里，右键点选 source 文件夹然后点击创建文件：新文件命名为Player.hx然后双击打开。由于 VSCode 环境下目前我还不知道有什么方法可以通过UI界面选择一个文件的父类再自动生成文件，所以下面需要手动敲码。正确添加之后界面大概会像这样：然后在Player.hx文件里敲入以下代码：这是一个标准的FlxSprite子类的结构，我们为了使用需要稍微修改一下。首先，去掉构造函数的SimpleGraphic参数，我们的Player精灵用不着这个参数。所以：改写成：还有：改写成：在类里面，我们使用 “super” 关键字来引用父类。所以在我们的 new()/构造函数 中，通过调用super(X,Y)我们是表示将它关联至父类，此例中也就是FlxSprite类，并调用父类构造函数，把传递给我们的 X 和 y 也传递给父类构造函数。这里有点细节：Haxe中的继承然后我们为了知道我们的精灵在哪我们为它创建一个 占位符图像（placeholder image），所以在super(X,Y)之后添加：（注意添加import代码导入FlxColor类：import flixel.util.FlxColor;）我们这里所做的事情是把这个对象创建为一个 16x16 大小的蓝色放块。现在我们要创建Player对象的实例确保这个对象能够正常工作，并把它添加到PlayState状态里。它暂时还不能移动或做其他任何事情，这个我们稍后会实现它，现在先保存Player.hx文件（Ctrl+S），然后回到PlayState文件里，我们要定义一个Player类的变量，在类体第一行位置添加以下代码：然后在creat()函数里super.create()；之前：这里所做的事情很简单，为我们的_player变量赋值了一个Player类的实例，告诉他放在(20,20)坐标位置处，并把它添加进PlayState状态里。如果你现在开始调试（可以通过F5打开调试），点击“Play”按钮你应该能看到以下运行结果：接下来我们来实现移动功能！我们要如何实现player在画面中自由走动的功能？我们要同时支持方向键与 WASD 键实现8个方向上的移动：上，下，左，右以及对角方向。玩家会以一个相对固定的速度移动，但是在停下来的时候会有一个轻微的减速效果来丰富交互体验。首先，我们先为 player 定义一个移动速度以及一个减速度量：在Player类里面，构造函数的上一行添加：接着在构造函数里，位于makeGraphic()的调用之前的位置，我们需要加入一点drag（这是一个FlxSprite对象的属性，我不知道怎样翻译比较准确，大概就是可以产生一个拖曳效果）：在 HaxeFlixel 中drag是实现当对象停止移动时产生减速运动的方式之一。它可以帮助我们当玩家停止按压任何移动按键时，阻止 player 精灵一直朝某个方向移动，我们稍后会调整drag的数值。尽管处理 player 运动的方式有多种多样，但我们可以简单的把处理运动的功能放在 player 类里边；我们要添加几个函数用于跟踪玩家的输入并给予反馈，敲入代码：在这个函数里，我们将定义一组辅助变量用于在之后的代码里表示当前哪个按键被玩家按压：接下来我们要知道玩家希望朝哪个方向移动，我们通过检查当前处于按压状态的按键来获知：anyPressed()函数可以获取列表中的按键目前是否处于按压状态；通过传递一个键值数组（数组元素就是按键的名字）当数组中任何一个按键被按压时它会返回true。稍后我们还会使用其他几个类似的函数来检查其他的按键状态。接下来我们需要处理方向冲突的情况，比如当玩家同时按下上和下时，player 会原地不动：接下来我们要完善真正实现 player 移动的代码：然后我们要确定 player 以多快的速度朝哪个方向移动，通常很多第一次实现此类功能的人会下意识的觉得这里开始应该这样实现：尽管技术上讲这样做确实能够使某个物体实现上下左右方向的移动，但是这样做会使得对角方向的移动比上下左右的移动速度更快；可以试想一下矩形的对角线肯定比矩形的任何一条单边更长。这里我们应该使用一点三角函数的知识来计算每个方向的移动速度。我们首先需要知道当玩家按下按键时 player 朝向哪个方位角，对于FlxSprite对象而言，0度角朝向右边，而 -90度（或 270度） 则是朝向上（也就是说正角是顺时针方向的，这一点与数学上的定义有些出入）。这里所做的事情是创建了一个临时变量用于保存我们的角度，然后基于玩家当前按压的按键改变其角度值。现在我们知道了 player 应该朝哪个方位角移动，之后我们还需要知道以多少速率（velocity）朝这个方向移动，我们通过为velocity.x赋值speed与velocity.y赋值0，然后围绕(0,0)坐标对这个点（point：velocity是一个FlxPoint对象）进行mA度的旋转来实现。最后闭合if语句的花括号，然后…这就是movement()函数的所有逻辑代码了。最后剩下的一件事情就是override重写update()函数，在里面调用我们的movement()：你要记住，update()函数在游戏运行中是每帧调用一次的，所以每当PlayState的update()被调用时，也会调用它所有成员的update()函数这其中包括我们的 player 对象的update()函数。如此一来也会调用我们的movement()逻辑，相应地调整player的velocity属性值，接着他会调用super.update()，这会将刚刚修改过的velocity的值用于计算精灵（player sprite）的下一个位置。哇哦~ 看起来似乎步骤比实际功能要更繁琐一些。如果你现在尝试运行游戏看看结果如何，你将发现你能够使用方向键和WASD键控制 player 在屏幕中游走了。下一节我们将开始创建一个 精灵序列（sprite sheet） 让 player 看起来更地道一些！"},{"title":"HaxeFlixel官方教程2:创建项目","date":"2018-06-12T05:22:13.000Z","url":"/2018/06/12/HaxeFlixel官方教程2-创建项目/","tags":["HaxeFlixel"],"content":"由于官网教程使用的环境是 HaxeDevelop/FlashDevelop IDE 作为代码的编辑，调试环境，而我是使用 VSCode ，所以环境的搭建我打算另外做一篇教程，并且在必要的时候对系列教程的原文稍作修改以适应我所使用的环境，而官网的教程我就直接从创建项目的部分开始搬运。原文2-创建一个新的项目现在我们要确定我们需要的东西都安装妥当，并为我们的游戏建立所需的框架。所以我们首先创建一个新的项目，使用 VSCode 打开项目并测试它是否正常构建并运行程序。在命令行窗口（开始-运行-cmd-回车）敲入以下指令：flixel tpl -n &quot;FlixelTut&quot;这个指令会在当前目录使用一个空白的模板创建一个新的 Flixel 项目并放置于 FlixelTut 文件夹内（因为我们以 FlixelTut 命名了该项目）如果你跟我一样使用 VSCode 作为开发环境，并且在 haxelib run flixel-tools setup 的时候配置了 VSCode 作为 flixel 创建项目的默认编辑器，并设置为创建新模板或 Demo 时自动启动，那么现在 VSCode 会自动启动并打开该项目。打开 VSCode 的资源管理器。在资源管理器里，你能够看到项目的结构，包含了模板为我们生成的所有文件。接下来我们要确定我们的项目能够正确的构建与运行。默认情况下，一个崭新的 Flixel 模板项目会从 PlayState 启动游戏。所以从资源管理器双击打开 source 文件夹下的 PlayState 文件。这是一个十分基础的 FlxState 子类的实例。你可以设想一下把 FlxState 看作是一个 “场景（scenes）” 。当你的游戏开始运行时有且只有一个 “状态（state）” 处于活动状态。玩家看得见摸得着的东西都是被“添加（added）”进该状态的，并且通常会把不共享资源的状态相互隔离。通常相互隔离的状态负责游戏的不同部分，比如游戏的开始菜单（MenuState）与游戏状态（PlayState），这些状态之间的关系有点像一个个泡泡（这个实在不知道如何翻译）They are great for having different sections of your game that are sort of in a bubble from one another, such as a MenuState (which we will add later) and the PlayState (where the game is actually played).稍后你将会看到，但目前为止 PlayState 只有包含了两个函数：create() 与 update()函数。当一个状态被加载进来，他的create()函数会立即被调用。你应该在这里对状态做一些初始化工作。update() 是所有奇妙的事物发生的地方，他会在游戏运行时按每帧一次的频率调用（默认情况下游戏是 每秒60帧 - 60fps）。当一个 FlxState 对象的 update() 被调用时，它也会调用被添加进该状态的对象的 update() 函数。这基本上就是你的游戏背后的工作原理。稍后我们会更详细的讨论。现在，我们只是想看看我们搭建的东西是不是能够正常运行，所以接下来让我们添加一个简单的 FlxText 对象到这个状态里。在文件的最上方，位于 import flixel.FlxState; 这一行下方添加以下代码：在 create() 函数里，位于 super.create(); 的前一行的位置添加以下代码:然后保存你的修改（Ctrl + s）The Moment of Truth! 点击 VSCode 左侧的小虫子图标打开调试窗口，然后点击绿色小箭头。如果你看到以下结果那么一切都很顺利：行了！你成功构建并运行了你的第一个 HaxeFlixel 项目！“Big things have small beginnings.”  —— 《Prometheus》下一节，我们将正式为我们的游戏做一些设计，并开始把每个设想实现整合。"},{"title":"HaxeFlixel官方教程:开篇","date":"2018-06-11T15:39:01.000Z","url":"/2018/06/11/HaxeFlixel官方教程-开篇/","tags":["HaxeFlixel"],"content":"原文欢迎来到 HaxeFlixel ！在这系列教程中，你将学习如何使用 HaxeFlixel 从头到尾创建一个完整的游戏，每一步骤都会被打碎成小片段以帮助你度过难关。这一系列教程可以面向 Flash，Windows，Aandroid 进行构建。但我们多数时候是编译到 Flash 平台。我们将要搭建一个 dungen crawler 小游戏。首先，让我聊一点关于为何你应该选择 HaxeFlixel :HaxeFlixel 的由来要追溯到由 Adam ‘Atomic’ Saltsman 开发的 AS3 Flixel 框架。如果你有玩过 Canabalt，那么你就见过过了这个框架的早期版本。HaxeFlixel 继承了 Flixel 的一般结构，从 Flash 平台分离出来并整合进强大的开源多平台语言 Haxe 中，所以你编写的游戏就可以简单的发布到各个平台上（Windows，Flash，iOS，Android等）。当你使用 HaxeFlixel 编写代码时尽管有些变化但与编写 AS3 代码没有太多差别。此外它拥有大量的内置特性 - 类，实用程序，以及函数 - 当你碰上一些常见或复杂的事情时它们可以帮你解决。并且因为 HaxeFlixel 是开源的，当你发现某些事情它做不到，那你可以修改它的源码，同时如果你的修改对其他人是有帮助的，可以把它们添加进 library。它是一个简单易用的代码库（library），而且给予了你足够的自由去实现你能够想到的任何事情，却不会被死板的接口而限制住。你可以从这里了解到更多有关于 HaxeFlixel ：链接"},{"title":"HelloWorld!","date":"2018-06-10T14:06:04.000Z","url":"/2018/06/10/HelloWorld/","content":"折腾了两天，总算是把博客重新部署回来了，博客的订阅源算是可以用了，欢迎视奸 :) 。由于最近在研究一个2D游戏框架——HaxeFlixel，为了自己回顾每天的学习进程，打算在学习过程里把一些东西整理一下放到博客上来，日后也可以分享给其他感兴趣的人学习。目前在跟HaxeFlixel官网的教程走一遍，由于还没有看到与这个框架有关的中文资料，接下来一段时间我跟到哪就顺便翻译到博客上来。"}]